; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_motor.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_motor.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I..\..\..\User\angle\gan_rui_Angle -I..\..\User\angle\yuan_zi_Angle -I..\..\User\dx8\inc -IF:\LuckyXRQ\CleanCar\NO_RTOS\Project\MDK-ARM(uV4)\RTE -ID:\soft\MDK5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\soft\MDK5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_motor.crf ..\..\User\app\src\bsp_motor.c]
                          THUMB

                          AREA ||i.bsp_InitMotor||, CODE, READONLY, ALIGN=1

                  bsp_InitMotor PROC
;;;32     */
;;;33     void bsp_InitMotor(void)
000000  b510              PUSH     {r4,lr}
;;;34     {
;;;35     	/*初始化PWM 20KHZ，用于驱动电机，10KHZ会有噪声*/
;;;36     	bsp_InitTimer1(3599,0); 
000002  2100              MOVS     r1,#0
000004  f640600f          MOV      r0,#0xe0f
000008  f7fffffe          BL       bsp_InitTimer1
;;;37     	bsp_InitTimer4(3599,0);
00000c  2100              MOVS     r1,#0
00000e  f640600f          MOV      r0,#0xe0f
000012  f7fffffe          BL       bsp_InitTimer4
;;;38     	bsp_InitVacuum();
000016  f7fffffe          BL       bsp_InitVacuum
;;;39     	
;;;40     }
00001a  bd10              POP      {r4,pc}
;;;41     
                          ENDP


                          AREA ||i.bsp_InitTimer1||, CODE, READONLY, ALIGN=2

                  bsp_InitTimer1 PROC
;;;229    */
;;;230    static void bsp_InitTimer1(uint16_t arr,uint16_t psc)
000000  b530              PUSH     {r4,r5,lr}
;;;231    {  
000002  b089              SUB      sp,sp,#0x24
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;232    	
;;;233    	GPIO_InitTypeDef   GPIO_InitStructure;
;;;234    	TIM_OCInitTypeDef  TIM_OCInitStructure;
;;;235    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;236    	
;;;237    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  02c8              LSLS     r0,r1,#11
00000c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;238     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE|RCC_APB2Periph_AFIO, ENABLE);
000010  2101              MOVS     r1,#1
000012  2041              MOVS     r0,#0x41
000014  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;239    	GPIO_PinRemapConfig(GPIO_FullRemap_TIM1, ENABLE); /*Timer1重映射*/     	
000018  2101              MOVS     r1,#1
00001a  4836              LDR      r0,|L2.244|
00001c  f7fffffe          BL       GPIO_PinRemapConfig
;;;240    
;;;241    	/*GPIO初始化*/
;;;242    	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_9|GPIO_Pin_11|GPIO_Pin_13|GPIO_Pin_14;
000020  f44f40d4          MOV      r0,#0x6a00
000024  f8ad0020          STRH     r0,[sp,#0x20]
;;;243    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;  //复用推挽输出
000028  2018              MOVS     r0,#0x18
00002a  f88d0023          STRB     r0,[sp,#0x23]
;;;244    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00002e  2003              MOVS     r0,#3
000030  f88d0022          STRB     r0,[sp,#0x22]
;;;245    	GPIO_Init(GPIOE, &GPIO_InitStructure);
000034  a908              ADD      r1,sp,#0x20
000036  4830              LDR      r0,|L2.248|
000038  f7fffffe          BL       GPIO_Init
;;;246    	
;;;247    	/*定时器初始化*/
;;;248    	TIM_TimeBaseStructure.TIM_Period 		= arr; 					
00003c  f8ad5008          STRH     r5,[sp,#8]
;;;249    	TIM_TimeBaseStructure.TIM_Prescaler     = psc; 					
000040  f8ad4004          STRH     r4,[sp,#4]
;;;250    	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; 		
000044  2000              MOVS     r0,#0
000046  f8ad000a          STRH     r0,[sp,#0xa]
;;;251    	TIM_TimeBaseStructure.TIM_CounterMode 	= TIM_CounterMode_Up;  	
00004a  f8ad0006          STRH     r0,[sp,#6]
;;;252    	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure); 
00004e  a901              ADD      r1,sp,#4
000050  482a              LDR      r0,|L2.252|
000052  f7fffffe          BL       TIM_TimeBaseInit
;;;253    	
;;;254    	/*
;;;255    	PWM一共有两种模式，PWM1模式：CNT<CRRx为有效电平（不包括等于）。CNT>=CRRx为无效电平。PWM2模式相反。
;;;256    	那么问题来了什么为有效电平？他又怎么确定？
;;;257    	它是由TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;输出极性来定的。
;;;258    	有效电平加输出极性就等于什么时候输出高电
;;;259    	*/ 
;;;260    	TIM_OCInitStructure.TIM_OCMode 		= TIM_OCMode_PWM1; 			
000056  2060              MOVS     r0,#0x60
000058  f8ad0010          STRH     r0,[sp,#0x10]
;;;261     	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; 	
00005c  2001              MOVS     r0,#1
00005e  f8ad0012          STRH     r0,[sp,#0x12]
;;;262    	TIM_OCInitStructure.TIM_OCPolarity  = TIM_OCPolarity_High;	
000062  2000              MOVS     r0,#0
000064  f8ad0018          STRH     r0,[sp,#0x18]
;;;263    
;;;264    	/*TIM1，TIM8必须使用，否则在RTOS中无法使用，暂时不了解原因*/
;;;265    	TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Disable;	/* only for TIM1 and TIM8. */	
000068  f8ad0014          STRH     r0,[sp,#0x14]
;;;266    	TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;			/* only for TIM1 and TIM8. */		
00006c  f8ad001a          STRH     r0,[sp,#0x1a]
;;;267    	TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Reset;		/* only for TIM1 and TIM8. */
000070  f8ad001c          STRH     r0,[sp,#0x1c]
;;;268    	TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCNIdleState_Reset;		/* only for TIM1 and TIM8. */
000074  f8ad001e          STRH     r0,[sp,#0x1e]
;;;269    	
;;;270    	/*CH1*/
;;;271    	TIM_OC1Init(TIM1, &TIM_OCInitStructure);	 
000078  a904              ADD      r1,sp,#0x10
00007a  4820              LDR      r0,|L2.252|
00007c  f7fffffe          BL       TIM_OC1Init
;;;272    	TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);
000080  2108              MOVS     r1,#8
000082  481e              LDR      r0,|L2.252|
000084  f7fffffe          BL       TIM_OC1PreloadConfig
;;;273    	
;;;274    	/*CH2*/
;;;275    	TIM_OC2Init(TIM1, &TIM_OCInitStructure); 
000088  a904              ADD      r1,sp,#0x10
00008a  481c              LDR      r0,|L2.252|
00008c  f7fffffe          BL       TIM_OC2Init
;;;276    	TIM_OC2PreloadConfig(TIM1, TIM_OCPreload_Enable);
000090  2108              MOVS     r1,#8
000092  481a              LDR      r0,|L2.252|
000094  f7fffffe          BL       TIM_OC2PreloadConfig
;;;277    	
;;;278    	/*CH3*/
;;;279    	TIM_OC3Init(TIM1, &TIM_OCInitStructure);	 
000098  a904              ADD      r1,sp,#0x10
00009a  4818              LDR      r0,|L2.252|
00009c  f7fffffe          BL       TIM_OC3Init
;;;280    	TIM_OC3PreloadConfig(TIM1, TIM_OCPreload_Enable);
0000a0  2108              MOVS     r1,#8
0000a2  4816              LDR      r0,|L2.252|
0000a4  f7fffffe          BL       TIM_OC3PreloadConfig
;;;281    	
;;;282    	/*CH4*/
;;;283    	TIM_OC4Init(TIM1, &TIM_OCInitStructure);	 
0000a8  a904              ADD      r1,sp,#0x10
0000aa  4814              LDR      r0,|L2.252|
0000ac  f7fffffe          BL       TIM_OC4Init
;;;284    	TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Enable);
0000b0  2108              MOVS     r1,#8
0000b2  4812              LDR      r0,|L2.252|
0000b4  f7fffffe          BL       TIM_OC4PreloadConfig
;;;285      
;;;286    	/*使能TIM1*/
;;;287    	TIM_Cmd(TIM1, ENABLE); 
0000b8  2101              MOVS     r1,#1
0000ba  4810              LDR      r0,|L2.252|
0000bc  f7fffffe          BL       TIM_Cmd
;;;288    	
;;;289    	/*TIM1，TIM8必须使用，其他定时器可使用或不使用*/
;;;290    	TIM_CtrlPWMOutputs(TIM1,ENABLE);
0000c0  2101              MOVS     r1,#1
0000c2  480e              LDR      r0,|L2.252|
0000c4  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;291    	
;;;292    	/*4个通道全部输出高电平*/
;;;293    	TIM_SetCompare1(TIM1,CONSTANT_HIGH_PWM);
0000c8  f44f6161          MOV      r1,#0xe10
0000cc  480b              LDR      r0,|L2.252|
0000ce  f7fffffe          BL       TIM_SetCompare1
;;;294    	TIM_SetCompare2(TIM1,CONSTANT_HIGH_PWM);
0000d2  f44f6161          MOV      r1,#0xe10
0000d6  4809              LDR      r0,|L2.252|
0000d8  f7fffffe          BL       TIM_SetCompare2
;;;295    	TIM_SetCompare3(TIM1,CONSTANT_HIGH_PWM);
0000dc  f44f6161          MOV      r1,#0xe10
0000e0  4806              LDR      r0,|L2.252|
0000e2  f7fffffe          BL       TIM_SetCompare3
;;;296    	TIM_SetCompare4(TIM1,CONSTANT_HIGH_PWM);
0000e6  f44f6161          MOV      r1,#0xe10
0000ea  4804              LDR      r0,|L2.252|
0000ec  f7fffffe          BL       TIM_SetCompare4
;;;297    	
;;;298    }
0000f0  b009              ADD      sp,sp,#0x24
0000f2  bd30              POP      {r4,r5,pc}
;;;299    
                          ENDP

                  |L2.244|
                          DCD      0x001600c0
                  |L2.248|
                          DCD      0x40011800
                  |L2.252|
                          DCD      0x40012c00

                          AREA ||i.bsp_InitTimer4||, CODE, READONLY, ALIGN=2

                  bsp_InitTimer4 PROC
;;;308    */
;;;309    static void bsp_InitTimer4(uint16_t arr,uint16_t psc)
000000  b530              PUSH     {r4,r5,lr}
;;;310    {  
000002  b089              SUB      sp,sp,#0x24
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;311    	
;;;312    	GPIO_InitTypeDef   GPIO_InitStructure;
;;;313    	TIM_OCInitTypeDef  TIM_OCInitStructure;
;;;314    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;315    	
;;;316    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
000008  2101              MOVS     r1,#1
00000a  2004              MOVS     r0,#4
00000c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;317     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD|RCC_APB2Periph_AFIO, ENABLE);
000010  2101              MOVS     r1,#1
000012  2021              MOVS     r0,#0x21
000014  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;318    	GPIO_PinRemapConfig(GPIO_Remap_TIM4, ENABLE); /*Timer1重映射*/     	
000018  2101              MOVS     r1,#1
00001a  0308              LSLS     r0,r1,#12
00001c  f7fffffe          BL       GPIO_PinRemapConfig
;;;319    
;;;320    	/*GPIO初始化*/
;;;321    	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_12 | GPIO_Pin_13 |GPIO_Pin_14 | GPIO_Pin_15;
000020  f44f4070          MOV      r0,#0xf000
000024  f8ad0020          STRH     r0,[sp,#0x20]
;;;322    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;  //复用推挽输出
000028  2018              MOVS     r0,#0x18
00002a  f88d0023          STRB     r0,[sp,#0x23]
;;;323    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00002e  2003              MOVS     r0,#3
000030  f88d0022          STRB     r0,[sp,#0x22]
;;;324    	GPIO_Init(GPIOD, &GPIO_InitStructure);
000034  a908              ADD      r1,sp,#0x20
000036  482b              LDR      r0,|L3.228|
000038  f7fffffe          BL       GPIO_Init
;;;325    	
;;;326    	/*定时器初始化*/
;;;327    	TIM_TimeBaseStructure.TIM_Period 		= arr; 					
00003c  f8ad5008          STRH     r5,[sp,#8]
;;;328    	TIM_TimeBaseStructure.TIM_Prescaler     = psc; 					
000040  f8ad4004          STRH     r4,[sp,#4]
;;;329    	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; 		
000044  2000              MOVS     r0,#0
000046  f8ad000a          STRH     r0,[sp,#0xa]
;;;330    	TIM_TimeBaseStructure.TIM_CounterMode 	= TIM_CounterMode_Up;  	
00004a  f8ad0006          STRH     r0,[sp,#6]
;;;331    	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure); 
00004e  a901              ADD      r1,sp,#4
000050  4825              LDR      r0,|L3.232|
000052  f7fffffe          BL       TIM_TimeBaseInit
;;;332    	
;;;333    	/*
;;;334    	PWM一共有两种模式，PWM1模式：CNT<CRRx为有效电平（不包括等于）。CNT>=CRRx为无效电平。PWM2模式相反。
;;;335    	那么问题来了什么为有效电平？他又怎么确定？
;;;336    	它是由TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;输出极性来定的。
;;;337    	有效电平加输出极性就等于什么时候输出高电
;;;338    	*/ 
;;;339    	TIM_OCInitStructure.TIM_OCMode 		= TIM_OCMode_PWM1; 			
000056  2060              MOVS     r0,#0x60
000058  f8ad0010          STRH     r0,[sp,#0x10]
;;;340     	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; 	
00005c  2001              MOVS     r0,#1
00005e  f8ad0012          STRH     r0,[sp,#0x12]
;;;341    	TIM_OCInitStructure.TIM_OCPolarity  = TIM_OCPolarity_High;	
000062  2000              MOVS     r0,#0
000064  f8ad0018          STRH     r0,[sp,#0x18]
;;;342    
;;;343    	/*TIM1，TIM8必须使用，否则在RTOS中无法使用，暂时不了解原因*/
;;;344    	#if 0
;;;345    	TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Disable;	/* only for TIM1 and TIM8. */	
;;;346    	TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;			/* only for TIM1 and TIM8. */		
;;;347    	TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Reset;		/* only for TIM1 and TIM8. */
;;;348    	TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCNIdleState_Reset;		/* only for TIM1 and TIM8. */
;;;349    	#endif
;;;350    	
;;;351    	/*CH1*/
;;;352    	TIM_OC1Init(TIM4, &TIM_OCInitStructure);	 
000068  a904              ADD      r1,sp,#0x10
00006a  481f              LDR      r0,|L3.232|
00006c  f7fffffe          BL       TIM_OC1Init
;;;353    	TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Enable);
000070  2108              MOVS     r1,#8
000072  481d              LDR      r0,|L3.232|
000074  f7fffffe          BL       TIM_OC1PreloadConfig
;;;354    	
;;;355    	/*CH2*/
;;;356    	TIM_OC2Init(TIM4, &TIM_OCInitStructure); 
000078  a904              ADD      r1,sp,#0x10
00007a  481b              LDR      r0,|L3.232|
00007c  f7fffffe          BL       TIM_OC2Init
;;;357    	TIM_OC2PreloadConfig(TIM4, TIM_OCPreload_Enable);
000080  2108              MOVS     r1,#8
000082  4819              LDR      r0,|L3.232|
000084  f7fffffe          BL       TIM_OC2PreloadConfig
;;;358    	
;;;359    	/*CH3*/
;;;360    	TIM_OC3Init(TIM4, &TIM_OCInitStructure);	 
000088  a904              ADD      r1,sp,#0x10
00008a  4817              LDR      r0,|L3.232|
00008c  f7fffffe          BL       TIM_OC3Init
;;;361    	TIM_OC3PreloadConfig(TIM4, TIM_OCPreload_Enable);
000090  2108              MOVS     r1,#8
000092  4815              LDR      r0,|L3.232|
000094  f7fffffe          BL       TIM_OC3PreloadConfig
;;;362    	
;;;363    	/*CH4*/
;;;364    	TIM_OC4Init(TIM4, &TIM_OCInitStructure);	 
000098  a904              ADD      r1,sp,#0x10
00009a  4813              LDR      r0,|L3.232|
00009c  f7fffffe          BL       TIM_OC4Init
;;;365    	TIM_OC4PreloadConfig(TIM4, TIM_OCPreload_Enable);
0000a0  2108              MOVS     r1,#8
0000a2  4811              LDR      r0,|L3.232|
0000a4  f7fffffe          BL       TIM_OC4PreloadConfig
;;;366      
;;;367    	/*使能TIM*/
;;;368    	TIM_Cmd(TIM4, ENABLE); 
0000a8  2101              MOVS     r1,#1
0000aa  480f              LDR      r0,|L3.232|
0000ac  f7fffffe          BL       TIM_Cmd
;;;369    	
;;;370    	/*TIM1，TIM8必须使用，其他定时器可使用或不使用*/
;;;371    	TIM_CtrlPWMOutputs(TIM4,ENABLE);
0000b0  2101              MOVS     r1,#1
0000b2  480d              LDR      r0,|L3.232|
0000b4  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;372    	
;;;373    	/*4个通道全部输出高电平*/
;;;374    	TIM_SetCompare1(TIM4,CONSTANT_HIGH_PWM);
0000b8  f44f6161          MOV      r1,#0xe10
0000bc  480a              LDR      r0,|L3.232|
0000be  f7fffffe          BL       TIM_SetCompare1
;;;375    	TIM_SetCompare2(TIM4,CONSTANT_HIGH_PWM);
0000c2  f44f6161          MOV      r1,#0xe10
0000c6  4808              LDR      r0,|L3.232|
0000c8  f7fffffe          BL       TIM_SetCompare2
;;;376    	TIM_SetCompare3(TIM4,CONSTANT_HIGH_PWM);
0000cc  f44f6161          MOV      r1,#0xe10
0000d0  4805              LDR      r0,|L3.232|
0000d2  f7fffffe          BL       TIM_SetCompare3
;;;377    	TIM_SetCompare4(TIM4,CONSTANT_HIGH_PWM);
0000d6  f44f6161          MOV      r1,#0xe10
0000da  4803              LDR      r0,|L3.232|
0000dc  f7fffffe          BL       TIM_SetCompare4
;;;378    	
;;;379    }
0000e0  b009              ADD      sp,sp,#0x24
0000e2  bd30              POP      {r4,r5,pc}
;;;380    
                          ENDP

                  |L3.228|
                          DCD      0x40011400
                  |L3.232|
                          DCD      0x40000800

                          AREA ||i.bsp_InitVacuum||, CODE, READONLY, ALIGN=2

                  bsp_InitVacuum PROC
;;;135    */
;;;136    static void bsp_InitVacuum(void)
000000  b508              PUSH     {r3,lr}
;;;137    {
;;;138    	GPIO_InitTypeDef GPIO_InitStructure;
;;;139    
;;;140    	/* 打开GPIO时钟 */
;;;141    	RCC_APB2PeriphClockCmd(RCC_ALL_VACUUM, ENABLE);
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;142    
;;;143    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;144    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;145    	
;;;146    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_VACUUM;
000016  2001              MOVS     r0,#1
000018  f8ad0000          STRH     r0,[sp,#0]
;;;147    	GPIO_Init(GPIO_PORT_VACUUM, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4804              LDR      r0,|L4.48|
000020  f7fffffe          BL       GPIO_Init
;;;148    	
;;;149    	GPIO_ResetBits(GPIO_PORT_VACUUM,GPIO_PIN_VACUUM);
000024  2101              MOVS     r1,#1
000026  4802              LDR      r0,|L4.48|
000028  f7fffffe          BL       GPIO_ResetBits
;;;150    }
00002c  bd08              POP      {r3,pc}
;;;151    
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      0x40010800

                          AREA ||i.bsp_MotorCleanSetPWM||, CODE, READONLY, ALIGN=2

                  bsp_MotorCleanSetPWM PROC
;;;91     */
;;;92     void bsp_MotorCleanSetPWM(MotorCleanSN sn, MotorCleanDir dir , uint16_t pwm)
000000  b570              PUSH     {r4-r6,lr}
;;;93     {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;94     	switch(sn)
000008  b116              CBZ      r6,|L5.16|
00000a  2e01              CMP      r6,#1
00000c  d126              BNE      |L5.92|
00000e  e012              B        |L5.54|
                  |L5.16|
;;;95     	{
;;;96     		case MotorRollingBrush:
;;;97     		{
;;;98     			if(dir == CW)
000010  b944              CBNZ     r4,|L5.36|
;;;99     			{
;;;100    				TIM_SetCompare1(TIM4,0);
000012  2100              MOVS     r1,#0
000014  4812              LDR      r0,|L5.96|
000016  f7fffffe          BL       TIM_SetCompare1
;;;101    				TIM_SetCompare2(TIM4,pwm);
00001a  4629              MOV      r1,r5
00001c  4810              LDR      r0,|L5.96|
00001e  f7fffffe          BL       TIM_SetCompare2
000022  e007              B        |L5.52|
                  |L5.36|
;;;102    			}
;;;103    			else
;;;104    			{
;;;105    				TIM_SetCompare1(TIM4,pwm);
000024  4629              MOV      r1,r5
000026  480e              LDR      r0,|L5.96|
000028  f7fffffe          BL       TIM_SetCompare1
;;;106    				TIM_SetCompare2(TIM4,0);
00002c  2100              MOVS     r1,#0
00002e  480c              LDR      r0,|L5.96|
000030  f7fffffe          BL       TIM_SetCompare2
                  |L5.52|
;;;107    			}
;;;108    		}break;
000034  e012              B        |L5.92|
                  |L5.54|
;;;109    		
;;;110    		case MotorSideBrush:
;;;111    		{
;;;112    			if(dir == CW)
000036  b944              CBNZ     r4,|L5.74|
;;;113    			{
;;;114    				TIM_SetCompare3(TIM4,0);
000038  2100              MOVS     r1,#0
00003a  4809              LDR      r0,|L5.96|
00003c  f7fffffe          BL       TIM_SetCompare3
;;;115    				TIM_SetCompare4(TIM4,pwm);
000040  4629              MOV      r1,r5
000042  4807              LDR      r0,|L5.96|
000044  f7fffffe          BL       TIM_SetCompare4
000048  e007              B        |L5.90|
                  |L5.74|
;;;116    			}
;;;117    			else
;;;118    			{
;;;119    				TIM_SetCompare3(TIM4,pwm);
00004a  4629              MOV      r1,r5
00004c  4804              LDR      r0,|L5.96|
00004e  f7fffffe          BL       TIM_SetCompare3
;;;120    				TIM_SetCompare4(TIM4,0);
000052  2100              MOVS     r1,#0
000054  4802              LDR      r0,|L5.96|
000056  f7fffffe          BL       TIM_SetCompare4
                  |L5.90|
;;;121    			}
;;;122    		}break;
00005a  bf00              NOP      
                  |L5.92|
00005c  bf00              NOP                            ;108
;;;123    
;;;124    	}
;;;125    }
00005e  bd70              POP      {r4-r6,pc}
;;;126    
                          ENDP

                  |L5.96|
                          DCD      0x40000800

                          AREA ||i.bsp_MotorSetPWM||, CODE, READONLY, ALIGN=2

                  bsp_MotorSetPWM PROC
;;;49     */
;;;50     void bsp_MotorSetPWM(MotorSN sn ,MotorDir dir,uint16_t pwm)
000000  b570              PUSH     {r4-r6,lr}
;;;51     {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;52     	switch(sn)
000008  b116              CBZ      r6,|L6.16|
00000a  2e01              CMP      r6,#1
00000c  d126              BNE      |L6.92|
00000e  e012              B        |L6.54|
                  |L6.16|
;;;53     	{
;;;54     		case MotorLeft:
;;;55     		{
;;;56     			if(dir == Forward)
000010  b944              CBNZ     r4,|L6.36|
;;;57     			{
;;;58     				TIM_SetCompare3(TIM1,0);
000012  2100              MOVS     r1,#0
000014  4812              LDR      r0,|L6.96|
000016  f7fffffe          BL       TIM_SetCompare3
;;;59     				TIM_SetCompare4(TIM1,pwm);
00001a  4629              MOV      r1,r5
00001c  4810              LDR      r0,|L6.96|
00001e  f7fffffe          BL       TIM_SetCompare4
000022  e007              B        |L6.52|
                  |L6.36|
;;;60     			}
;;;61     			else
;;;62     			{
;;;63     				TIM_SetCompare3(TIM1,pwm);
000024  4629              MOV      r1,r5
000026  480e              LDR      r0,|L6.96|
000028  f7fffffe          BL       TIM_SetCompare3
;;;64     				TIM_SetCompare4(TIM1,0);
00002c  2100              MOVS     r1,#0
00002e  480c              LDR      r0,|L6.96|
000030  f7fffffe          BL       TIM_SetCompare4
                  |L6.52|
;;;65     			}
;;;66     		}break;
000034  e012              B        |L6.92|
                  |L6.54|
;;;67     		
;;;68     		case MotorRight:
;;;69     		{
;;;70     			if(dir == Forward)
000036  b944              CBNZ     r4,|L6.74|
;;;71     			{
;;;72     				TIM_SetCompare1(TIM1,0);
000038  2100              MOVS     r1,#0
00003a  4809              LDR      r0,|L6.96|
00003c  f7fffffe          BL       TIM_SetCompare1
;;;73     				TIM_SetCompare2(TIM1,pwm);
000040  4629              MOV      r1,r5
000042  4807              LDR      r0,|L6.96|
000044  f7fffffe          BL       TIM_SetCompare2
000048  e007              B        |L6.90|
                  |L6.74|
;;;74     			}
;;;75     			else
;;;76     			{
;;;77     				TIM_SetCompare1(TIM1,pwm);
00004a  4629              MOV      r1,r5
00004c  4804              LDR      r0,|L6.96|
00004e  f7fffffe          BL       TIM_SetCompare1
;;;78     				TIM_SetCompare2(TIM1,0);
000052  2100              MOVS     r1,#0
000054  4802              LDR      r0,|L6.96|
000056  f7fffffe          BL       TIM_SetCompare2
                  |L6.90|
;;;79     			}
;;;80     		}break;
00005a  bf00              NOP      
                  |L6.92|
00005c  bf00              NOP                            ;66
;;;81     	}
;;;82     }
00005e  bd70              POP      {r4-r6,pc}
;;;83     
                          ENDP

                  |L6.96|
                          DCD      0x40012c00

                          AREA ||i.bsp_StartVacuum||, CODE, READONLY, ALIGN=2

                  bsp_StartVacuum PROC
;;;198    */
;;;199    void bsp_StartVacuum(void)
000000  2000              MOVS     r0,#0
;;;200    {
;;;201    	vacuum.tick = 0 ;
000002  4902              LDR      r1,|L7.12|
000004  6048              STR      r0,[r1,#4]  ; vacuum
;;;202    	vacuum.isRunning = true;
000006  2001              MOVS     r0,#1
000008  7008              STRB     r0,[r1,#0]
;;;203    }
00000a  4770              BX       lr
;;;204    
                          ENDP

                  |L7.12|
                          DCD      vacuum

                          AREA ||i.bsp_StopVacuum||, CODE, READONLY, ALIGN=2

                  bsp_StopVacuum PROC
;;;212    */
;;;213    void bsp_StopVacuum(void)
000000  b510              PUSH     {r4,lr}
;;;214    {
;;;215    	vacuum.isRunning = false;
000002  2000              MOVS     r0,#0
000004  4903              LDR      r1,|L8.20|
000006  7008              STRB     r0,[r1,#0]
;;;216    	vacuum.tick = 0 ;
000008  6048              STR      r0,[r1,#4]  ; vacuum
;;;217    	
;;;218    	GPIO_ResetBits(GPIO_PORT_VACUUM,GPIO_PIN_VACUUM);
00000a  2101              MOVS     r1,#1
00000c  4802              LDR      r0,|L8.24|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;219    }
000012  bd10              POP      {r4,pc}
;;;220    
                          ENDP

                  |L8.20|
                          DCD      vacuum
                  |L8.24|
                          DCD      0x40010800

                          AREA ||i.bsp_VacuumClean||, CODE, READONLY, ALIGN=2

                  bsp_VacuumClean PROC
;;;159    */
;;;160    void bsp_VacuumClean(void)
000000  b510              PUSH     {r4,lr}
;;;161    {	
;;;162    #if 1
;;;163    	
;;;164    	GPIO_SetBits(GPIOA,GPIO_Pin_0);
000002  2101              MOVS     r1,#1
000004  4801              LDR      r0,|L9.12|
000006  f7fffffe          BL       GPIO_SetBits
;;;165    #else
;;;166    	
;;;167    	const uint32_t max_tick = 5;
;;;168    	const uint32_t changeTick = 4;
;;;169    	
;;;170    	if(!vacuum.isRunning)
;;;171    		return ;
;;;172    
;;;173    	++vacuum.tick;
;;;174    	
;;;175    	if(vacuum.tick <= changeTick)
;;;176    	{
;;;177    		GPIO_SetBits(GPIOA,GPIO_Pin_0);
;;;178    	}
;;;179    	else if(vacuum.tick > changeTick && vacuum.tick <=max_tick)
;;;180    	{
;;;181    		GPIO_ResetBits(GPIOA,GPIO_Pin_0);
;;;182    	}
;;;183    	else
;;;184    	{
;;;185    		vacuum.tick = 0 ;
;;;186    	}
;;;187    #endif
;;;188    	
;;;189    }
00000a  bd10              POP      {r4,pc}
;;;190    
                          ENDP

                  |L9.12|
                          DCD      0x40010800

                          AREA ||.data||, DATA, ALIGN=2

                  vacuum
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\src\\bsp_motor.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_motor_c_714f68c8____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_bsp_motor_c_714f68c8____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_motor_c_714f68c8____REVSH|
#line 128
|__asm___11_bsp_motor_c_714f68c8____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
