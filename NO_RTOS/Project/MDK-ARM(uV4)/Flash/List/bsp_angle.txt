; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_angle.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_angle.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I..\..\..\User\angle\gan_rui_Angle -I..\..\User\angle\yuan_zi_Angle -IF:\LuckyXRQ\CleanCar\NO_RTOS\Project\MDK-ARM(uV4)\RTE -ID:\soft\MDK5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\soft\MDK5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_angle.crf ..\..\User\app\src\bsp_Angle.c]
                          THUMB

                          AREA ||i.bsp_AngleAdd||, CODE, READONLY, ALIGN=2

                  bsp_AngleAdd PROC
;;;359    */
;;;360    float bsp_AngleAdd(float angle1 , float angle2)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;361    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;362    	float ret = 0.0F;
000008  2400              MOVS     r4,#0
;;;363    	
;;;364    	ret = angle1 + angle2;
00000a  4631              MOV      r1,r6
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       __aeabi_fadd
000012  4604              MOV      r4,r0
;;;365    	
;;;366    	if(angle1>=0.0F)
000014  2100              MOVS     r1,#0
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       __aeabi_cfrcmple
00001c  d81e              BHI      |L1.92|
;;;367    	{
;;;368    		if(ret >= 0.0F && ret <= 180.0F)
00001e  2100              MOVS     r1,#0
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       __aeabi_cfrcmple
000026  d807              BHI      |L1.56|
000028  491b              LDR      r1,|L1.152|
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       __aeabi_cfcmple
000030  d802              BHI      |L1.56|
;;;369    		{
;;;370    			return ret ;
000032  4620              MOV      r0,r4
                  |L1.52|
;;;371    		}
;;;372    		else if(ret > 180.0F)
;;;373    		{
;;;374    			return -(180 - (ret-180.0F));
;;;375    		}
;;;376    		else
;;;377    		{
;;;378    			return ret ;
;;;379    		}
;;;380    	}
;;;381    	else
;;;382    	{
;;;383    		if(ret < 0.0F && ret > -180.0F)
;;;384    		{
;;;385    			return ret ;
;;;386    		}
;;;387    		else if(ret < -180.0F)
;;;388    		{
;;;389    			return (180-(-ret-180));
;;;390    		}
;;;391    		else
;;;392    		{
;;;393    			return ret ;
;;;394    		}
;;;395    	}
;;;396    }
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L1.56|
000038  4917              LDR      r1,|L1.152|
00003a  4620              MOV      r0,r4                 ;372
00003c  f7fffffe          BL       __aeabi_cfrcmple
000040  d20a              BCS      |L1.88|
000042  4915              LDR      r1,|L1.152|
000044  4620              MOV      r0,r4                 ;374
000046  f7fffffe          BL       __aeabi_fsub
00004a  4607              MOV      r7,r0                 ;374
00004c  4912              LDR      r1,|L1.152|
00004e  f7fffffe          BL       __aeabi_frsub
000052  f0804000          EOR      r0,r0,#0x80000000     ;374
000056  e7ed              B        |L1.52|
                  |L1.88|
000058  4620              MOV      r0,r4                 ;378
00005a  e7eb              B        |L1.52|
                  |L1.92|
00005c  2100              MOVS     r1,#0                 ;383
00005e  4620              MOV      r0,r4                 ;383
000060  f7fffffe          BL       __aeabi_cfcmple
000064  d206              BCS      |L1.116|
000066  490d              LDR      r1,|L1.156|
000068  4620              MOV      r0,r4                 ;383
00006a  f7fffffe          BL       __aeabi_cfrcmple
00006e  d201              BCS      |L1.116|
000070  4620              MOV      r0,r4                 ;385
000072  e7df              B        |L1.52|
                  |L1.116|
000074  4909              LDR      r1,|L1.156|
000076  4620              MOV      r0,r4                 ;387
000078  f7fffffe          BL       __aeabi_cfcmple
00007c  d20a              BCS      |L1.148|
00007e  f0844800          EOR      r8,r4,#0x80000000     ;389
000082  4905              LDR      r1,|L1.152|
000084  4640              MOV      r0,r8                 ;389
000086  f7fffffe          BL       __aeabi_fsub
00008a  4607              MOV      r7,r0                 ;389
00008c  4902              LDR      r1,|L1.152|
00008e  f7fffffe          BL       __aeabi_frsub
000092  e7cf              B        |L1.52|
                  |L1.148|
000094  4620              MOV      r0,r4                 ;393
000096  e7cd              B        |L1.52|
;;;8      
                          ENDP

                  |L1.152|
                          DCD      0x43340000
                  |L1.156|
                          DCD      0xc3340000

                          AREA ||i.bsp_AngleAnalyzeApp||, CODE, READONLY, ALIGN=2

                  bsp_AngleAnalyzeApp PROC
;;;303    */
;;;304    static void bsp_AngleAnalyzeApp(void)
000000  2000              MOVS     r0,#0
;;;305    {	
;;;306    	uint32_t val = 0;
;;;307    	
;;;308    	/*加速度X Y Z*/
;;;309    	val = angle.buf[12] << 24 | angle.buf[11] << 16 | angle.buf[10] << 8 | angle.buf[9];
000002  4937              LDR      r1,|L2.224|
000004  7c09              LDRB     r1,[r1,#0x10]
000006  060a              LSLS     r2,r1,#24
000008  4935              LDR      r1,|L2.224|
00000a  7bc9              LDRB     r1,[r1,#0xf]
00000c  ea424201          ORR      r2,r2,r1,LSL #16
000010  4933              LDR      r1,|L2.224|
000012  7b89              LDRB     r1,[r1,#0xe]
000014  ea422101          ORR      r1,r2,r1,LSL #8
000018  4a31              LDR      r2,|L2.224|
00001a  7b52              LDRB     r2,[r2,#0xd]
00001c  ea410002          ORR      r0,r1,r2
;;;310    	memcpy(&angle.accX , &val , 4);
000020  492f              LDR      r1,|L2.224|
000022  66c8              STR      r0,[r1,#0x6c]  ; angle
;;;311    	
;;;312    	val = angle.buf[16] << 24 | angle.buf[15] << 16 | angle.buf[14] << 8 | angle.buf[13];
000024  7d09              LDRB     r1,[r1,#0x14]
000026  060a              LSLS     r2,r1,#24
000028  492d              LDR      r1,|L2.224|
00002a  7cc9              LDRB     r1,[r1,#0x13]
00002c  ea424201          ORR      r2,r2,r1,LSL #16
000030  492b              LDR      r1,|L2.224|
000032  7c89              LDRB     r1,[r1,#0x12]
000034  ea422101          ORR      r1,r2,r1,LSL #8
000038  4a29              LDR      r2,|L2.224|
00003a  7c52              LDRB     r2,[r2,#0x11]
00003c  ea410002          ORR      r0,r1,r2
;;;313    	memcpy(&angle.accY , &val , 4);
000040  4927              LDR      r1,|L2.224|
000042  6708              STR      r0,[r1,#0x70]  ; angle
;;;314    	
;;;315    	val = angle.buf[20] << 24 | angle.buf[19] << 16 | angle.buf[18] << 8 | angle.buf[17];
000044  7e09              LDRB     r1,[r1,#0x18]
000046  060a              LSLS     r2,r1,#24
000048  4925              LDR      r1,|L2.224|
00004a  7dc9              LDRB     r1,[r1,#0x17]
00004c  ea424201          ORR      r2,r2,r1,LSL #16
000050  4923              LDR      r1,|L2.224|
000052  7d89              LDRB     r1,[r1,#0x16]
000054  ea422101          ORR      r1,r2,r1,LSL #8
000058  4a21              LDR      r2,|L2.224|
00005a  7d52              LDRB     r2,[r2,#0x15]
00005c  ea410002          ORR      r0,r1,r2
;;;316    	memcpy(&angle.accZ , &val , 4);
000060  491f              LDR      r1,|L2.224|
000062  6748              STR      r0,[r1,#0x74]  ; angle
;;;317    	
;;;318    	
;;;319    	/*角度X Y Z*/
;;;320    	val = angle.buf[57] << 24 | angle.buf[56] << 16 | angle.buf[55] << 8 | angle.buf[54];
000064  f891103d          LDRB     r1,[r1,#0x3d]
000068  060a              LSLS     r2,r1,#24
00006a  491d              LDR      r1,|L2.224|
00006c  f891103c          LDRB     r1,[r1,#0x3c]
000070  ea424201          ORR      r2,r2,r1,LSL #16
000074  491a              LDR      r1,|L2.224|
000076  f891103b          LDRB     r1,[r1,#0x3b]
00007a  ea422101          ORR      r1,r2,r1,LSL #8
00007e  4a18              LDR      r2,|L2.224|
000080  f892203a          LDRB     r2,[r2,#0x3a]
000084  ea410002          ORR      r0,r1,r2
;;;321    	memcpy(&angle.roll , &val , 4);
000088  4915              LDR      r1,|L2.224|
00008a  6788              STR      r0,[r1,#0x78]  ; angle
;;;322    	
;;;323    	val = angle.buf[61] << 24 | angle.buf[60] << 16 | angle.buf[59] << 8 | angle.buf[58];
00008c  f8911041          LDRB     r1,[r1,#0x41]
000090  060a              LSLS     r2,r1,#24
000092  4913              LDR      r1,|L2.224|
000094  f8911040          LDRB     r1,[r1,#0x40]
000098  ea424201          ORR      r2,r2,r1,LSL #16
00009c  4910              LDR      r1,|L2.224|
00009e  f891103f          LDRB     r1,[r1,#0x3f]
0000a2  ea422101          ORR      r1,r2,r1,LSL #8
0000a6  4a0e              LDR      r2,|L2.224|
0000a8  f892203e          LDRB     r2,[r2,#0x3e]
0000ac  ea410002          ORR      r0,r1,r2
;;;324    	memcpy(&angle.pitch , &val , 4);
0000b0  490b              LDR      r1,|L2.224|
0000b2  67c8              STR      r0,[r1,#0x7c]  ; angle
;;;325    	
;;;326    	val = angle.buf[65] << 24 | angle.buf[64] << 16 | angle.buf[63] << 8 | angle.buf[62];
0000b4  f8911045          LDRB     r1,[r1,#0x45]
0000b8  060a              LSLS     r2,r1,#24
0000ba  4909              LDR      r1,|L2.224|
0000bc  f8911044          LDRB     r1,[r1,#0x44]
0000c0  ea424201          ORR      r2,r2,r1,LSL #16
0000c4  4906              LDR      r1,|L2.224|
0000c6  f8911043          LDRB     r1,[r1,#0x43]
0000ca  ea422101          ORR      r1,r2,r1,LSL #8
0000ce  4a04              LDR      r2,|L2.224|
0000d0  f8922042          LDRB     r2,[r2,#0x42]
0000d4  ea410002          ORR      r0,r1,r2
;;;327    	memcpy(&angle.yaw , &val , 4);
0000d8  4901              LDR      r1,|L2.224|
0000da  f8c10080          STR      r0,[r1,#0x80]  ; angle
;;;328    	
;;;329    }
0000de  4770              BX       lr
;;;330    
                          ENDP

                  |L2.224|
                          DCD      angle

                          AREA ||i.bsp_AngleCheck||, CODE, READONLY, ALIGN=2

                  bsp_AngleCheck PROC
;;;236    */
;;;237    static bool bsp_AngleCheck(void)
000000  b570              PUSH     {r4-r6,lr}
;;;238    {
;;;239    	uint8_t i = 0 ;
000002  2400              MOVS     r4,#0
;;;240    	uint8_t sum = 0 ;
000004  2500              MOVS     r5,#0
;;;241    	
;;;242    	/*HEAD1*/
;;;243    	if( angle.buf[POS_HEAD1_CHK + 0] != 0x41 || 
000006  4834              LDR      r0,|L3.216|
000008  7900              LDRB     r0,[r0,#4]  ; angle
00000a  2841              CMP      r0,#0x41
00000c  d113              BNE      |L3.54|
;;;244    		angle.buf[POS_HEAD1_CHK + 1] != 0x78 || 
00000e  4832              LDR      r0,|L3.216|
000010  7940              LDRB     r0,[r0,#5]
000012  2878              CMP      r0,#0x78
000014  d10f              BNE      |L3.54|
;;;245    		angle.buf[POS_HEAD1_CHK + 2] != 0xFF || 
000016  4830              LDR      r0,|L3.216|
000018  7980              LDRB     r0,[r0,#6]
00001a  28ff              CMP      r0,#0xff
00001c  d10b              BNE      |L3.54|
;;;246    		angle.buf[POS_HEAD1_CHK + 3] != 0x06 || 
00001e  482e              LDR      r0,|L3.216|
000020  79c0              LDRB     r0,[r0,#7]
000022  2806              CMP      r0,#6
000024  d107              BNE      |L3.54|
;;;247    		angle.buf[POS_HEAD1_CHK + 4] != 0x81 || 
000026  482c              LDR      r0,|L3.216|
000028  7a00              LDRB     r0,[r0,#8]
00002a  2881              CMP      r0,#0x81
00002c  d103              BNE      |L3.54|
;;;248    		angle.buf[POS_HEAD1_CHK + 5] != 0x47)
00002e  482a              LDR      r0,|L3.216|
000030  7a40              LDRB     r0,[r0,#9]
000032  2847              CMP      r0,#0x47
000034  d001              BEQ      |L3.58|
                  |L3.54|
;;;249    	{
;;;250    		return false;
000036  2000              MOVS     r0,#0
                  |L3.56|
;;;251    	}
;;;252    	
;;;253    	/*HEAD2*/
;;;254    	if( angle.buf[POS_HEAD2_CHK + 0] != 0x00 || 
;;;255    		angle.buf[POS_HEAD2_CHK + 1] != 0x8C || 
;;;256    		angle.buf[POS_HEAD2_CHK + 2] != 0x0C)
;;;257    	{
;;;258    		return false;
;;;259    	}
;;;260    	
;;;261    	/*HEAD3*/
;;;262    	if( angle.buf[POS_HEAD3_CHK + 0] != 0x02 || 
;;;263    		angle.buf[POS_HEAD3_CHK + 1] != 0x8C || 
;;;264    		angle.buf[POS_HEAD3_CHK + 2] != 0x0C)
;;;265    	{
;;;266    		return false;
;;;267    	}
;;;268    	
;;;269    	/*HEAD4*/
;;;270    	if( angle.buf[POS_HEAD4_CHK + 0] != 0x01 || 
;;;271    		angle.buf[POS_HEAD4_CHK + 1] != 0xB0 || 
;;;272    		angle.buf[POS_HEAD4_CHK + 2] != 0x10)
;;;273    	{
;;;274    		return false;
;;;275    	}
;;;276    	
;;;277    	/*TAIL*/
;;;278    	if( angle.buf[POS_TAIL_CHK + 0] != 0x6D )
;;;279    	{
;;;280    		return false;
;;;281    	}
;;;282    	
;;;283    	for(i=0;i<SIZE_WITH_ROLL_PITCH - 2 ;i++)
;;;284    	{
;;;285    		sum += angle.buf[i];
;;;286    	}
;;;287    	
;;;288    	if(bsp_AngleChkXorCalc((uint8_t*)angle.buf,SIZE_WITH_ROLL_PITCH - 2) != angle.buf[POS_ANGLE_CHK])
;;;289    	{
;;;290    		return false;
;;;291    	}
;;;292    
;;;293    	return true;
;;;294    }	
000038  bd70              POP      {r4-r6,pc}
                  |L3.58|
00003a  4827              LDR      r0,|L3.216|
00003c  7e40              LDRB     r0,[r0,#0x19]         ;254
00003e  b938              CBNZ     r0,|L3.80|
000040  4825              LDR      r0,|L3.216|
000042  7e80              LDRB     r0,[r0,#0x1a]         ;255
000044  288c              CMP      r0,#0x8c              ;255
000046  d103              BNE      |L3.80|
000048  4823              LDR      r0,|L3.216|
00004a  7ec0              LDRB     r0,[r0,#0x1b]         ;256
00004c  280c              CMP      r0,#0xc               ;256
00004e  d001              BEQ      |L3.84|
                  |L3.80|
000050  2000              MOVS     r0,#0                 ;258
000052  e7f1              B        |L3.56|
                  |L3.84|
000054  4820              LDR      r0,|L3.216|
000056  f8900028          LDRB     r0,[r0,#0x28]         ;262
00005a  2802              CMP      r0,#2                 ;262
00005c  d109              BNE      |L3.114|
00005e  481e              LDR      r0,|L3.216|
000060  f8900029          LDRB     r0,[r0,#0x29]         ;263
000064  288c              CMP      r0,#0x8c              ;263
000066  d104              BNE      |L3.114|
000068  481b              LDR      r0,|L3.216|
00006a  f890002a          LDRB     r0,[r0,#0x2a]         ;264
00006e  280c              CMP      r0,#0xc               ;264
000070  d001              BEQ      |L3.118|
                  |L3.114|
000072  2000              MOVS     r0,#0                 ;266
000074  e7e0              B        |L3.56|
                  |L3.118|
000076  4818              LDR      r0,|L3.216|
000078  f8900037          LDRB     r0,[r0,#0x37]         ;270
00007c  2801              CMP      r0,#1                 ;270
00007e  d109              BNE      |L3.148|
000080  4815              LDR      r0,|L3.216|
000082  f8900038          LDRB     r0,[r0,#0x38]         ;271
000086  28b0              CMP      r0,#0xb0              ;271
000088  d104              BNE      |L3.148|
00008a  4813              LDR      r0,|L3.216|
00008c  f8900039          LDRB     r0,[r0,#0x39]         ;272
000090  2810              CMP      r0,#0x10              ;272
000092  d001              BEQ      |L3.152|
                  |L3.148|
000094  2000              MOVS     r0,#0                 ;274
000096  e7cf              B        |L3.56|
                  |L3.152|
000098  480f              LDR      r0,|L3.216|
00009a  f8900052          LDRB     r0,[r0,#0x52]         ;278
00009e  286d              CMP      r0,#0x6d              ;278
0000a0  d001              BEQ      |L3.166|
0000a2  2000              MOVS     r0,#0                 ;280
0000a4  e7c8              B        |L3.56|
                  |L3.166|
0000a6  2400              MOVS     r4,#0                 ;283
0000a8  e006              B        |L3.184|
                  |L3.170|
0000aa  480b              LDR      r0,|L3.216|
0000ac  1d00              ADDS     r0,r0,#4              ;285
0000ae  5d00              LDRB     r0,[r0,r4]            ;285
0000b0  4428              ADD      r0,r0,r5              ;285
0000b2  b2c5              UXTB     r5,r0                 ;285
0000b4  1c60              ADDS     r0,r4,#1              ;283
0000b6  b2c4              UXTB     r4,r0                 ;283
                  |L3.184|
0000b8  2c4d              CMP      r4,#0x4d              ;283
0000ba  dbf6              BLT      |L3.170|
0000bc  214d              MOVS     r1,#0x4d              ;288
0000be  4806              LDR      r0,|L3.216|
0000c0  1d00              ADDS     r0,r0,#4              ;288
0000c2  f7fffffe          BL       bsp_AngleChkXorCalc
0000c6  4904              LDR      r1,|L3.216|
0000c8  f8911051          LDRB     r1,[r1,#0x51]         ;288
0000cc  4288              CMP      r0,r1                 ;288
0000ce  d001              BEQ      |L3.212|
0000d0  2000              MOVS     r0,#0                 ;290
0000d2  e7b1              B        |L3.56|
                  |L3.212|
0000d4  2001              MOVS     r0,#1                 ;293
0000d6  e7af              B        |L3.56|
;;;295    
                          ENDP

                  |L3.216|
                          DCD      angle

                          AREA ||i.bsp_AngleChkXorCalc||, CODE, READONLY, ALIGN=1

                  bsp_AngleChkXorCalc PROC
;;;331    
;;;332    static uint8_t bsp_AngleChkXorCalc(uint8_t buf[] , uint8_t len)
000000  b510              PUSH     {r4,lr}
;;;333    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;334    	uint8_t i = 0 ;
000006  2100              MOVS     r1,#0
;;;335    	uint8_t chk = 0 ;
000008  2000              MOVS     r0,#0
;;;336    	
;;;337    	for(i=0;i<len;i++)
00000a  bf00              NOP      
00000c  e003              B        |L4.22|
                  |L4.14|
;;;338    	{
;;;339    		chk ^= buf[i];
00000e  5c54              LDRB     r4,[r2,r1]
000010  4060              EORS     r0,r0,r4
000012  1c4c              ADDS     r4,r1,#1              ;337
000014  b2e1              UXTB     r1,r4                 ;337
                  |L4.22|
000016  4299              CMP      r1,r3                 ;337
000018  dbf9              BLT      |L4.14|
;;;340    	}
;;;341    	
;;;342    	return chk;
;;;343    }
00001a  bd10              POP      {r4,pc}
;;;344    
                          ENDP


                          AREA ||i.bsp_AnglePoll||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  bsp_AnglePoll PROC
;;;197    */
;;;198    static void bsp_AnglePoll(void)
000000  b510              PUSH     {r4,lr}
;;;199    {	
;;;200    	if (angle.timeout == false)	/* 超过3.5个字符时间后执行MODH_RxTimeOut()函数。 */
000002  4810              LDR      r0,|L5.68|
000004  7800              LDRB     r0,[r0,#0]  ; angle
000006  b900              CBNZ     r0,|L5.10|
                  |L5.8|
;;;201    	{
;;;202    		/* 没有超时，继续接收。不要清零  */
;;;203    		return ;
;;;204    	}
;;;205    
;;;206    	/* 超时清零  */
;;;207    	angle.timeout = false;
;;;208    
;;;209    	if (angle.rxCount != SIZE_WITH_ROLL_PITCH)
;;;210    	{
;;;211    		WARNING("angle len err:%d\r\n",angle.rxCount);
;;;212    		goto err_ret;
;;;213    	}
;;;214    	
;;;215    	/* 计算SUM校验和 */
;;;216    	if(bsp_AngleCheck() == false)
;;;217    	{
;;;218    		WARNING("angle chk err:\r\n");
;;;219    		goto err_ret;
;;;220    	}
;;;221    	
;;;222    	/* 分析应用层协议 */
;;;223    	bsp_AngleAnalyzeApp();
;;;224    
;;;225    err_ret:
;;;226    	angle.rxCount = 0;	/* 必须清零计数器，方便下次帧同步 */
;;;227    }
000008  bd10              POP      {r4,pc}
                  |L5.10|
00000a  2000              MOVS     r0,#0                 ;207
00000c  490d              LDR      r1,|L5.68|
00000e  7008              STRB     r0,[r1,#0]            ;207
000010  4608              MOV      r0,r1                 ;209
000012  8840              LDRH     r0,[r0,#2]            ;209  ; angle
000014  284f              CMP      r0,#0x4f              ;209
000016  d005              BEQ      |L5.36|
000018  4608              MOV      r0,r1                 ;211
00001a  8841              LDRH     r1,[r0,#2]            ;211  ; angle
00001c  a00a              ADR      r0,|L5.72|
00001e  f7fffffe          BL       __2printf
000022  e009              B        |L5.56|
                  |L5.36|
000024  f7fffffe          BL       bsp_AngleCheck
000028  b918              CBNZ     r0,|L5.50|
00002a  a00c              ADR      r0,|L5.92|
00002c  f7fffffe          BL       __2printf
000030  e002              B        |L5.56|
                  |L5.50|
000032  f7fffffe          BL       bsp_AngleAnalyzeApp
000036  bf00              NOP                            ;225
                  |L5.56|
000038  2000              MOVS     r0,#0                 ;226
00003a  4902              LDR      r1,|L5.68|
00003c  8048              STRH     r0,[r1,#2]            ;226
00003e  bf00              NOP      
000040  e7e2              B        |L5.8|
;;;228    
                          ENDP

000042  0000              DCW      0x0000
                  |L5.68|
                          DCD      angle
                  |L5.72|
000048  616e676c          DCB      "angle len err:%d\r\n",0
00004c  65206c65
000050  6e206572
000054  723a2564
000058  0d0a00  
00005b  00                DCB      0
                  |L5.92|
00005c  616e676c          DCB      "angle chk err:\r\n",0
000060  65206368
000064  6b206572
000068  723a0d0a
00006c  00      
00006d  00                DCB      0
00006e  00                DCB      0
00006f  00                DCB      0

                          AREA ||i.bsp_AngleRead||, CODE, READONLY, ALIGN=1

                  bsp_AngleRead PROC
;;;28     */
;;;29     float bsp_AngleRead(void)
000000  b500              PUSH     {lr}
;;;30     {
;;;31     	return bsp_IMU_GetData(YAW);
000002  2005              MOVS     r0,#5
000004  f7fffffe          BL       bsp_IMU_GetData
;;;32     }
000008  bd00              POP      {pc}
;;;33     
                          ENDP


                          AREA ||i.bsp_AngleReadRaw||, CODE, READONLY, ALIGN=2

                  bsp_AngleReadRaw PROC
;;;41     */
;;;42     int16_t bsp_AngleReadRaw(void)
000000  b570              PUSH     {r4-r6,lr}
;;;43     {
;;;44     	return bsp_IMU_GetData(YAW)*100;
000002  2005              MOVS     r0,#5
000004  f7fffffe          BL       bsp_IMU_GetData
000008  4605              MOV      r5,r0
00000a  4904              LDR      r1,|L7.28|
00000c  f7fffffe          BL       __aeabi_fmul
000010  4604              MOV      r4,r0
000012  f7fffffe          BL       __aeabi_f2iz
000016  b200              SXTH     r0,r0
;;;45     }
000018  bd70              POP      {r4-r6,pc}
;;;46     
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x42c80000

                          AREA ||i.bsp_AngleRevByte||, CODE, READONLY, ALIGN=2

                  bsp_AngleRevByte PROC
;;;146    */
;;;147    void bsp_AngleRevByte(uint8_t byte)
000000  b570              PUSH     {r4-r6,lr}
;;;148    {
000002  4604              MOV      r4,r0
;;;149    	/*
;;;150    		3.5个字符的时间间隔，只是用在RTU模式下面，因为RTU模式没有开始符和结束符，
;;;151    		两个数据包之间只能靠时间间隔来区分，Modbus定义在不同的波特率下，间隔时间是不一样的，
;;;152    		所以就是3.5个字符的时间，波特率高，这个时间间隔就小，波特率低，这个时间间隔相应就大
;;;153    
;;;154    		4800  = 7.297ms
;;;155    		9600  = 3.646ms
;;;156    		19200  = 1.771ms
;;;157    		38400  = 0.885ms
;;;158    	*/
;;;159    	uint32_t timeout;
;;;160    
;;;161    	angle.timeout = false;
000004  2000              MOVS     r0,#0
000006  490a              LDR      r1,|L8.48|
000008  7008              STRB     r0,[r1,#0]
;;;162    	
;;;163    	timeout = 35000000 / RX_BAUD;		/* 计算超时时间，单位us 35000000*/
00000a  f240152f          MOV      r5,#0x12f
;;;164    	
;;;165    	/* 硬件定时中断，定时精度us*/
;;;166    	bsp_StartHardTimer(3, timeout, (void *)bsp_AngleTimeout);
00000e  4a09              LDR      r2,|L8.52|
000010  4629              MOV      r1,r5
000012  2003              MOVS     r0,#3
000014  f7fffffe          BL       bsp_StartHardTimer
;;;167    
;;;168    	if (angle.rxCount < RX_BUF_SIZE)
000018  4805              LDR      r0,|L8.48|
00001a  8840              LDRH     r0,[r0,#2]  ; angle
00001c  2860              CMP      r0,#0x60
00001e  da06              BGE      |L8.46|
;;;169    	{
;;;170    		angle.buf[angle.rxCount++] = byte;
000020  4903              LDR      r1,|L8.48|
000022  8848              LDRH     r0,[r1,#2]  ; angle
000024  1c41              ADDS     r1,r0,#1
000026  4a02              LDR      r2,|L8.48|
000028  8051              STRH     r1,[r2,#2]
00002a  1d11              ADDS     r1,r2,#4
00002c  540c              STRB     r4,[r1,r0]
                  |L8.46|
;;;171    	}
;;;172    }
00002e  bd70              POP      {r4-r6,pc}
;;;173    
                          ENDP

                  |L8.48|
                          DCD      angle
                  |L8.52|
                          DCD      bsp_AngleTimeout

                          AREA ||i.bsp_AngleRst||, CODE, READONLY, ALIGN=2

                  bsp_AngleRst PROC
;;;127    */
;;;128    void bsp_AngleRst(void)
000000  b510              PUSH     {r4,lr}
;;;129    {
;;;130    	GPIO_SetBits(GPIO_PORT_RST,GPIO_PIN_RST);
000002  2102              MOVS     r1,#2
000004  4808              LDR      r0,|L9.40|
000006  f7fffffe          BL       GPIO_SetBits
;;;131    	bsp_DelayMS(10);
00000a  200a              MOVS     r0,#0xa
00000c  f7fffffe          BL       bsp_DelayMS
;;;132    	GPIO_ResetBits(GPIO_PORT_RST,GPIO_PIN_RST);
000010  2102              MOVS     r1,#2
000012  4805              LDR      r0,|L9.40|
000014  f7fffffe          BL       GPIO_ResetBits
;;;133    	bsp_DelayMS(10);
000018  200a              MOVS     r0,#0xa
00001a  f7fffffe          BL       bsp_DelayMS
;;;134    	GPIO_SetBits(GPIO_PORT_RST,GPIO_PIN_RST);
00001e  2102              MOVS     r1,#2
000020  4801              LDR      r0,|L9.40|
000022  f7fffffe          BL       GPIO_SetBits
;;;135    }
000026  bd10              POP      {r4,pc}
;;;136    
                          ENDP

                  |L9.40|
                          DCD      0x40010800

                          AREA ||i.bsp_AngleTimeout||, CODE, READONLY, ALIGN=2

                  bsp_AngleTimeout PROC
;;;181    */
;;;182    static void bsp_AngleTimeout(void)
000000  b510              PUSH     {r4,lr}
;;;183    {
;;;184    	angle.timeout = true;
000002  2001              MOVS     r0,#1
000004  4902              LDR      r1,|L10.16|
000006  7008              STRB     r0,[r1,#0]
;;;185    	
;;;186    	bsp_AnglePoll();
000008  f7fffffe          BL       bsp_AnglePoll
;;;187    }
00000c  bd10              POP      {r4,pc}
;;;188    
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      angle

                          AREA ||i.bsp_IMU_Calibration||, CODE, READONLY, ALIGN=2

                  bsp_IMU_Calibration PROC
;;;345    
;;;346    void bsp_IMU_Calibration(void)
000000  b510              PUSH     {r4,lr}
;;;347    {
;;;348    	comSendBuf(COM2,CalibrationBuf,CALIBRATION_SIZE);
000002  2208              MOVS     r2,#8
000004  4902              LDR      r1,|L11.16|
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       comSendBuf
;;;349    }
00000c  bd10              POP      {r4,pc}
;;;350    
                          ENDP

00000e  0000              DCW      0x0000
                  |L11.16|
                          DCD      CalibrationBuf

                          AREA ||i.bsp_IMU_GetData||, CODE, READONLY, ALIGN=2

                  bsp_IMU_GetData PROC
;;;56     */
;;;57     float bsp_IMU_GetData(IMU_DATA_TYPE type)
000000  4601              MOV      r1,r0
;;;58     {
;;;59     	float data = 0.0F;
000002  2000              MOVS     r0,#0
;;;60     	
;;;61     	switch(type)
000004  2906              CMP      r1,#6
000006  d217              BCS      |L12.56|
000008  e8dff001          TBB      [pc,r1]
00000c  0306090c          DCB      0x03,0x06,0x09,0x0c
000010  0f12              DCB      0x0f,0x12
;;;62     	{
;;;63     		case ACC_X:
;;;64     		{
;;;65     			data = angle.accX;
000012  4a0a              LDR      r2,|L12.60|
000014  6ed0              LDR      r0,[r2,#0x6c]  ; angle
;;;66     		}break;
000016  e00f              B        |L12.56|
;;;67     		
;;;68     		case ACC_Y:
;;;69     		{
;;;70     			data = angle.accY;
000018  4a08              LDR      r2,|L12.60|
00001a  6f10              LDR      r0,[r2,#0x70]  ; angle
;;;71     		}break;
00001c  e00c              B        |L12.56|
;;;72     		
;;;73     		case ACC_Z:
;;;74     		{
;;;75     			data = angle.accZ;
00001e  4a07              LDR      r2,|L12.60|
000020  6f50              LDR      r0,[r2,#0x74]  ; angle
;;;76     		}break;
000022  e009              B        |L12.56|
;;;77     		
;;;78     		case PITCH:
;;;79     		{
;;;80     			data = angle.pitch;
000024  4a05              LDR      r2,|L12.60|
000026  6fd0              LDR      r0,[r2,#0x7c]  ; angle
;;;81     		}break;
000028  e006              B        |L12.56|
;;;82     		
;;;83     		case ROLL:
;;;84     		{
;;;85     			data = angle.roll;
00002a  4a04              LDR      r2,|L12.60|
00002c  6f90              LDR      r0,[r2,#0x78]  ; angle
;;;86     		}break;
00002e  e003              B        |L12.56|
;;;87     		
;;;88     		case YAW:
;;;89     		{
;;;90     			data = angle.yaw;
000030  4a02              LDR      r2,|L12.60|
000032  f8d20080          LDR      r0,[r2,#0x80]  ; angle
;;;91     		}break;
000036  bf00              NOP      
                  |L12.56|
000038  bf00              NOP                            ;66
;;;92     	}
;;;93     	
;;;94     	return data;
;;;95     }
00003a  4770              BX       lr
;;;96     
                          ENDP

                  |L12.60|
                          DCD      angle

                          AREA ||i.bsp_InitAngle||, CODE, READONLY, ALIGN=2

                  bsp_InitAngle PROC
;;;104    */
;;;105    void bsp_InitAngle(void)
000000  b508              PUSH     {r3,lr}
;;;106    {
;;;107    	GPIO_InitTypeDef GPIO_InitStructure;
;;;108    
;;;109    	/* 打开GPIO时钟 */
;;;110    	RCC_APB2PeriphClockCmd(RCC_ALL_ANGLE, ENABLE);
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;111    
;;;112    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;113    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;	
000010  2014              MOVS     r0,#0x14
000012  f88d0003          STRB     r0,[sp,#3]
;;;114    	
;;;115    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_RST;
000016  2002              MOVS     r0,#2
000018  f8ad0000          STRH     r0,[sp,#0]
;;;116    	GPIO_Init(GPIO_PORT_RST, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4802              LDR      r0,|L13.40|
000020  f7fffffe          BL       GPIO_Init
;;;117    
;;;118    }
000024  bd08              POP      {r3,pc}
;;;119    
                          ENDP

000026  0000              DCW      0x0000
                  |L13.40|
                          DCD      0x40010800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  angle
                          %        132

                          AREA ||.data||, DATA, ALIGN=0

                  CalibrationBuf
000000  4178ff06          DCB      0x41,0x78,0xff,0x06
000004  0200c26d          DCB      0x02,0x00,0xc2,0x6d

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\src\\bsp_Angle.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_Angle_c_f16e245a____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_bsp_Angle_c_f16e245a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_Angle_c_f16e245a____REVSH|
#line 128
|__asm___11_bsp_Angle_c_f16e245a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
