; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_cliffsw.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_cliffsw.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I..\..\..\User\angle\gan_rui_Angle -I..\..\User\angle\yuan_zi_Angle -IF:\LuckyXRQ\CleanCar\NO_RTOS\Project\MDK-ARM(uV4)\RTE -ID:\soft\MDK5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\soft\MDK5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_cliffsw.crf ..\..\User\app\src\bsp_CliffSW.c]
                          THUMB

                          AREA ||i.bsp_CliffCalibration||, CODE, READONLY, ALIGN=2

                  bsp_CliffCalibration PROC
;;;216    */
;;;217    void bsp_CliffCalibration(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;218    {
;;;219    	/*初始值*/
;;;220    #if 1
;;;221    	uint8_t i = 0 ;
000004  2400              MOVS     r4,#0
;;;222    	double sum = 0 ;
000006  bf00              NOP      
;;;223    	
;;;224    	/*左边初始值*/
;;;225    	sum = 0 ;
000008  2100              MOVS     r1,#0
00000a  460d              MOV      r5,r1
00000c  460e              MOV      r6,r1
;;;226    	for(i=0;i<VOLTAGE_FILTERING_COUNT;i++)
00000e  bf00              NOP      
000010  e00e              B        |L1.48|
                  |L1.18|
;;;227    	{
;;;228    		sum += bsp_GetCliffVoltage(CliffLeft);
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       bsp_GetCliffVoltage
000018  4681              MOV      r9,r0
00001a  f7fffffe          BL       __aeabi_f2d
00001e  4607              MOV      r7,r0
000020  462a              MOV      r2,r5
000022  4633              MOV      r3,r6
000024  f7fffffe          BL       __aeabi_dadd
000028  4605              MOV      r5,r0
00002a  460e              MOV      r6,r1
00002c  1c60              ADDS     r0,r4,#1              ;226
00002e  b2c4              UXTB     r4,r0                 ;226
                  |L1.48|
000030  2c32              CMP      r4,#0x32              ;226
000032  dbee              BLT      |L1.18|
;;;229    	}
;;;230    	cliff[CliffLeft].initializeVoltage = sum / VOLTAGE_FILTERING_COUNT;
000034  2200              MOVS     r2,#0
000036  4b29              LDR      r3,|L1.220|
000038  4628              MOV      r0,r5
00003a  4631              MOV      r1,r6
00003c  f7fffffe          BL       __aeabi_ddiv
000040  4607              MOV      r7,r0
000042  f7fffffe          BL       __aeabi_d2f
000046  4926              LDR      r1,|L1.224|
000048  6048              STR      r0,[r1,#4]  ; cliff
;;;231    	
;;;232    	/*中间初始值*/
;;;233    	sum = 0 ;
00004a  2100              MOVS     r1,#0
00004c  460d              MOV      r5,r1
00004e  460e              MOV      r6,r1
;;;234    	for(i=0;i<VOLTAGE_FILTERING_COUNT;i++)
000050  2400              MOVS     r4,#0
000052  e00e              B        |L1.114|
                  |L1.84|
;;;235    	{
;;;236    		sum += bsp_GetCliffVoltage(CliffMiddle);
000054  2001              MOVS     r0,#1
000056  f7fffffe          BL       bsp_GetCliffVoltage
00005a  4681              MOV      r9,r0
00005c  f7fffffe          BL       __aeabi_f2d
000060  4607              MOV      r7,r0
000062  462a              MOV      r2,r5
000064  4633              MOV      r3,r6
000066  f7fffffe          BL       __aeabi_dadd
00006a  4605              MOV      r5,r0
00006c  460e              MOV      r6,r1
00006e  1c60              ADDS     r0,r4,#1              ;234
000070  b2c4              UXTB     r4,r0                 ;234
                  |L1.114|
000072  2c32              CMP      r4,#0x32              ;234
000074  dbee              BLT      |L1.84|
;;;237    	}
;;;238    	cliff[CliffMiddle].initializeVoltage = sum / VOLTAGE_FILTERING_COUNT;
000076  2200              MOVS     r2,#0
000078  4b18              LDR      r3,|L1.220|
00007a  4628              MOV      r0,r5
00007c  4631              MOV      r1,r6
00007e  f7fffffe          BL       __aeabi_ddiv
000082  4607              MOV      r7,r0
000084  f7fffffe          BL       __aeabi_d2f
000088  4915              LDR      r1,|L1.224|
00008a  6108              STR      r0,[r1,#0x10]
;;;239    	
;;;240    	/*右边初始值*/
;;;241    	sum = 0 ;
00008c  2100              MOVS     r1,#0
00008e  460d              MOV      r5,r1
000090  460e              MOV      r6,r1
;;;242    	for(i=0;i<VOLTAGE_FILTERING_COUNT;i++)
000092  2400              MOVS     r4,#0
000094  e00e              B        |L1.180|
                  |L1.150|
;;;243    	{
;;;244    		sum += bsp_GetCliffVoltage(CliffRight);
000096  2002              MOVS     r0,#2
000098  f7fffffe          BL       bsp_GetCliffVoltage
00009c  4681              MOV      r9,r0
00009e  f7fffffe          BL       __aeabi_f2d
0000a2  4607              MOV      r7,r0
0000a4  462a              MOV      r2,r5
0000a6  4633              MOV      r3,r6
0000a8  f7fffffe          BL       __aeabi_dadd
0000ac  4605              MOV      r5,r0
0000ae  460e              MOV      r6,r1
0000b0  1c60              ADDS     r0,r4,#1              ;242
0000b2  b2c4              UXTB     r4,r0                 ;242
                  |L1.180|
0000b4  2c32              CMP      r4,#0x32              ;242
0000b6  dbee              BLT      |L1.150|
;;;245    	}
;;;246    	cliff[CliffRight].initializeVoltage = sum / VOLTAGE_FILTERING_COUNT;
0000b8  2200              MOVS     r2,#0
0000ba  4b08              LDR      r3,|L1.220|
0000bc  4628              MOV      r0,r5
0000be  4631              MOV      r1,r6
0000c0  f7fffffe          BL       __aeabi_ddiv
0000c4  4607              MOV      r7,r0
0000c6  f7fffffe          BL       __aeabi_d2f
0000ca  4905              LDR      r1,|L1.224|
0000cc  61c8              STR      r0,[r1,#0x1c]
;;;247    	
;;;248    	/*阈值*/
;;;249    	cliff[CliffLeft].threshold =   1.6F;
0000ce  4805              LDR      r0,|L1.228|
0000d0  6008              STR      r0,[r1,#0]  ; cliff
;;;250    	cliff[CliffMiddle].threshold = 1.6F;
0000d2  60c8              STR      r0,[r1,#0xc]  ; cliff
;;;251    	cliff[CliffRight].threshold =  1.6F;
0000d4  6188              STR      r0,[r1,#0x18]  ; cliff
;;;252    #else
;;;253    	cliff[CliffLeft].initializeVoltage =   3.3F;
;;;254    	cliff[CliffMiddle].initializeVoltage = 3.3F;
;;;255    	cliff[CliffRight].initializeVoltage =  3.3F;
;;;256    	
;;;257    	cliff[CliffLeft].threshold =   1.6F;
;;;258    	cliff[CliffMiddle].threshold = 1.6F;
;;;259    	cliff[CliffRight].threshold =  1.6F;
;;;260    #endif
;;;261    	
;;;262    	UNUSED(cliff);
;;;263    }
0000d6  e8bd87f0          POP      {r4-r10,pc}
;;;264    
                          ENDP

0000da  0000              DCW      0x0000
                  |L1.220|
                          DCD      0x40490000
                  |L1.224|
                          DCD      cliff
                  |L1.228|
                          DCD      0x3fcccccd

                          AREA ||i.bsp_CliffIsDangerous||, CODE, READONLY, ALIGN=2

                  bsp_CliffIsDangerous PROC
;;;272    */
;;;273    bool bsp_CliffIsDangerous(CliffSWSN sn)
000000  b570              PUSH     {r4-r6,lr}
;;;274    {
000002  4604              MOV      r4,r0
;;;275    
;;;276    	cliff[sn].currentVoltage = bsp_GetCliffVoltage(sn);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       bsp_GetCliffVoltage
00000a  eb040144          ADD      r1,r4,r4,LSL #1
00000e  4a0f              LDR      r2,|L2.76|
000010  eb020181          ADD      r1,r2,r1,LSL #2
000014  6088              STR      r0,[r1,#8]
;;;277    	if(cliff[sn].initializeVoltage - cliff[sn].currentVoltage >= cliff[sn].threshold)
000016  eb040244          ADD      r2,r4,r4,LSL #1
00001a  4b0c              LDR      r3,|L2.76|
00001c  eb030282          ADD      r2,r3,r2,LSL #2
000020  6891              LDR      r1,[r2,#8]
000022  eb040244          ADD      r2,r4,r4,LSL #1
000026  eb030282          ADD      r2,r3,r2,LSL #2
00002a  6850              LDR      r0,[r2,#4]
00002c  f7fffffe          BL       __aeabi_fsub
000030  4605              MOV      r5,r0
000032  eb040044          ADD      r0,r4,r4,LSL #1
000036  4a05              LDR      r2,|L2.76|
000038  f8521020          LDR      r1,[r2,r0,LSL #2]
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       __aeabi_cfrcmple
000042  d801              BHI      |L2.72|
;;;278    	{
;;;279    		//bsp_SetMotorSpeed(MotorLeft, 0);
;;;280    		//bsp_SetMotorSpeed(MotorRight,0);
;;;281    		
;;;282    		return true;
000044  2001              MOVS     r0,#1
                  |L2.70|
;;;283    	}
;;;284    	
;;;285    	return false;
;;;286    }
000046  bd70              POP      {r4-r6,pc}
                  |L2.72|
000048  2000              MOVS     r0,#0                 ;285
00004a  e7fc              B        |L2.70|
;;;287    
                          ENDP

                  |L2.76|
                          DCD      cliff

                          AREA ||i.bsp_CliffTest||, CODE, READONLY, ALIGN=2

                  bsp_CliffTest PROC
;;;336    
;;;337    void bsp_CliffTest(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;338    {
;;;339    	if(!cliffTest.isRunning)
000004  4865              LDR      r0,|L3.412|
000006  7800              LDRB     r0,[r0,#0]  ; cliffTest
000008  b920              CBNZ     r0,|L3.20|
;;;340    	{
;;;341    		isErlangGod = false;
00000a  2000              MOVS     r0,#0
00000c  4964              LDR      r1,|L3.416|
00000e  7008              STRB     r0,[r1,#0]
                  |L3.16|
;;;342    		return;
;;;343    	}
;;;344    	
;;;345    	switch(cliffTest.action)
;;;346    	{
;;;347    		case 0: /*直行*/
;;;348    		{
;;;349    
;;;350    			if(bsp_GetInfraRedAdcVoltage(IR7) >= 1.0F
;;;351    				||bsp_GetInfraRedAdcVoltage(IR2) >= 1.0F
;;;352    				||bsp_GetInfraRedAdcVoltage(IR3) >= 1.0F
;;;353    				||bsp_GetInfraRedAdcVoltage(IR4) >= 1.0F)
;;;354    			{
;;;355    				isErlangGod = true;
;;;356    			}
;;;357    			
;;;358    			
;;;359    			cliffTest.action++;
;;;360    		}break;
;;;361    		
;;;362    		case 1: /*检测是否有悬崖触发了*/
;;;363    		{
;;;364    			if(bsp_CliffIsDangerous(CliffLeft) ||
;;;365    				bsp_CliffIsDangerous(CliffMiddle) ||
;;;366    			    bsp_CliffIsDangerous(CliffRight) ||
;;;367    			    bsp_CollisionScan() != CollisionNone)
;;;368    			{
;;;369    				DEBUG("悬崖触发\r\n");
;;;370    				bsp_SetMotorSpeed(MotorLeft, 0);
;;;371    			    bsp_SetMotorSpeed(MotorRight,0);
;;;372    				cliffTest.action++;
;;;373    				
;;;374    				isErlangGod = false;
;;;375    			}
;;;376    			else
;;;377    				
;;;378    			{
;;;379    				if(isErlangGod)
;;;380    				{
;;;381    					bsp_SetMotorSpeed(MotorLeft, 6);
;;;382    					bsp_SetMotorSpeed(MotorRight,6);
;;;383    				}
;;;384    				else
;;;385    				{
;;;386    					bsp_SetMotorSpeed(MotorLeft, 12);
;;;387    					bsp_SetMotorSpeed(MotorRight,12);
;;;388    				}
;;;389    				cliffTest.action = 0 ;
;;;390    			}
;;;391    		}break;
;;;392    		
;;;393    		case 2:
;;;394    		{
;;;395    			cliffTest.pulse = bsp_GetCurrentBothPulse();
;;;396    			bsp_SetMotorSpeed(MotorLeft, -6);
;;;397    			bsp_SetMotorSpeed(MotorRight,-6);
;;;398    			cliffTest.action++;
;;;399    		}break;
;;;400    		
;;;401    		case 3:
;;;402    		{
;;;403    			if(bsp_GetCurrentBothPulse()-cliffTest.pulse >= GO_BACK_PULSE*5)
;;;404    			{
;;;405    				cliffTest.angle = bsp_AngleRead();
;;;406    				bsp_RotateCCW();
;;;407    				cliffTest.action++;
;;;408    			}
;;;409    		}break;
;;;410    		
;;;411    		case 4:
;;;412    		{
;;;413    			if(myabs(bsp_AngleAdd(cliffTest.angle ,20) - (bsp_AngleRead())) <= 2.0F)
;;;414    			{
;;;415    				bsp_SetMotorSpeed(MotorLeft, 6);
;;;416    				bsp_SetMotorSpeed(MotorRight,6);
;;;417    				cliffTest.action = 0 ;
;;;418    			}
;;;419    		}break;
;;;420    	}
;;;421    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L3.20|
000014  4861              LDR      r0,|L3.412|
000016  7a00              LDRB     r0,[r0,#8]            ;345  ; cliffTest
000018  2805              CMP      r0,#5                 ;345
00001a  d230              BCS      |L3.126|
00001c  e8dff000          TBB      [pc,r0]               ;345
000020  03306c80          DCB      0x03,0x30,0x6c,0x80
000024  9900              DCB      0x99,0x00
000026  2007              MOVS     r0,#7                 ;350
000028  f7fffffe          BL       bsp_GetInfraRedAdcVoltage
00002c  4604              MOV      r4,r0                 ;350
00002e  f04f517e          MOV      r1,#0x3f800000        ;350
000032  f7fffffe          BL       __aeabi_cfrcmple
000036  d91a              BLS      |L3.110|
000038  2002              MOVS     r0,#2                 ;351
00003a  f7fffffe          BL       bsp_GetInfraRedAdcVoltage
00003e  4604              MOV      r4,r0                 ;351
000040  f04f517e          MOV      r1,#0x3f800000        ;351
000044  f7fffffe          BL       __aeabi_cfrcmple
000048  d911              BLS      |L3.110|
00004a  2003              MOVS     r0,#3                 ;352
00004c  f7fffffe          BL       bsp_GetInfraRedAdcVoltage
000050  4604              MOV      r4,r0                 ;352
000052  f04f517e          MOV      r1,#0x3f800000        ;352
000056  f7fffffe          BL       __aeabi_cfrcmple
00005a  d908              BLS      |L3.110|
00005c  2004              MOVS     r0,#4                 ;353
00005e  f7fffffe          BL       bsp_GetInfraRedAdcVoltage
000062  4604              MOV      r4,r0                 ;353
000064  f04f517e          MOV      r1,#0x3f800000        ;353
000068  f7fffffe          BL       __aeabi_cfrcmple
00006c  d802              BHI      |L3.116|
                  |L3.110|
00006e  2001              MOVS     r0,#1                 ;355
000070  494b              LDR      r1,|L3.416|
000072  7008              STRB     r0,[r1,#0]            ;355
                  |L3.116|
000074  4849              LDR      r0,|L3.412|
000076  7a00              LDRB     r0,[r0,#8]            ;359  ; cliffTest
000078  1c40              ADDS     r0,r0,#1              ;359
00007a  4948              LDR      r1,|L3.412|
00007c  7208              STRB     r0,[r1,#8]            ;359
                  |L3.126|
00007e  e089              B        |L3.404|
000080  2000              MOVS     r0,#0                 ;364
000082  f7fffffe          BL       bsp_CliffIsDangerous
000086  b958              CBNZ     r0,|L3.160|
000088  2001              MOVS     r0,#1                 ;365
00008a  f7fffffe          BL       bsp_CliffIsDangerous
00008e  b938              CBNZ     r0,|L3.160|
000090  2002              MOVS     r0,#2                 ;366
000092  f7fffffe          BL       bsp_CliffIsDangerous
000096  b918              CBNZ     r0,|L3.160|
000098  f7fffffe          BL       bsp_CollisionScan
00009c  2803              CMP      r0,#3                 ;367
00009e  d013              BEQ      |L3.200|
                  |L3.160|
0000a0  a040              ADR      r0,|L3.420|
0000a2  f7fffffe          BL       __2printf
0000a6  2100              MOVS     r1,#0                 ;370
0000a8  4608              MOV      r0,r1                 ;370
0000aa  f7fffffe          BL       bsp_SetMotorSpeed
0000ae  2100              MOVS     r1,#0                 ;371
0000b0  2001              MOVS     r0,#1                 ;371
0000b2  f7fffffe          BL       bsp_SetMotorSpeed
0000b6  4839              LDR      r0,|L3.412|
0000b8  7a00              LDRB     r0,[r0,#8]            ;372  ; cliffTest
0000ba  1c40              ADDS     r0,r0,#1              ;372
0000bc  4937              LDR      r1,|L3.412|
0000be  7208              STRB     r0,[r1,#8]            ;372
0000c0  2000              MOVS     r0,#0                 ;374
0000c2  4937              LDR      r1,|L3.416|
0000c4  7008              STRB     r0,[r1,#0]            ;374
0000c6  e016              B        |L3.246|
                  |L3.200|
0000c8  4835              LDR      r0,|L3.416|
0000ca  7800              LDRB     r0,[r0,#0]            ;379  ; isErlangGod
0000cc  b140              CBZ      r0,|L3.224|
0000ce  2106              MOVS     r1,#6                 ;381
0000d0  2000              MOVS     r0,#0                 ;381
0000d2  f7fffffe          BL       bsp_SetMotorSpeed
0000d6  2106              MOVS     r1,#6                 ;382
0000d8  2001              MOVS     r0,#1                 ;382
0000da  f7fffffe          BL       bsp_SetMotorSpeed
0000de  e007              B        |L3.240|
                  |L3.224|
0000e0  210c              MOVS     r1,#0xc               ;386
0000e2  2000              MOVS     r0,#0                 ;386
0000e4  f7fffffe          BL       bsp_SetMotorSpeed
0000e8  210c              MOVS     r1,#0xc               ;387
0000ea  2001              MOVS     r0,#1                 ;387
0000ec  f7fffffe          BL       bsp_SetMotorSpeed
                  |L3.240|
0000f0  2000              MOVS     r0,#0                 ;389
0000f2  492a              LDR      r1,|L3.412|
0000f4  7208              STRB     r0,[r1,#8]            ;389
                  |L3.246|
0000f6  e04d              B        |L3.404|
0000f8  f7fffffe          BL       bsp_GetCurrentBothPulse
0000fc  4927              LDR      r1,|L3.412|
0000fe  60c8              STR      r0,[r1,#0xc]          ;395  ; cliffTest
000100  f06f0105          MVN      r1,#5                 ;396
000104  2000              MOVS     r0,#0                 ;396
000106  f7fffffe          BL       bsp_SetMotorSpeed
00010a  f06f0105          MVN      r1,#5                 ;397
00010e  2001              MOVS     r0,#1                 ;397
000110  f7fffffe          BL       bsp_SetMotorSpeed
000114  4821              LDR      r0,|L3.412|
000116  7a00              LDRB     r0,[r0,#8]            ;398  ; cliffTest
000118  1c40              ADDS     r0,r0,#1              ;398
00011a  4920              LDR      r1,|L3.412|
00011c  7208              STRB     r0,[r1,#8]            ;398
00011e  e039              B        |L3.404|
000120  f7fffffe          BL       bsp_GetCurrentBothPulse
000124  491d              LDR      r1,|L3.412|
000126  68c9              LDR      r1,[r1,#0xc]          ;403  ; cliffTest
000128  1a45              SUBS     r5,r0,r1              ;403
00012a  4628              MOV      r0,r5                 ;403
00012c  f7fffffe          BL       __aeabi_ui2f
000130  4604              MOV      r4,r0                 ;403
000132  491f              LDR      r1,|L3.432|
000134  f7fffffe          BL       __aeabi_cfrcmple
000138  d80a              BHI      |L3.336|
00013a  f7fffffe          BL       bsp_AngleRead
00013e  4917              LDR      r1,|L3.412|
000140  6108              STR      r0,[r1,#0x10]         ;405  ; cliffTest
000142  f7fffffe          BL       bsp_RotateCCW
000146  4815              LDR      r0,|L3.412|
000148  7a00              LDRB     r0,[r0,#8]            ;407  ; cliffTest
00014a  1c40              ADDS     r0,r0,#1              ;407
00014c  4913              LDR      r1,|L3.412|
00014e  7208              STRB     r0,[r1,#8]            ;407
                  |L3.336|
000150  e020              B        |L3.404|
000152  f7fffffe          BL       bsp_AngleRead
000156  4606              MOV      r6,r0                 ;413
000158  4910              LDR      r1,|L3.412|
00015a  6908              LDR      r0,[r1,#0x10]         ;413  ; cliffTest
00015c  4915              LDR      r1,|L3.436|
00015e  f7fffffe          BL       bsp_AngleAdd
000162  4607              MOV      r7,r0                 ;413
000164  4631              MOV      r1,r6                 ;413
000166  f7fffffe          BL       __aeabi_fsub
00016a  4605              MOV      r5,r0                 ;413
00016c  f7fffffe          BL       myabs
000170  4604              MOV      r4,r0                 ;413
000172  f04f4180          MOV      r1,#0x40000000        ;413
000176  f7fffffe          BL       __aeabi_cfcmple
00017a  d80a              BHI      |L3.402|
00017c  2106              MOVS     r1,#6                 ;415
00017e  2000              MOVS     r0,#0                 ;415
000180  f7fffffe          BL       bsp_SetMotorSpeed
000184  2106              MOVS     r1,#6                 ;416
000186  2001              MOVS     r0,#1                 ;416
000188  f7fffffe          BL       bsp_SetMotorSpeed
00018c  2000              MOVS     r0,#0                 ;417
00018e  4903              LDR      r1,|L3.412|
000190  7208              STRB     r0,[r1,#8]            ;417
                  |L3.402|
000192  bf00              NOP                            ;419
                  |L3.404|
000194  bf00              NOP                            ;360
000196  bf00              NOP      
000198  e73a              B        |L3.16|
;;;422    
                          ENDP

00019a  0000              DCW      0x0000
                  |L3.412|
                          DCD      cliffTest
                  |L3.416|
                          DCD      isErlangGod
                  |L3.420|
0001a4  d0fcd1c2          DCB      208,252,209,194,180,165,183,162,"\r\n",0
0001a8  b4a5b7a2
0001ac  0d0a00  
0001af  00                DCB      0
                  |L3.432|
                          DCD      0x4368f064
                  |L3.436|
                          DCD      0x41a00000

                          AREA ||i.bsp_GetCliffVoltage||, CODE, READONLY, ALIGN=2

                  bsp_GetCliffVoltage PROC
;;;160    */
;;;161    float bsp_GetCliffVoltage(CliffSWSN sn)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;162    {
000004  4604              MOV      r4,r0
;;;163    	float ret = 0 ;
000006  2500              MOVS     r5,#0
;;;164    	
;;;165    	switch(sn)
000008  b124              CBZ      r4,|L4.20|
00000a  2c01              CMP      r4,#1
00000c  d024              BEQ      |L4.88|
00000e  2c02              CMP      r4,#2
000010  d166              BNE      |L4.224|
000012  e043              B        |L4.156|
                  |L4.20|
;;;166    	{
;;;167    		case CliffLeft:
;;;168    		{
;;;169    			ADC_RegularChannelConfig(ADC2, ADC_Channel_7, 1, ADC_SampleTime_239Cycles5 );
000014  2307              MOVS     r3,#7
000016  2201              MOVS     r2,#1
000018  4619              MOV      r1,r3
00001a  4833              LDR      r0,|L4.232|
00001c  f7fffffe          BL       ADC_RegularChannelConfig
;;;170    			ADC_SoftwareStartConvCmd(ADC2, ENABLE);	
000020  2101              MOVS     r1,#1
000022  4831              LDR      r0,|L4.232|
000024  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;171    			while(!ADC_GetFlagStatus(ADC2, ADC_FLAG_EOC ));
000028  bf00              NOP      
                  |L4.42|
00002a  2102              MOVS     r1,#2
00002c  482e              LDR      r0,|L4.232|
00002e  f7fffffe          BL       ADC_GetFlagStatus
000032  2800              CMP      r0,#0
000034  d0f9              BEQ      |L4.42|
;;;172    			ret = ADC_GetConversionValue(ADC2) * 3.3F / 4096;
000036  482c              LDR      r0,|L4.232|
000038  f7fffffe          BL       ADC_GetConversionValue
00003c  4680              MOV      r8,r0
00003e  f7fffffe          BL       __aeabi_ui2f
000042  4607              MOV      r7,r0
000044  4929              LDR      r1,|L4.236|
000046  f7fffffe          BL       __aeabi_fmul
00004a  4606              MOV      r6,r0
00004c  f04f418b          MOV      r1,#0x45800000
000050  f7fffffe          BL       __aeabi_fdiv
000054  4605              MOV      r5,r0
;;;173    		}break;
000056  e043              B        |L4.224|
                  |L4.88|
;;;174    		
;;;175    		case CliffMiddle:
;;;176    		{
;;;177    			ADC_RegularChannelConfig(ADC2, ADC_Channel_6, 1, ADC_SampleTime_239Cycles5 );
000058  2307              MOVS     r3,#7
00005a  2201              MOVS     r2,#1
00005c  2106              MOVS     r1,#6
00005e  4822              LDR      r0,|L4.232|
000060  f7fffffe          BL       ADC_RegularChannelConfig
;;;178    			ADC_SoftwareStartConvCmd(ADC2, ENABLE);	
000064  2101              MOVS     r1,#1
000066  4820              LDR      r0,|L4.232|
000068  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;179    			while(!ADC_GetFlagStatus(ADC2, ADC_FLAG_EOC ));
00006c  bf00              NOP      
                  |L4.110|
00006e  2102              MOVS     r1,#2
000070  481d              LDR      r0,|L4.232|
000072  f7fffffe          BL       ADC_GetFlagStatus
000076  2800              CMP      r0,#0
000078  d0f9              BEQ      |L4.110|
;;;180    			ret = ADC_GetConversionValue(ADC2) * 3.3F / 4096;
00007a  481b              LDR      r0,|L4.232|
00007c  f7fffffe          BL       ADC_GetConversionValue
000080  4680              MOV      r8,r0
000082  f7fffffe          BL       __aeabi_ui2f
000086  4607              MOV      r7,r0
000088  4918              LDR      r1,|L4.236|
00008a  f7fffffe          BL       __aeabi_fmul
00008e  4606              MOV      r6,r0
000090  f04f418b          MOV      r1,#0x45800000
000094  f7fffffe          BL       __aeabi_fdiv
000098  4605              MOV      r5,r0
;;;181    		}break;
00009a  e021              B        |L4.224|
                  |L4.156|
;;;182    		
;;;183    		case CliffRight:
;;;184    		{
;;;185    			ADC_RegularChannelConfig(ADC3, ADC_Channel_7, 1, ADC_SampleTime_239Cycles5 );
00009c  2307              MOVS     r3,#7
00009e  2201              MOVS     r2,#1
0000a0  4619              MOV      r1,r3
0000a2  4813              LDR      r0,|L4.240|
0000a4  f7fffffe          BL       ADC_RegularChannelConfig
;;;186    			ADC_SoftwareStartConvCmd(ADC3, ENABLE);	
0000a8  2101              MOVS     r1,#1
0000aa  4811              LDR      r0,|L4.240|
0000ac  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;187    			while(!ADC_GetFlagStatus(ADC3, ADC_FLAG_EOC ));
0000b0  bf00              NOP      
                  |L4.178|
0000b2  2102              MOVS     r1,#2
0000b4  480e              LDR      r0,|L4.240|
0000b6  f7fffffe          BL       ADC_GetFlagStatus
0000ba  2800              CMP      r0,#0
0000bc  d0f9              BEQ      |L4.178|
;;;188    			ret = ADC_GetConversionValue(ADC3) * 3.3F / 4096;
0000be  480c              LDR      r0,|L4.240|
0000c0  f7fffffe          BL       ADC_GetConversionValue
0000c4  4680              MOV      r8,r0
0000c6  f7fffffe          BL       __aeabi_ui2f
0000ca  4607              MOV      r7,r0
0000cc  4907              LDR      r1,|L4.236|
0000ce  f7fffffe          BL       __aeabi_fmul
0000d2  4606              MOV      r6,r0
0000d4  f04f418b          MOV      r1,#0x45800000
0000d8  f7fffffe          BL       __aeabi_fdiv
0000dc  4605              MOV      r5,r0
;;;189    		}break;
0000de  bf00              NOP      
                  |L4.224|
0000e0  bf00              NOP                            ;173
;;;190    	}
;;;191    	
;;;192    	return ret;
0000e2  4628              MOV      r0,r5
;;;193    }
0000e4  e8bd81f0          POP      {r4-r8,pc}
;;;194    
                          ENDP

                  |L4.232|
                          DCD      0x40012800
                  |L4.236|
                          DCD      0x40533333
                  |L4.240|
                          DCD      0x40013c00

                          AREA ||i.bsp_InitCliffSW||, CODE, READONLY, ALIGN=2

                  bsp_InitCliffSW PROC
;;;13     */
;;;14     void bsp_InitCliffSW(void)
000000  b500              PUSH     {lr}
;;;15     {
000002  b087              SUB      sp,sp,#0x1c
;;;16     	ADC_InitTypeDef ADC_InitStructure; 
;;;17     	GPIO_InitTypeDef GPIO_InitStructure;
;;;18     	
;;;19     	/*跳崖1*/
;;;20     	{
;;;21     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA |RCC_APB2Periph_ADC2, ENABLE );
000004  2101              MOVS     r1,#1
000006  f2404004          MOV      r0,#0x404
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;22      
;;;23     		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;24     		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
00000e  f44f4000          MOV      r0,#0x8000
000012  f7fffffe          BL       RCC_ADCCLKConfig
;;;25                       
;;;26     		/*配置引脚为模拟输入模式*/
;;;27     		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
000016  2080              MOVS     r0,#0x80
000018  f8ad0004          STRH     r0,[sp,#4]
;;;28     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00001c  2000              MOVS     r0,#0
00001e  f88d0007          STRB     r0,[sp,#7]
;;;29     		GPIO_Init(GPIOA, &GPIO_InitStructure);	
000022  a901              ADD      r1,sp,#4
000024  4860              LDR      r0,|L5.424|
000026  f7fffffe          BL       GPIO_Init
;;;30     
;;;31     		/*复位ADC*/
;;;32     		ADC_DeInit(ADC2);
00002a  4860              LDR      r0,|L5.428|
00002c  f7fffffe          BL       ADC_DeInit
;;;33     
;;;34     		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000030  2000              MOVS     r0,#0
000032  9002              STR      r0,[sp,#8]
;;;35     		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
000034  f88d000c          STRB     r0,[sp,#0xc]
;;;36     		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
000038  f88d000d          STRB     r0,[sp,#0xd]
;;;37     		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
00003c  f44f2060          MOV      r0,#0xe0000
000040  9004              STR      r0,[sp,#0x10]
;;;38     		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000042  2000              MOVS     r0,#0
000044  9005              STR      r0,[sp,#0x14]
;;;39     		ADC_InitStructure.ADC_NbrOfChannel = 1;
000046  2001              MOVS     r0,#1
000048  f88d0018          STRB     r0,[sp,#0x18]
;;;40     		ADC_Init(ADC2, &ADC_InitStructure);  
00004c  a902              ADD      r1,sp,#8
00004e  4857              LDR      r0,|L5.428|
000050  f7fffffe          BL       ADC_Init
;;;41     
;;;42     		/*使能指定的ADC*/
;;;43     		ADC_Cmd(ADC2, ENABLE);
000054  2101              MOVS     r1,#1
000056  4855              LDR      r0,|L5.428|
000058  f7fffffe          BL       ADC_Cmd
;;;44     		
;;;45     		/*使能复位校准 */
;;;46     		ADC_ResetCalibration(ADC2);
00005c  4853              LDR      r0,|L5.428|
00005e  f7fffffe          BL       ADC_ResetCalibration
;;;47     		 
;;;48     		/*等待复位校准结束*/
;;;49     		while(ADC_GetResetCalibrationStatus(ADC2));
000062  bf00              NOP      
                  |L5.100|
000064  4851              LDR      r0,|L5.428|
000066  f7fffffe          BL       ADC_GetResetCalibrationStatus
00006a  2800              CMP      r0,#0
00006c  d1fa              BNE      |L5.100|
;;;50     		
;;;51     		/*开启AD校准*/
;;;52     		ADC_StartCalibration(ADC2);
00006e  484f              LDR      r0,|L5.428|
000070  f7fffffe          BL       ADC_StartCalibration
;;;53     	 
;;;54     		/*等待校准结束*/
;;;55     		while(ADC_GetCalibrationStatus(ADC2));
000074  bf00              NOP      
                  |L5.118|
000076  484d              LDR      r0,|L5.428|
000078  f7fffffe          BL       ADC_GetCalibrationStatus
00007c  2800              CMP      r0,#0
00007e  d1fa              BNE      |L5.118|
;;;56     		
;;;57     		/*ADC,ADC通道,采样时间为239.5周期*/
;;;58     		ADC_RegularChannelConfig(ADC2, ADC_Channel_7, 1, ADC_SampleTime_239Cycles5 );
000080  2307              MOVS     r3,#7
000082  2201              MOVS     r2,#1
000084  4619              MOV      r1,r3
000086  4849              LDR      r0,|L5.428|
000088  f7fffffe          BL       ADC_RegularChannelConfig
;;;59     	}
;;;60     	
;;;61     	
;;;62     	/*跳崖2*/
;;;63     	{
;;;64     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA |RCC_APB2Periph_ADC2, ENABLE );
00008c  2101              MOVS     r1,#1
00008e  f2404004          MOV      r0,#0x404
000092  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;65      
;;;66     		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;67     		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
000096  f44f4000          MOV      r0,#0x8000
00009a  f7fffffe          BL       RCC_ADCCLKConfig
;;;68                       
;;;69     		/*配置引脚为模拟输入模式*/
;;;70     		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
00009e  2040              MOVS     r0,#0x40
0000a0  f8ad0004          STRH     r0,[sp,#4]
;;;71     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
0000a4  2000              MOVS     r0,#0
0000a6  f88d0007          STRB     r0,[sp,#7]
;;;72     		GPIO_Init(GPIOA, &GPIO_InitStructure);	
0000aa  a901              ADD      r1,sp,#4
0000ac  483e              LDR      r0,|L5.424|
0000ae  f7fffffe          BL       GPIO_Init
;;;73     
;;;74     		/*复位ADC*/
;;;75     		ADC_DeInit(ADC2);
0000b2  483e              LDR      r0,|L5.428|
0000b4  f7fffffe          BL       ADC_DeInit
;;;76     
;;;77     		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
0000b8  2000              MOVS     r0,#0
0000ba  9002              STR      r0,[sp,#8]
;;;78     		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
0000bc  f88d000c          STRB     r0,[sp,#0xc]
;;;79     		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
0000c0  f88d000d          STRB     r0,[sp,#0xd]
;;;80     		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
0000c4  f44f2060          MOV      r0,#0xe0000
0000c8  9004              STR      r0,[sp,#0x10]
;;;81     		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
0000ca  2000              MOVS     r0,#0
0000cc  9005              STR      r0,[sp,#0x14]
;;;82     		ADC_InitStructure.ADC_NbrOfChannel = 1;
0000ce  2001              MOVS     r0,#1
0000d0  f88d0018          STRB     r0,[sp,#0x18]
;;;83     		ADC_Init(ADC2, &ADC_InitStructure);  
0000d4  a902              ADD      r1,sp,#8
0000d6  4835              LDR      r0,|L5.428|
0000d8  f7fffffe          BL       ADC_Init
;;;84     
;;;85     		/*使能指定的ADC*/
;;;86     		ADC_Cmd(ADC2, ENABLE);
0000dc  2101              MOVS     r1,#1
0000de  4833              LDR      r0,|L5.428|
0000e0  f7fffffe          BL       ADC_Cmd
;;;87     		
;;;88     		/*使能复位校准 */
;;;89     		ADC_ResetCalibration(ADC2);
0000e4  4831              LDR      r0,|L5.428|
0000e6  f7fffffe          BL       ADC_ResetCalibration
;;;90     		 
;;;91     		/*等待复位校准结束*/
;;;92     		while(ADC_GetResetCalibrationStatus(ADC2));
0000ea  bf00              NOP      
                  |L5.236|
0000ec  482f              LDR      r0,|L5.428|
0000ee  f7fffffe          BL       ADC_GetResetCalibrationStatus
0000f2  2800              CMP      r0,#0
0000f4  d1fa              BNE      |L5.236|
;;;93     		
;;;94     		/*开启AD校准*/
;;;95     		ADC_StartCalibration(ADC2);
0000f6  482d              LDR      r0,|L5.428|
0000f8  f7fffffe          BL       ADC_StartCalibration
;;;96     	 
;;;97     		/*等待校准结束*/
;;;98     		while(ADC_GetCalibrationStatus(ADC2));
0000fc  bf00              NOP      
                  |L5.254|
0000fe  482b              LDR      r0,|L5.428|
000100  f7fffffe          BL       ADC_GetCalibrationStatus
000104  2800              CMP      r0,#0
000106  d1fa              BNE      |L5.254|
;;;99     		
;;;100    		/*ADC,ADC通道,采样时间为239.5周期*/
;;;101    		ADC_RegularChannelConfig(ADC2, ADC_Channel_6, 1, ADC_SampleTime_239Cycles5 );
000108  2307              MOVS     r3,#7
00010a  2201              MOVS     r2,#1
00010c  2106              MOVS     r1,#6
00010e  4827              LDR      r0,|L5.428|
000110  f7fffffe          BL       ADC_RegularChannelConfig
;;;102    	}
;;;103    	
;;;104    	/*跳崖3*/
;;;105    	{
;;;106    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF |RCC_APB2Periph_ADC3, ENABLE );
000114  2101              MOVS     r1,#1
000116  f2480080          MOV      r0,#0x8080
00011a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;107     
;;;108    		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;109    		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
00011e  f44f4000          MOV      r0,#0x8000
000122  f7fffffe          BL       RCC_ADCCLKConfig
;;;110                      
;;;111    		/*配置引脚为模拟输入模式*/
;;;112    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000126  f44f7000          MOV      r0,#0x200
00012a  f8ad0004          STRH     r0,[sp,#4]
;;;113    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00012e  2000              MOVS     r0,#0
000130  f88d0007          STRB     r0,[sp,#7]
;;;114    		GPIO_Init(GPIOF, &GPIO_InitStructure);	
000134  a901              ADD      r1,sp,#4
000136  481e              LDR      r0,|L5.432|
000138  f7fffffe          BL       GPIO_Init
;;;115    
;;;116    		/*复位ADC*/
;;;117    		ADC_DeInit(ADC3);
00013c  481d              LDR      r0,|L5.436|
00013e  f7fffffe          BL       ADC_DeInit
;;;118    
;;;119    		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000142  2000              MOVS     r0,#0
000144  9002              STR      r0,[sp,#8]
;;;120    		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
000146  f88d000c          STRB     r0,[sp,#0xc]
;;;121    		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
00014a  f88d000d          STRB     r0,[sp,#0xd]
;;;122    		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
00014e  f44f2060          MOV      r0,#0xe0000
000152  9004              STR      r0,[sp,#0x10]
;;;123    		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000154  2000              MOVS     r0,#0
000156  9005              STR      r0,[sp,#0x14]
;;;124    		ADC_InitStructure.ADC_NbrOfChannel = 1;
000158  2001              MOVS     r0,#1
00015a  f88d0018          STRB     r0,[sp,#0x18]
;;;125    		ADC_Init(ADC3, &ADC_InitStructure);  
00015e  a902              ADD      r1,sp,#8
000160  4814              LDR      r0,|L5.436|
000162  f7fffffe          BL       ADC_Init
;;;126    
;;;127    		/*使能指定的ADC*/
;;;128    		ADC_Cmd(ADC3, ENABLE);
000166  2101              MOVS     r1,#1
000168  4812              LDR      r0,|L5.436|
00016a  f7fffffe          BL       ADC_Cmd
;;;129    		
;;;130    		/*使能复位校准 */
;;;131    		ADC_ResetCalibration(ADC3);
00016e  4811              LDR      r0,|L5.436|
000170  f7fffffe          BL       ADC_ResetCalibration
;;;132    		 
;;;133    		/*等待复位校准结束*/
;;;134    		while(ADC_GetResetCalibrationStatus(ADC3));
000174  bf00              NOP      
                  |L5.374|
000176  480f              LDR      r0,|L5.436|
000178  f7fffffe          BL       ADC_GetResetCalibrationStatus
00017c  2800              CMP      r0,#0
00017e  d1fa              BNE      |L5.374|
;;;135    		
;;;136    		/*开启AD校准*/
;;;137    		ADC_StartCalibration(ADC3);
000180  480c              LDR      r0,|L5.436|
000182  f7fffffe          BL       ADC_StartCalibration
;;;138    	 
;;;139    		/*等待校准结束*/
;;;140    		while(ADC_GetCalibrationStatus(ADC3));
000186  bf00              NOP      
                  |L5.392|
000188  480a              LDR      r0,|L5.436|
00018a  f7fffffe          BL       ADC_GetCalibrationStatus
00018e  2800              CMP      r0,#0
000190  d1fa              BNE      |L5.392|
;;;141    		
;;;142    		/*ADC,ADC通道,采样时间为239.5周期*/
;;;143    		ADC_RegularChannelConfig(ADC3, ADC_Channel_7, 1, ADC_SampleTime_239Cycles5 );
000192  2307              MOVS     r3,#7
000194  2201              MOVS     r2,#1
000196  4619              MOV      r1,r3
000198  4806              LDR      r0,|L5.436|
00019a  f7fffffe          BL       ADC_RegularChannelConfig
;;;144    	}
;;;145    
;;;146    	/*开机初始化ADC的时候，校准一次悬崖传感器校准值*/
;;;147    	bsp_CliffCalibration();
00019e  f7fffffe          BL       bsp_CliffCalibration
;;;148    
;;;149    }
0001a2  b007              ADD      sp,sp,#0x1c
0001a4  bd00              POP      {pc}
;;;150    
                          ENDP

0001a6  0000              DCW      0x0000
                  |L5.424|
                          DCD      0x40010800
                  |L5.428|
                          DCD      0x40012800
                  |L5.432|
                          DCD      0x40011c00
                  |L5.436|
                          DCD      0x40013c00

                          AREA ||i.bsp_RotateCCW||, CODE, READONLY, ALIGN=1

                  bsp_RotateCCW PROC
;;;431    */
;;;432    static void bsp_RotateCCW(void)
000000  b510              PUSH     {r4,lr}
;;;433    {
;;;434    	bsp_SetMotorSpeed(MotorLeft, ROTATE_CCW_SPEED_L);
000002  f06f0104          MVN      r1,#4
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       bsp_SetMotorSpeed
;;;435    	bsp_SetMotorSpeed(MotorRight,ROTATE_CCW_SPEED_R);
00000c  2105              MOVS     r1,#5
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       bsp_SetMotorSpeed
;;;436    }
000014  bd10              POP      {r4,pc}
;;;437    
                          ENDP


                          AREA ||i.bsp_StartCliffTest||, CODE, READONLY, ALIGN=2

                  bsp_StartCliffTest PROC
;;;309    
;;;310    void bsp_StartCliffTest(void)
000000  2000              MOVS     r0,#0
;;;311    {
;;;312    	cliffTest.delay = 0 ;
000002  4904              LDR      r1,|L7.20|
000004  6048              STR      r0,[r1,#4]  ; cliffTest
;;;313    	cliffTest.action = 0;
000006  7208              STRB     r0,[r1,#8]
;;;314    	cliffTest.pulse = 0 ;
000008  60c8              STR      r0,[r1,#0xc]  ; cliffTest
;;;315    	cliffTest.angle = 0 ;
00000a  6108              STR      r0,[r1,#0x10]  ; cliffTest
;;;316    	
;;;317    	cliffTest.isRunning = true;
00000c  2001              MOVS     r0,#1
00000e  7008              STRB     r0,[r1,#0]
;;;318    }
000010  4770              BX       lr
;;;319    
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      cliffTest

                          AREA ||i.bsp_StopCliffTest||, CODE, READONLY, ALIGN=2

                  bsp_StopCliffTest PROC
;;;319    
;;;320    void bsp_StopCliffTest(void)
000000  b510              PUSH     {r4,lr}
;;;321    {
;;;322    	cliffTest.isRunning = false;
000002  2000              MOVS     r0,#0
000004  4907              LDR      r1,|L8.36|
000006  7008              STRB     r0,[r1,#0]
;;;323    	
;;;324    	cliffTest.delay = 0 ;
000008  6048              STR      r0,[r1,#4]  ; cliffTest
;;;325    	cliffTest.action = 0;
00000a  7208              STRB     r0,[r1,#8]
;;;326    	cliffTest.pulse = 0 ;
00000c  60c8              STR      r0,[r1,#0xc]  ; cliffTest
;;;327    	cliffTest.angle = 0 ;
00000e  6108              STR      r0,[r1,#0x10]  ; cliffTest
;;;328    	
;;;329    	bsp_SetMotorSpeed(MotorLeft, 0);
000010  2100              MOVS     r1,#0
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       bsp_SetMotorSpeed
;;;330    	bsp_SetMotorSpeed(MotorRight,0);
000018  2100              MOVS     r1,#0
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       bsp_SetMotorSpeed
;;;331    	
;;;332    }
000020  bd10              POP      {r4,pc}
;;;333    
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      cliffTest

                          AREA ||i.myabs||, CODE, READONLY, ALIGN=1

                  myabs PROC
;;;438    
;;;439    static float myabs(float val)
000000  b510              PUSH     {r4,lr}
;;;440    {
000002  4604              MOV      r4,r0
;;;441    	if(val < 0)
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       __aeabi_cfcmple
00000c  d201              BCS      |L9.18|
;;;442    	{
;;;443    		val = - val;
00000e  f0844400          EOR      r4,r4,#0x80000000
                  |L9.18|
;;;444    	}
;;;445    	
;;;446    	return val;
000012  4620              MOV      r0,r4
;;;447    }
000014  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  cliff
                          %        36
                  cliffTest
                          %        20

                          AREA ||.data||, DATA, ALIGN=0

                  isErlangGod
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\src\\bsp_CliffSW.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_CliffSW_c_4df603ba____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_CliffSW_c_4df603ba____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_CliffSW_c_4df603ba____REVSH|
#line 128
|__asm___13_bsp_CliffSW_c_4df603ba____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
