; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_ir_decode.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_ir_decode.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I..\..\..\User\angle\gan_rui_Angle -I..\..\User\angle\yuan_zi_Angle -I..\..\User\dx8\inc -IF:\LuckyXRQ\CleanCar\NO_RTOS\Project\MDK-ARM(uV4)\RTE -ID:\soft\MDK5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\soft\MDK5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_ir_decode.crf ..\..\User\bsp\src\bsp_ir_decode.c]
                          THUMB

                          AREA ||i.TIM3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM3_IRQHandler PROC
;;;556    */
;;;557    void TIM3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;558    {
;;;559    
;;;560    	/* 溢出中断 */
;;;561    	if (TIM_GetITStatus(TIM3, TIM_IT_Update))
000002  2101              MOVS     r1,#1
000004  4822              LDR      r0,|L1.144|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  b178              CBZ      r0,|L1.44|
;;;562    	{
;;;563    		TIM_ClearITPendingBit(TIM3, TIM_IT_Update);;
00000c  2101              MOVS     r1,#1
00000e  4820              LDR      r0,|L1.144|
000010  f7fffffe          BL       TIM_ClearITPendingBit
;;;564    		
;;;565    		/*太久没有收到上下降沿了，恢复各个通道到初始状态*/
;;;566            bsp_IR_TimeOutProc(IR_CH1);
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       bsp_IR_TimeOutProc
;;;567    		bsp_IR_TimeOutProc(IR_CH2);
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       bsp_IR_TimeOutProc
;;;568    		bsp_IR_TimeOutProc(IR_CH3);
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       bsp_IR_TimeOutProc
;;;569    		bsp_IR_TimeOutProc(IR_CH4);
000026  2003              MOVS     r0,#3
000028  f7fffffe          BL       bsp_IR_TimeOutProc
                  |L1.44|
;;;570    	}
;;;571    	
;;;572    	/* 输入通道3捕获中断 */
;;;573    	if (TIM_GetITStatus(TIM3, TIM_IT_CC1))
00002c  2102              MOVS     r1,#2
00002e  4818              LDR      r0,|L1.144|
000030  f7fffffe          BL       TIM_GetITStatus
000034  b130              CBZ      r0,|L1.68|
;;;574    	{
;;;575    		TIM_ClearITPendingBit(TIM3, TIM_IT_CC1);
000036  2102              MOVS     r1,#2
000038  4815              LDR      r0,|L1.144|
00003a  f7fffffe          BL       TIM_ClearITPendingBit
;;;576    
;;;577    		bsp_IR_GetPulseWidth(IR_CH1);
00003e  2000              MOVS     r0,#0
000040  f7fffffe          BL       bsp_IR_GetPulseWidth
                  |L1.68|
;;;578    		
;;;579    	}
;;;580    	
;;;581    	/* 输入通道3捕获中断 */
;;;582    	if (TIM_GetITStatus(TIM3, TIM_IT_CC2))
000044  2104              MOVS     r1,#4
000046  4812              LDR      r0,|L1.144|
000048  f7fffffe          BL       TIM_GetITStatus
00004c  b130              CBZ      r0,|L1.92|
;;;583    	{
;;;584    		TIM_ClearITPendingBit(TIM3, TIM_IT_CC2);
00004e  2104              MOVS     r1,#4
000050  480f              LDR      r0,|L1.144|
000052  f7fffffe          BL       TIM_ClearITPendingBit
;;;585    
;;;586    		bsp_IR_GetPulseWidth(IR_CH2);
000056  2001              MOVS     r0,#1
000058  f7fffffe          BL       bsp_IR_GetPulseWidth
                  |L1.92|
;;;587    		
;;;588    	}
;;;589    	
;;;590    	/* 输入通道3捕获中断 */
;;;591    	if (TIM_GetITStatus(TIM3, TIM_IT_CC3))
00005c  2108              MOVS     r1,#8
00005e  480c              LDR      r0,|L1.144|
000060  f7fffffe          BL       TIM_GetITStatus
000064  b130              CBZ      r0,|L1.116|
;;;592    	{
;;;593    		TIM_ClearITPendingBit(TIM3, TIM_IT_CC3);
000066  2108              MOVS     r1,#8
000068  4809              LDR      r0,|L1.144|
00006a  f7fffffe          BL       TIM_ClearITPendingBit
;;;594    
;;;595    		bsp_IR_GetPulseWidth(IR_CH3);
00006e  2002              MOVS     r0,#2
000070  f7fffffe          BL       bsp_IR_GetPulseWidth
                  |L1.116|
;;;596    		
;;;597    	}
;;;598    	
;;;599    	/* 输入通道3捕获中断 */
;;;600    	if (TIM_GetITStatus(TIM3, TIM_IT_CC4))
000074  2110              MOVS     r1,#0x10
000076  4806              LDR      r0,|L1.144|
000078  f7fffffe          BL       TIM_GetITStatus
00007c  b130              CBZ      r0,|L1.140|
;;;601    	{
;;;602    		TIM_ClearITPendingBit(TIM3, TIM_IT_CC4);
00007e  2110              MOVS     r1,#0x10
000080  4803              LDR      r0,|L1.144|
000082  f7fffffe          BL       TIM_ClearITPendingBit
;;;603    
;;;604    		bsp_IR_GetPulseWidth(IR_CH4);
000086  2003              MOVS     r0,#3
000088  f7fffffe          BL       bsp_IR_GetPulseWidth
                  |L1.140|
;;;605    		
;;;606    	}
;;;607    }
00008c  bd10              POP      {r4,pc}
;;;608    
                          ENDP

00008e  0000              DCW      0x0000
                  |L1.144|
                          DCD      0x40000400

                          AREA ||i.bsp_IRD_DecodeNec||, CODE, READONLY, ALIGN=2

                  bsp_IRD_DecodeNec PROC
;;;257    */
;;;258    static void bsp_IRD_DecodeNec(IR_CH ch , uint16_t _width)
000000  b510              PUSH     {r4,lr}
;;;259    {
;;;260    	/* NEC 格式 （5段）
;;;261    		1、引导码  9ms低 + 4.5ms高
;;;262    		2、低8位地址码  0=1.125ms  1=2.25ms    bit0先传
;;;263    		3、高8位地址码  0=1.125ms  1=2.25ms
;;;264    		4、8位数据      0=1.125ms  1=2.25ms
;;;265    		5、8为数码反码  0=1.125ms  1=2.25ms
;;;266    	*/
;;;267    
;;;268    loop1:	
000002  bf00              NOP      
                  |L2.4|
;;;269    	//bsp_LedToggle(1);		//for DEBUG 观测是否能够给在两个边沿触发捕获中断
;;;270    	switch (g_tIR.Status[ch])
000004  4a7e              LDR      r2,|L2.512|
000006  5c12              LDRB     r2,[r2,r0]
000008  b132              CBZ      r2,|L2.24|
00000a  2a01              CMP      r2,#1
00000c  d058              BEQ      |L2.192|
00000e  2a02              CMP      r2,#2
000010  d06c              BEQ      |L2.236|
000012  2a03              CMP      r2,#3
000014  d153              BNE      |L2.190|
000016  e079              B        |L2.268|
                  |L2.24|
;;;271    	{
;;;272    		case 0:			/* 929 等待引导码低信号  7ms - 11ms */
;;;273    			if ((_width > 700) && (_width < 1100))
000018  f5b17f2f          CMP      r1,#0x2bc
00001c  dd0c              BLE      |L2.56|
00001e  f240424c          MOV      r2,#0x44c
000022  4291              CMP      r1,r2
000024  da08              BGE      |L2.56|
;;;274    			{
;;;275    				g_tIR.Status[ch] = 1;
000026  2301              MOVS     r3,#1
000028  4a75              LDR      r2,|L2.512|
00002a  5413              STRB     r3,[r2,r0]
;;;276    				g_tIR.s_Byte[ch] = 0;
00002c  2300              MOVS     r3,#0
00002e  3274              ADDS     r2,r2,#0x74
000030  5413              STRB     r3,[r2,r0]
;;;277    				g_tIR.s_Bit[ch] = 0;
000032  1d12              ADDS     r2,r2,#4
000034  5413              STRB     r3,[r2,r0]
000036  e042              B        |L2.190|
                  |L2.56|
;;;278    			}
;;;279    			else if((_width > 5000))
000038  f2413288          MOV      r2,#0x1388
00003c  4291              CMP      r1,r2
00003e  dd30              BLE      |L2.162|
;;;280    			{
;;;281    				//DEBUG("间隔\r\n");
;;;282    				
;;;283    				/*间隔期间进行更新值*/
;;;284    				g_tIR.isRev[ch][IR_TX_SITE_LEFT] = g_tIR.isRevFilter[ch][IR_TX_SITE_LEFT];
000040  eb000340          ADD      r3,r0,r0,LSL #1
000044  4a6e              LDR      r2,|L2.512|
000046  3230              ADDS     r2,r2,#0x30
000048  5cd3              LDRB     r3,[r2,r3]
00004a  eb000440          ADD      r4,r0,r0,LSL #1
00004e  3a0c              SUBS     r2,r2,#0xc
000050  5513              STRB     r3,[r2,r4]
;;;285    				g_tIR.isRev[ch][IR_TX_SITE_CENTER] = g_tIR.isRevFilter[ch][IR_TX_SITE_CENTER];
000052  eb000340          ADD      r3,r0,r0,LSL #1
000056  320c              ADDS     r2,r2,#0xc
000058  441a              ADD      r2,r2,r3
00005a  7853              LDRB     r3,[r2,#1]
00005c  eb000440          ADD      r4,r0,r0,LSL #1
000060  4a67              LDR      r2,|L2.512|
000062  3224              ADDS     r2,r2,#0x24
000064  4422              ADD      r2,r2,r4
000066  7053              STRB     r3,[r2,#1]
;;;286    				g_tIR.isRev[ch][IR_TX_SITE_RIGHT] = g_tIR.isRevFilter[ch][IR_TX_SITE_RIGHT];
000068  eb000340          ADD      r3,r0,r0,LSL #1
00006c  4a64              LDR      r2,|L2.512|
00006e  3230              ADDS     r2,r2,#0x30
000070  441a              ADD      r2,r2,r3
000072  7893              LDRB     r3,[r2,#2]
000074  eb000440          ADD      r4,r0,r0,LSL #1
000078  4a61              LDR      r2,|L2.512|
00007a  3224              ADDS     r2,r2,#0x24
00007c  4422              ADD      r2,r2,r4
00007e  7093              STRB     r3,[r2,#2]
;;;287    				
;;;288    				/*滤波临时状态更新*/
;;;289    				g_tIR.isRevFilter[ch][IR_TX_SITE_LEFT] = false;
000080  2300              MOVS     r3,#0
000082  eb000440          ADD      r4,r0,r0,LSL #1
000086  4a5e              LDR      r2,|L2.512|
000088  3230              ADDS     r2,r2,#0x30
00008a  5513              STRB     r3,[r2,r4]
;;;290    				g_tIR.isRevFilter[ch][IR_TX_SITE_CENTER] = false;
00008c  eb000440          ADD      r4,r0,r0,LSL #1
000090  4422              ADD      r2,r2,r4
000092  7053              STRB     r3,[r2,#1]
;;;291    				g_tIR.isRevFilter[ch][IR_TX_SITE_RIGHT] = false;
000094  eb000440          ADD      r4,r0,r0,LSL #1
000098  4a59              LDR      r2,|L2.512|
00009a  3230              ADDS     r2,r2,#0x30
00009c  4422              ADD      r2,r2,r4
00009e  7093              STRB     r3,[r2,#2]
0000a0  e00d              B        |L2.190|
                  |L2.162|
;;;292    				
;;;293    			}
;;;294    			else
;;;295    			{
;;;296    				static uint8_t sss = 0;
;;;297    				
;;;298    				if (sss == 0)
0000a2  4a58              LDR      r2,|L2.516|
0000a4  7812              LDRB     r2,[r2,#0]  ; sss
0000a6  b91a              CBNZ     r2,|L2.176|
;;;299    				{
;;;300    					sss = 1;
0000a8  2201              MOVS     r2,#1
0000aa  4b56              LDR      r3,|L2.516|
0000ac  701a              STRB     r2,[r3,#0]
0000ae  e006              B        |L2.190|
                  |L2.176|
;;;301    				}
;;;302    				else if (sss == 1)
0000b0  4a54              LDR      r2,|L2.516|
0000b2  7812              LDRB     r2,[r2,#0]  ; sss
0000b4  2a01              CMP      r2,#1
0000b6  d102              BNE      |L2.190|
;;;303    				{
;;;304    					sss = 2;
0000b8  2202              MOVS     r2,#2
0000ba  4b52              LDR      r3,|L2.516|
0000bc  701a              STRB     r2,[r3,#0]
                  |L2.190|
;;;305    				}				
;;;306    			}
;;;307    			break;
0000be  e09d              B        |L2.508|
                  |L2.192|
;;;308    
;;;309    		case 1:			/* 413 判断引导码高信号  3ms - 6ms */
;;;310    			if ((_width > 313) && (_width < 600))	/* 引导码 4.5ms */
0000c0  f5b17f9d          CMP      r1,#0x13a
0000c4  db06              BLT      |L2.212|
0000c6  f5b17f16          CMP      r1,#0x258
0000ca  da03              BGE      |L2.212|
;;;311    			{
;;;312    				g_tIR.Status[ch] = 2;
0000cc  2302              MOVS     r3,#2
0000ce  4a4c              LDR      r2,|L2.512|
0000d0  5413              STRB     r3,[r2,r0]
0000d2  e00a              B        |L2.234|
                  |L2.212|
;;;313    			}
;;;314    			else if ((_width > 150) && (_width < 250))	/* 2.25ms */
0000d4  2996              CMP      r1,#0x96
0000d6  dd05              BLE      |L2.228|
0000d8  29fa              CMP      r1,#0xfa
0000da  da03              BGE      |L2.228|
;;;315    			{
;;;316    				#if IR_REPEAT_SEND_EN				
;;;317    					if (g_tIR.RepeatCount[ch] >= IR_REPEAT_FILTER)
;;;318    					{
;;;319    						bsp_PutKey(g_tIR.RxBuf[2] + IR_KEY_STRAT);	/* 连发码 */
;;;320    					}
;;;321    					else
;;;322    					{
;;;323    						g_tIR.RepeatCount[ch]++;
;;;324    					}
;;;325    				#endif
;;;326    				g_tIR.Status[ch] = 0;	/* 复位解码状态 */
0000dc  2300              MOVS     r3,#0
0000de  4a48              LDR      r2,|L2.512|
0000e0  5413              STRB     r3,[r2,r0]
0000e2  e002              B        |L2.234|
                  |L2.228|
;;;327    			}
;;;328    			else
;;;329    			{
;;;330    				/* 异常脉宽 */
;;;331    				g_tIR.Status[ch] = 0;	/* 复位解码状态 */
0000e4  2300              MOVS     r3,#0
0000e6  4a46              LDR      r2,|L2.512|
0000e8  5413              STRB     r3,[r2,r0]
                  |L2.234|
;;;332    			}
;;;333    			break;
0000ea  e087              B        |L2.508|
                  |L2.236|
;;;334    		
;;;335    		case 2:			/* 低电平期间 0.56ms */
;;;336    			if ((_width > 10) && (_width < 100))
0000ec  290a              CMP      r1,#0xa
0000ee  dd08              BLE      |L2.258|
0000f0  2964              CMP      r1,#0x64
0000f2  da06              BGE      |L2.258|
;;;337    			{		
;;;338    				g_tIR.Status[ch] = 3;
0000f4  2303              MOVS     r3,#3
0000f6  4a42              LDR      r2,|L2.512|
0000f8  5413              STRB     r3,[r2,r0]
;;;339    				g_tIR.s_LowWidth[ch] = _width;	/* 保存低电平宽度 */
0000fa  326c              ADDS     r2,r2,#0x6c
0000fc  f8221010          STRH     r1,[r2,r0,LSL #1]
000100  e003              B        |L2.266|
                  |L2.258|
;;;340    			}
;;;341    			else	/* 异常脉宽 */
;;;342    			{
;;;343    				/* 异常脉宽 */
;;;344    				g_tIR.Status[ch] = 0;	/* 复位解码器状态 */	
000102  2300              MOVS     r3,#0
000104  4a3e              LDR      r2,|L2.512|
000106  5413              STRB     r3,[r2,r0]
;;;345    				goto loop1;		/* 继续判断同步信号 */
000108  e77c              B        |L2.4|
                  |L2.266|
;;;346    			}
;;;347    			break;
00010a  e077              B        |L2.508|
                  |L2.268|
;;;348    
;;;349    		case 3:			/* 85+25, 64+157 开始连续解码32bit */						
;;;350    			g_tIR.TotalWitdh[ch] = g_tIR.s_LowWidth[ch] + _width;
00010c  4a3c              LDR      r2,|L2.512|
00010e  326c              ADDS     r2,r2,#0x6c
000110  f8322010          LDRH     r2,[r2,r0,LSL #1]
000114  440a              ADD      r2,r2,r1
000116  b293              UXTH     r3,r2
000118  4a39              LDR      r2,|L2.512|
00011a  327c              ADDS     r2,r2,#0x7c
00011c  f8223010          STRH     r3,[r2,r0,LSL #1]
;;;351    			/* 0的宽度为1.125ms，1的宽度为2.25ms */				
;;;352    			g_tIR.s_Byte[ch] <<= 1;
000120  3a08              SUBS     r2,r2,#8
000122  5c12              LDRB     r2,[r2,r0]
000124  0652              LSLS     r2,r2,#25
000126  0e13              LSRS     r3,r2,#24
000128  4a35              LDR      r2,|L2.512|
00012a  3274              ADDS     r2,r2,#0x74
00012c  5413              STRB     r3,[r2,r0]
;;;353    			if ((g_tIR.TotalWitdh[ch] > 92) && (g_tIR.TotalWitdh[ch] < 132))
00012e  3208              ADDS     r2,r2,#8
000130  f8322010          LDRH     r2,[r2,r0,LSL #1]
000134  2a5c              CMP      r2,#0x5c
000136  dd05              BLE      |L2.324|
000138  4a31              LDR      r2,|L2.512|
00013a  327c              ADDS     r2,r2,#0x7c
00013c  f8322010          LDRH     r2,[r2,r0,LSL #1]
000140  2a84              CMP      r2,#0x84
000142  db18              BLT      |L2.374|
                  |L2.324|
;;;354    			{
;;;355    				;					/* bit = 0 */
;;;356    			}
;;;357    			else if ((g_tIR.TotalWitdh[ch] > 205) && (g_tIR.TotalWitdh[ch] < 245))
000144  4a2e              LDR      r2,|L2.512|
000146  327c              ADDS     r2,r2,#0x7c
000148  f8322010          LDRH     r2,[r2,r0,LSL #1]
00014c  2acd              CMP      r2,#0xcd
00014e  dd0e              BLE      |L2.366|
000150  4a2b              LDR      r2,|L2.512|
000152  327c              ADDS     r2,r2,#0x7c
000154  f8322010          LDRH     r2,[r2,r0,LSL #1]
000158  2af5              CMP      r2,#0xf5
00015a  da08              BGE      |L2.366|
;;;358    			{
;;;359    				g_tIR.s_Byte[ch] += 0x01;		/* bit = 1 */
00015c  4a28              LDR      r2,|L2.512|
00015e  3274              ADDS     r2,r2,#0x74
000160  5c12              LDRB     r2,[r2,r0]
000162  1c52              ADDS     r2,r2,#1
000164  b2d3              UXTB     r3,r2
000166  4a26              LDR      r2,|L2.512|
000168  3274              ADDS     r2,r2,#0x74
00016a  5413              STRB     r3,[r2,r0]
00016c  e003              B        |L2.374|
                  |L2.366|
;;;360    			}	
;;;361    			else
;;;362    			{
;;;363    				/* 异常脉宽 */
;;;364    				g_tIR.Status[ch] = 0;	/* 复位解码器状态 */	
00016e  2300              MOVS     r3,#0
000170  4a23              LDR      r2,|L2.512|
000172  5413              STRB     r3,[r2,r0]
;;;365    				goto loop1;		/* 继续判断同步信号 */
000174  e746              B        |L2.4|
                  |L2.374|
;;;366    			}
;;;367    			
;;;368    			g_tIR.s_Bit[ch]++;
000176  4a22              LDR      r2,|L2.512|
000178  3278              ADDS     r2,r2,#0x78
00017a  5c12              LDRB     r2,[r2,r0]
00017c  1c52              ADDS     r2,r2,#1
00017e  b2d3              UXTB     r3,r2
000180  4a1f              LDR      r2,|L2.512|
000182  3278              ADDS     r2,r2,#0x78
000184  5413              STRB     r3,[r2,r0]
;;;369    			if (g_tIR.s_Bit[ch] == 8)	/* 收齐8位 */
000186  5c12              LDRB     r2,[r2,r0]
000188  2a08              CMP      r2,#8
00018a  d133              BNE      |L2.500|
;;;370    			{
;;;371    				g_tIR.RxBuf[ch][0] = g_tIR.s_Byte[ch];
00018c  4a1c              LDR      r2,|L2.512|
00018e  3274              ADDS     r2,r2,#0x74
000190  5c13              LDRB     r3,[r2,r0]
000192  3a70              SUBS     r2,r2,#0x70
000194  f8023020          STRB     r3,[r2,r0,LSL #2]
;;;372    				g_tIR.s_Byte[ch] = 0;
000198  2300              MOVS     r3,#0
00019a  3270              ADDS     r2,r2,#0x70
00019c  5413              STRB     r3,[r2,r0]
;;;373    				
;;;374    //				if(ch == IR_CH3)
;;;375    //					DEBUG("CH%d:%02X\r\n",ch+1,g_tIR.RxBuf[ch][0]);
;;;376    				/*更新辐射范围*/
;;;377    				if(g_tIR.RxBuf[ch][0] == IR_TX_CODE_LEFT)
00019e  3a70              SUBS     r2,r2,#0x70
0001a0  f8122020          LDRB     r2,[r2,r0,LSL #2]
0001a4  2a27              CMP      r2,#0x27
0001a6  d106              BNE      |L2.438|
;;;378    				{
;;;379    					g_tIR.isRevFilter[ch][IR_TX_SITE_LEFT] = true;
0001a8  2301              MOVS     r3,#1
0001aa  eb000440          ADD      r4,r0,r0,LSL #1
0001ae  4a14              LDR      r2,|L2.512|
0001b0  3230              ADDS     r2,r2,#0x30
0001b2  5513              STRB     r3,[r2,r4]
0001b4  e01a              B        |L2.492|
                  |L2.438|
;;;380    				}
;;;381    				else if(g_tIR.RxBuf[ch][0] == IR_TX_CODE_CENTER)
0001b6  4a12              LDR      r2,|L2.512|
0001b8  1d12              ADDS     r2,r2,#4
0001ba  f8122020          LDRB     r2,[r2,r0,LSL #2]
0001be  2a38              CMP      r2,#0x38
0001c0  d107              BNE      |L2.466|
;;;382    				{
;;;383    					g_tIR.isRevFilter[ch][IR_TX_SITE_CENTER] = true;
0001c2  2301              MOVS     r3,#1
0001c4  eb000440          ADD      r4,r0,r0,LSL #1
0001c8  4a0d              LDR      r2,|L2.512|
0001ca  3230              ADDS     r2,r2,#0x30
0001cc  4422              ADD      r2,r2,r4
0001ce  7053              STRB     r3,[r2,#1]
0001d0  e00c              B        |L2.492|
                  |L2.466|
;;;384    				}
;;;385    				else if(g_tIR.RxBuf[ch][0] == IR_TX_CODE_RIGHT)
0001d2  4a0b              LDR      r2,|L2.512|
0001d4  1d12              ADDS     r2,r2,#4
0001d6  f8122020          LDRB     r2,[r2,r0,LSL #2]
0001da  2a16              CMP      r2,#0x16
0001dc  d106              BNE      |L2.492|
;;;386    				{
;;;387    					g_tIR.isRevFilter[ch][IR_TX_SITE_RIGHT] = true;
0001de  2301              MOVS     r3,#1
0001e0  eb000440          ADD      r4,r0,r0,LSL #1
0001e4  4a06              LDR      r2,|L2.512|
0001e6  3230              ADDS     r2,r2,#0x30
0001e8  4422              ADD      r2,r2,r4
0001ea  7093              STRB     r3,[r2,#2]
                  |L2.492|
;;;388    				}
;;;389    				
;;;390    				g_tIR.Status[ch] = 0;	/* 等待下一组编码 */
0001ec  2300              MOVS     r3,#0
0001ee  4a04              LDR      r2,|L2.512|
0001f0  5413              STRB     r3,[r2,r0]
;;;391    				break;
0001f2  e003              B        |L2.508|
                  |L2.500|
;;;392    			}
;;;393    			g_tIR.Status[ch] = 2;	/* 继续下一个bit */
0001f4  2302              MOVS     r3,#2
0001f6  4a02              LDR      r2,|L2.512|
0001f8  5413              STRB     r3,[r2,r0]
;;;394    			break;	
0001fa  bf00              NOP      
                  |L2.508|
0001fc  bf00              NOP                            ;307
;;;395    	}
;;;396    }
0001fe  bd10              POP      {r4,pc}
;;;397    
                          ENDP

                  |L2.512|
                          DCD      g_tIR+0x8
                  |L2.516|
                          DCD      ||sss||

                          AREA ||i.bsp_IRD_StartWork||, CODE, READONLY, ALIGN=2

                  bsp_IRD_StartWork PROC
;;;145    */
;;;146    void bsp_IRD_StartWork(void)
000000  b510              PUSH     {r4,lr}
;;;147    {
000002  b088              SUB      sp,sp,#0x20
;;;148    	GPIO_InitTypeDef GPIO_InitStructure;
;;;149    	NVIC_InitTypeDef NVIC_InitStructure;
;;;150    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;151    	TIM_ICInitTypeDef  TIM_ICInitStructure;
;;;152    	uint16_t PrescalerValue;
;;;153    	
;;;154    	/* 时钟，重映射 */
;;;155    	RCC_APB2PeriphClockCmd(RCC_IRD, ENABLE);
000004  2101              MOVS     r1,#1
000006  2010              MOVS     r0,#0x10
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;156    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  2002              MOVS     r0,#2
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;157    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
000014  2101              MOVS     r1,#1
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;158    	GPIO_PinRemapConfig(GPIO_FullRemap_TIM3, ENABLE);
00001c  2101              MOVS     r1,#1
00001e  484d              LDR      r0,|L3.340|
000020  f7fffffe          BL       GPIO_PinRemapConfig
;;;159    
;;;160    	/* 配置为输入引脚 */
;;;161    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000024  2003              MOVS     r0,#3
000026  f88d001e          STRB     r0,[sp,#0x1e]
;;;162    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;	/* 输入模式 */
00002a  2004              MOVS     r0,#4
00002c  f88d001f          STRB     r0,[sp,#0x1f]
;;;163    	GPIO_InitStructure.GPIO_Pin = PIN_IRD;
000030  f44f7070          MOV      r0,#0x3c0
000034  f8ad001c          STRH     r0,[sp,#0x1c]
;;;164    	GPIO_Init(PORT_IRD, &GPIO_InitStructure);	
000038  a907              ADD      r1,sp,#0x1c
00003a  4847              LDR      r0,|L3.344|
00003c  f7fffffe          BL       GPIO_Init
;;;165    	
;;;166    	/* 定时器3中断分组 */
;;;167    	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
000040  201d              MOVS     r0,#0x1d
000042  f88d0018          STRB     r0,[sp,#0x18]
;;;168    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000046  2000              MOVS     r0,#0
000048  f88d0019          STRB     r0,[sp,#0x19]
;;;169    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00004c  f88d001a          STRB     r0,[sp,#0x1a]
;;;170    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000050  2001              MOVS     r0,#1
000052  f88d001b          STRB     r0,[sp,#0x1b]
;;;171    	NVIC_Init(&NVIC_InitStructure);
000056  a806              ADD      r0,sp,#0x18
000058  f7fffffe          BL       NVIC_Init
;;;172    
;;;173    	/* 设置分频为, 捕获计数器值的单位正好是 10us, 方便脉宽比较。 */
;;;174    	PrescalerValue = 72000000/100000 - 1;
00005c  f24024cf          MOV      r4,#0x2cf
;;;175    	TIM_TimeBaseStructure.TIM_Period = 65535;
000060  f64f70ff          MOV      r0,#0xffff
000064  f8ad0010          STRH     r0,[sp,#0x10]
;;;176    	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
000068  f8ad400c          STRH     r4,[sp,#0xc]
;;;177    	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
00006c  2000              MOVS     r0,#0
00006e  f8ad0012          STRH     r0,[sp,#0x12]
;;;178    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
000072  f8ad000e          STRH     r0,[sp,#0xe]
;;;179    	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0x0000;
000076  f88d0014          STRB     r0,[sp,#0x14]
;;;180    	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
00007a  a903              ADD      r1,sp,#0xc
00007c  4837              LDR      r0,|L3.348|
00007e  f7fffffe          BL       TIM_TimeBaseInit
;;;181    	
;;;182    	/*输入捕获参数配置*/
;;;183    	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling;	/*对于TIM3，TIM_ICPolarity_BothEdge不起作用，自己切换上下降沿*/ 
000082  2002              MOVS     r0,#2
000084  f8ad0002          STRH     r0,[sp,#2]
;;;184    	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
000088  2001              MOVS     r0,#1
00008a  f8ad0004          STRH     r0,[sp,#4]
;;;185    	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			/* 每次跳变都产生1次捕获事件 */
00008e  2000              MOVS     r0,#0
000090  f8ad0006          STRH     r0,[sp,#6]
;;;186    	TIM_ICInitStructure.TIM_ICFilter = 0x0;	
000094  f8ad0008          STRH     r0,[sp,#8]
;;;187    	
;;;188    	/*每个通道*/
;;;189    	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;
000098  f8ad0000          STRH     r0,[sp,#0]
;;;190    	TIM_ICInit(TIM3, &TIM_ICInitStructure);
00009c  4669              MOV      r1,sp
00009e  482f              LDR      r0,|L3.348|
0000a0  f7fffffe          BL       TIM_ICInit
;;;191    	
;;;192    	TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;
0000a4  2004              MOVS     r0,#4
0000a6  f8ad0000          STRH     r0,[sp,#0]
;;;193    	TIM_ICInit(TIM3, &TIM_ICInitStructure);
0000aa  4669              MOV      r1,sp
0000ac  482b              LDR      r0,|L3.348|
0000ae  f7fffffe          BL       TIM_ICInit
;;;194    	
;;;195    	TIM_ICInitStructure.TIM_Channel = TIM_Channel_3;
0000b2  2008              MOVS     r0,#8
0000b4  f8ad0000          STRH     r0,[sp,#0]
;;;196    	TIM_ICInit(TIM3, &TIM_ICInitStructure);
0000b8  4669              MOV      r1,sp
0000ba  4828              LDR      r0,|L3.348|
0000bc  f7fffffe          BL       TIM_ICInit
;;;197    	
;;;198    	TIM_ICInitStructure.TIM_Channel = TIM_Channel_4;
0000c0  200c              MOVS     r0,#0xc
0000c2  f8ad0000          STRH     r0,[sp,#0]
;;;199    	TIM_ICInit(TIM3, &TIM_ICInitStructure);
0000c6  4669              MOV      r1,sp
0000c8  4824              LDR      r0,|L3.348|
0000ca  f7fffffe          BL       TIM_ICInit
;;;200    	
;;;201    	/*配置溢出中断和输入捕获中断*/
;;;202    	TIM_ITConfig(TIM3, TIM_IT_CC1, ENABLE);
0000ce  2201              MOVS     r2,#1
0000d0  2102              MOVS     r1,#2
0000d2  4822              LDR      r0,|L3.348|
0000d4  f7fffffe          BL       TIM_ITConfig
;;;203    	TIM_ITConfig(TIM3, TIM_IT_CC2, ENABLE);
0000d8  2201              MOVS     r2,#1
0000da  2104              MOVS     r1,#4
0000dc  481f              LDR      r0,|L3.348|
0000de  f7fffffe          BL       TIM_ITConfig
;;;204    	TIM_ITConfig(TIM3, TIM_IT_CC3, ENABLE);
0000e2  2201              MOVS     r2,#1
0000e4  2108              MOVS     r1,#8
0000e6  481d              LDR      r0,|L3.348|
0000e8  f7fffffe          BL       TIM_ITConfig
;;;205    	TIM_ITConfig(TIM3, TIM_IT_CC4, ENABLE);
0000ec  2201              MOVS     r2,#1
0000ee  2110              MOVS     r1,#0x10
0000f0  481a              LDR      r0,|L3.348|
0000f2  f7fffffe          BL       TIM_ITConfig
;;;206    	
;;;207    	TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);	/* 溢出中断使能，用于超时同步处理 */
0000f6  2201              MOVS     r2,#1
0000f8  4611              MOV      r1,r2
0000fa  4818              LDR      r0,|L3.348|
0000fc  f7fffffe          BL       TIM_ITConfig
;;;208    	
;;;209    	/*初始状态*/
;;;210    	g_tIR.LastCapture[IR_CH1] = 0;	
000100  2000              MOVS     r0,#0
000102  4917              LDR      r1,|L3.352|
000104  8008              STRH     r0,[r1,#0]
;;;211    	g_tIR.Status[IR_CH1] = 0;
000106  7208              STRB     r0,[r1,#8]
;;;212    	g_tIR.WaitFallEdge[IR_CH1] = 1;	/* 0 表示等待上升沿，1表示等待下降沿，用于切换输入捕获极性 */
000108  2001              MOVS     r0,#1
00010a  f8810020          STRB     r0,[r1,#0x20]
;;;213    	
;;;214    	g_tIR.LastCapture[IR_CH2] = 0;	
00010e  2000              MOVS     r0,#0
000110  8048              STRH     r0,[r1,#2]
;;;215    	g_tIR.Status[IR_CH2] = 0;
000112  2100              MOVS     r1,#0
000114  4812              LDR      r0,|L3.352|
000116  7241              STRB     r1,[r0,#9]
;;;216    	g_tIR.WaitFallEdge[IR_CH2] = 1;	/* 0 表示等待上升沿，1表示等待下降沿，用于切换输入捕获极性 */
000118  2101              MOVS     r1,#1
00011a  f8801021          STRB     r1,[r0,#0x21]
;;;217    	
;;;218    	g_tIR.LastCapture[IR_CH3] = 0;	
00011e  2000              MOVS     r0,#0
000120  490f              LDR      r1,|L3.352|
000122  8088              STRH     r0,[r1,#4]
;;;219    	g_tIR.Status[IR_CH3] = 0;
000124  2100              MOVS     r1,#0
000126  480e              LDR      r0,|L3.352|
000128  7281              STRB     r1,[r0,#0xa]
;;;220    	g_tIR.WaitFallEdge[IR_CH3] = 1;	/* 0 表示等待上升沿，1表示等待下降沿，用于切换输入捕获极性 */
00012a  2101              MOVS     r1,#1
00012c  f8801022          STRB     r1,[r0,#0x22]
;;;221    	
;;;222    	g_tIR.LastCapture[IR_CH4] = 0;	
000130  2000              MOVS     r0,#0
000132  490b              LDR      r1,|L3.352|
000134  80c8              STRH     r0,[r1,#6]
;;;223    	g_tIR.Status[IR_CH4] = 0;
000136  2100              MOVS     r1,#0
000138  4809              LDR      r0,|L3.352|
00013a  72c1              STRB     r1,[r0,#0xb]
;;;224    	g_tIR.WaitFallEdge[IR_CH4] = 1;	/* 0 表示等待上升沿，1表示等待下降沿，用于切换输入捕获极性 */
00013c  2101              MOVS     r1,#1
00013e  f8801023          STRB     r1,[r0,#0x23]
;;;225    	
;;;226    	bsp_IR_SoftTimerInit();
000142  f7fffffe          BL       bsp_IR_SoftTimerInit
;;;227    	
;;;228    	/* 使能定时器 */
;;;229    	TIM_Cmd(TIM3, ENABLE);
000146  2101              MOVS     r1,#1
000148  4804              LDR      r0,|L3.348|
00014a  f7fffffe          BL       TIM_Cmd
;;;230    }
00014e  b008              ADD      sp,sp,#0x20
000150  bd10              POP      {r4,pc}
;;;231    
                          ENDP

000152  0000              DCW      0x0000
                  |L3.340|
                          DCD      0x001a0c00
                  |L3.344|
                          DCD      0x40011000
                  |L3.348|
                          DCD      0x40000400
                  |L3.352|
                          DCD      g_tIR

                          AREA ||i.bsp_IRD_StopWork||, CODE, READONLY, ALIGN=2

                  bsp_IRD_StopWork PROC
;;;239    */
;;;240    void bsp_IRD_StopWork(void)
000000  b510              PUSH     {r4,lr}
;;;241    {
;;;242    	TIM_Cmd(TIM3, DISABLE);
000002  2100              MOVS     r1,#0
000004  480b              LDR      r0,|L4.52|
000006  f7fffffe          BL       TIM_Cmd
;;;243    	
;;;244    	TIM_ITConfig(TIM3, TIM_IT_CC1, DISABLE);
00000a  2200              MOVS     r2,#0
00000c  2102              MOVS     r1,#2
00000e  4809              LDR      r0,|L4.52|
000010  f7fffffe          BL       TIM_ITConfig
;;;245    	TIM_ITConfig(TIM3, TIM_IT_CC2, DISABLE);	
000014  2200              MOVS     r2,#0
000016  2104              MOVS     r1,#4
000018  4806              LDR      r0,|L4.52|
00001a  f7fffffe          BL       TIM_ITConfig
;;;246    	TIM_ITConfig(TIM3, TIM_IT_CC3, DISABLE);	
00001e  2200              MOVS     r2,#0
000020  2108              MOVS     r1,#8
000022  4804              LDR      r0,|L4.52|
000024  f7fffffe          BL       TIM_ITConfig
;;;247    	TIM_ITConfig(TIM3, TIM_IT_CC4, DISABLE);		
000028  2200              MOVS     r2,#0
00002a  2110              MOVS     r1,#0x10
00002c  4801              LDR      r0,|L4.52|
00002e  f7fffffe          BL       TIM_ITConfig
;;;248    }
000032  bd10              POP      {r4,pc}
;;;249    
                          ENDP

                  |L4.52|
                          DCD      0x40000400

                          AREA ||i.bsp_IR_GetPulseWidth||, CODE, READONLY, ALIGN=2

                  bsp_IR_GetPulseWidth PROC
;;;444    
;;;445    static void bsp_IR_GetPulseWidth(IR_CH ch)
000000  b570              PUSH     {r4-r6,lr}
;;;446    {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;447    	uint16_t NowCapture;
;;;448    	uint16_t Width;
;;;449    	uint32_t TIM_CH[IR_COUNT] = {TIM_Channel_1,TIM_Channel_2,TIM_Channel_3,TIM_Channel_4};
000006  4b47              LDR      r3,|L5.292|
000008  cb0f              LDM      r3,{r0-r3}
00000a  ad04              ADD      r5,sp,#0x10
00000c  c50f              STM      r5!,{r0-r3}
;;;450    	
;;;451    	
;;;452    	g_tIR.TimeOut[ch] = 0;  /* 清零超时计数器 */
00000e  2100              MOVS     r1,#0
000010  4845              LDR      r0,|L5.296|
000012  f8201014          STRH     r1,[r0,r4,LSL #1]
;;;453    	
;;;454    	if(ch == IR_CH1)
000016  b924              CBNZ     r4,|L5.34|
;;;455    	{
;;;456    		NowCapture = TIM_GetCapture1(TIM3);	/* 读取捕获的计数器值，计数器值从0-65535循环计数 */
000018  4844              LDR      r0,|L5.300|
00001a  f7fffffe          BL       TIM_GetCapture1
00001e  4605              MOV      r5,r0
000020  e013              B        |L5.74|
                  |L5.34|
;;;457    	}
;;;458    	else if(ch == IR_CH2)
000022  2c01              CMP      r4,#1
000024  d104              BNE      |L5.48|
;;;459    	{
;;;460    		NowCapture = TIM_GetCapture2(TIM3);	/* 读取捕获的计数器值，计数器值从0-65535循环计数 */
000026  4841              LDR      r0,|L5.300|
000028  f7fffffe          BL       TIM_GetCapture2
00002c  4605              MOV      r5,r0
00002e  e00c              B        |L5.74|
                  |L5.48|
;;;461    	}
;;;462    	else if(ch == IR_CH3)
000030  2c02              CMP      r4,#2
000032  d104              BNE      |L5.62|
;;;463    	{
;;;464    		NowCapture = TIM_GetCapture3(TIM3);	/* 读取捕获的计数器值，计数器值从0-65535循环计数 */
000034  483d              LDR      r0,|L5.300|
000036  f7fffffe          BL       TIM_GetCapture3
00003a  4605              MOV      r5,r0
00003c  e005              B        |L5.74|
                  |L5.62|
;;;465    	}
;;;466    	else if(ch == IR_CH4)
00003e  2c03              CMP      r4,#3
000040  d103              BNE      |L5.74|
;;;467    	{
;;;468    		NowCapture = TIM_GetCapture4(TIM3);	/* 读取捕获的计数器值，计数器值从0-65535循环计数 */
000042  483a              LDR      r0,|L5.300|
000044  f7fffffe          BL       TIM_GetCapture4
000048  4605              MOV      r5,r0
                  |L5.74|
;;;469    	}
;;;470    	
;;;471    
;;;472    	/* 	切换捕获的极性 */
;;;473    	if (g_tIR.WaitFallEdge[ch] == 0)
00004a  4837              LDR      r0,|L5.296|
00004c  1f00              SUBS     r0,r0,#4
00004e  5d00              LDRB     r0,[r0,r4]
000050  b9c8              CBNZ     r0,|L5.134|
;;;474    	{
;;;475    		TIM_ICInitTypeDef  TIM_ICInitStructure;
;;;476    		
;;;477    		TIM_ICInitStructure.TIM_Channel = TIM_CH[ch];
000052  a804              ADD      r0,sp,#0x10
000054  f8300024          LDRH     r0,[r0,r4,LSL #2]
000058  b280              UXTH     r0,r0
00005a  f8ad0004          STRH     r0,[sp,#4]
;;;478    		TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling;	/* 等待下降沿 */
00005e  2002              MOVS     r0,#2
000060  f8ad0006          STRH     r0,[sp,#6]
;;;479    		TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
000064  2001              MOVS     r0,#1
000066  f8ad0008          STRH     r0,[sp,#8]
;;;480    		TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			/* 每次跳变都产生1次捕获事件 */
00006a  2000              MOVS     r0,#0
00006c  f8ad000a          STRH     r0,[sp,#0xa]
;;;481    		TIM_ICInitStructure.TIM_ICFilter = 0x0;	
000070  f8ad000c          STRH     r0,[sp,#0xc]
;;;482    		TIM_ICInit(TIM3, &TIM_ICInitStructure);	
000074  a901              ADD      r1,sp,#4
000076  482d              LDR      r0,|L5.300|
000078  f7fffffe          BL       TIM_ICInit
;;;483    		
;;;484    		g_tIR.WaitFallEdge[ch] = 1;
00007c  2101              MOVS     r1,#1
00007e  482a              LDR      r0,|L5.296|
000080  1f00              SUBS     r0,r0,#4
000082  5501              STRB     r1,[r0,r4]
;;;485    	}			
000084  e019              B        |L5.186|
                  |L5.134|
;;;486    	else
;;;487    	{
;;;488    		TIM_ICInitTypeDef  TIM_ICInitStructure;
;;;489    		
;;;490    		TIM_ICInitStructure.TIM_Channel = TIM_CH[ch];
000086  a804              ADD      r0,sp,#0x10
000088  f8300024          LDRH     r0,[r0,r4,LSL #2]
00008c  b280              UXTH     r0,r0
00008e  f8ad0004          STRH     r0,[sp,#4]
;;;491    		TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;		/* 等待上升沿 */
000092  2000              MOVS     r0,#0
000094  f8ad0006          STRH     r0,[sp,#6]
;;;492    		TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
000098  2001              MOVS     r0,#1
00009a  f8ad0008          STRH     r0,[sp,#8]
;;;493    		TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			/* 每次跳变都产生1次捕获事件 */
00009e  2000              MOVS     r0,#0
0000a0  f8ad000a          STRH     r0,[sp,#0xa]
;;;494    		TIM_ICInitStructure.TIM_ICFilter = 0x0;	
0000a4  f8ad000c          STRH     r0,[sp,#0xc]
;;;495    		TIM_ICInit(TIM3, &TIM_ICInitStructure);	
0000a8  a901              ADD      r1,sp,#4
0000aa  4820              LDR      r0,|L5.300|
0000ac  f7fffffe          BL       TIM_ICInit
;;;496    		
;;;497    		g_tIR.WaitFallEdge[ch] = 0;
0000b0  2100              MOVS     r1,#0
0000b2  481d              LDR      r0,|L5.296|
0000b4  1f00              SUBS     r0,r0,#4
0000b6  5501              STRB     r1,[r0,r4]
;;;498    	}
0000b8  bf00              NOP      
                  |L5.186|
;;;499    	
;;;500    	if (NowCapture >= g_tIR.LastCapture[ch])
0000ba  481b              LDR      r0,|L5.296|
0000bc  3824              SUBS     r0,r0,#0x24
0000be  f8300014          LDRH     r0,[r0,r4,LSL #1]
0000c2  42a8              CMP      r0,r5
0000c4  dc06              BGT      |L5.212|
;;;501    	{
;;;502    		Width = NowCapture - g_tIR.LastCapture[ch];
0000c6  4818              LDR      r0,|L5.296|
0000c8  3824              SUBS     r0,r0,#0x24
0000ca  f8300014          LDRH     r0,[r0,r4,LSL #1]
0000ce  1a28              SUBS     r0,r5,r0
0000d0  b286              UXTH     r6,r0
0000d2  e00e              B        |L5.242|
                  |L5.212|
;;;503    	}
;;;504    	else if (NowCapture < g_tIR.LastCapture[ch])	/* 计数器抵达最大并翻转 */
0000d4  4814              LDR      r0,|L5.296|
0000d6  3824              SUBS     r0,r0,#0x24
0000d8  f8300014          LDRH     r0,[r0,r4,LSL #1]
0000dc  42a8              CMP      r0,r5
0000de  dd08              BLE      |L5.242|
;;;505    	{
;;;506    		Width = ((0xFFFF - g_tIR.LastCapture[ch]) + NowCapture);
0000e0  4811              LDR      r0,|L5.296|
0000e2  3824              SUBS     r0,r0,#0x24
0000e4  f8300014          LDRH     r0,[r0,r4,LSL #1]
0000e8  f64f71ff          MOV      r1,#0xffff
0000ec  1a08              SUBS     r0,r1,r0
0000ee  4428              ADD      r0,r0,r5
0000f0  b286              UXTH     r6,r0
                  |L5.242|
;;;507    	}			
;;;508    	
;;;509    	if ((g_tIR.Status[ch] == 0) && (g_tIR.LastCapture[ch] == 0))
0000f2  480d              LDR      r0,|L5.296|
0000f4  381c              SUBS     r0,r0,#0x1c
0000f6  5d00              LDRB     r0,[r0,r4]
0000f8  b950              CBNZ     r0,|L5.272|
0000fa  480b              LDR      r0,|L5.296|
0000fc  3824              SUBS     r0,r0,#0x24
0000fe  f8300014          LDRH     r0,[r0,r4,LSL #1]
000102  b928              CBNZ     r0,|L5.272|
;;;510    	{
;;;511    		g_tIR.LastCapture[ch] = NowCapture;
000104  4808              LDR      r0,|L5.296|
000106  3824              SUBS     r0,r0,#0x24
000108  f8205014          STRH     r5,[r0,r4,LSL #1]
                  |L5.268|
;;;512    		return;
;;;513    	}
;;;514    			
;;;515    	g_tIR.LastCapture[ch] = NowCapture;	/* 保存当前计数器，用于下次计算差值 */
;;;516    	
;;;517    	bsp_IRD_DecodeNec(ch , Width);		/* 解码 */	
;;;518    }
00010c  b008              ADD      sp,sp,#0x20
00010e  bd70              POP      {r4-r6,pc}
                  |L5.272|
000110  4805              LDR      r0,|L5.296|
000112  3824              SUBS     r0,r0,#0x24           ;515
000114  f8205014          STRH     r5,[r0,r4,LSL #1]     ;515
000118  4631              MOV      r1,r6                 ;517
00011a  4620              MOV      r0,r4                 ;517
00011c  f7fffffe          BL       bsp_IRD_DecodeNec
000120  bf00              NOP      
000122  e7f3              B        |L5.268|
;;;519    
                          ENDP

                  |L5.292|
                          DCD      ||.constdata||+0x10
                  |L5.296|
                          DCD      g_tIR+0x24
                  |L5.300|
                          DCD      0x40000400

                          AREA ||i.bsp_IR_GetRev||, CODE, READONLY, ALIGN=2

                  bsp_IR_GetRev PROC
;;;44     */
;;;45     bool bsp_IR_GetRev(IR_CH ch , IRSite site)
000000  4602              MOV      r2,r0
;;;46     {
;;;47     	return g_tIR.isRev[ch][site];
000002  eb020342          ADD      r3,r2,r2,LSL #1
000006  4802              LDR      r0,|L6.16|
000008  4418              ADD      r0,r0,r3
00000a  5c40              LDRB     r0,[r0,r1]
;;;48     }
00000c  4770              BX       lr
;;;49     
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      g_tIR+0x2c

                          AREA ||i.bsp_IR_SoftTick||, CODE, READONLY, ALIGN=2

                  bsp_IR_SoftTick PROC
;;;89     */
;;;90     static void bsp_IR_SoftTick(IR_CH ch , IRSite site)
000000  b510              PUSH     {r4,lr}
;;;91     {
;;;92     	/*如果收到红外了，则软件定时器值一直给0*/
;;;93     	if(g_tIR.isRev[ch][site])
000002  eb000340          ADD      r3,r0,r0,LSL #1
000006  4a18              LDR      r2,|L7.104|
000008  441a              ADD      r2,r2,r3
00000a  5c52              LDRB     r2,[r2,r1]
00000c  b312              CBZ      r2,|L7.84|
;;;94     	{
;;;95     		if(++g_tIR.softTimer[ch][site] >= IR_UPDATE_T)
00000e  eb000340          ADD      r3,r0,r0,LSL #1
000012  4a15              LDR      r2,|L7.104|
000014  3218              ADDS     r2,r2,#0x18
000016  eb020283          ADD      r2,r2,r3,LSL #2
00001a  f8522021          LDR      r2,[r2,r1,LSL #2]
00001e  1c52              ADDS     r2,r2,#1
000020  eb000440          ADD      r4,r0,r0,LSL #1
000024  4b10              LDR      r3,|L7.104|
000026  3318              ADDS     r3,r3,#0x18
000028  eb030384          ADD      r3,r3,r4,LSL #2
00002c  f8432021          STR      r2,[r3,r1,LSL #2]
000030  f5b27f7a          CMP      r2,#0x3e8
000034  d317              BCC      |L7.102|
;;;96     		{
;;;97     			g_tIR.softTimer[ch][site] = 0 ;
000036  2300              MOVS     r3,#0
000038  eb000440          ADD      r4,r0,r0,LSL #1
00003c  4a0a              LDR      r2,|L7.104|
00003e  3218              ADDS     r2,r2,#0x18
000040  eb020284          ADD      r2,r2,r4,LSL #2
000044  f8423021          STR      r3,[r2,r1,LSL #2]
;;;98     			g_tIR.isRev[ch][site] = false;
000048  eb000440          ADD      r4,r0,r0,LSL #1
00004c  4a06              LDR      r2,|L7.104|
00004e  4422              ADD      r2,r2,r4
000050  5453              STRB     r3,[r2,r1]
000052  e008              B        |L7.102|
                  |L7.84|
;;;99     		}
;;;100    	}
;;;101    	else
;;;102    	{
;;;103    		g_tIR.softTimer[ch][site] = 0 ;
000054  2300              MOVS     r3,#0
000056  eb000440          ADD      r4,r0,r0,LSL #1
00005a  4a03              LDR      r2,|L7.104|
00005c  3218              ADDS     r2,r2,#0x18
00005e  eb020284          ADD      r2,r2,r4,LSL #2
000062  f8423021          STR      r3,[r2,r1,LSL #2]
                  |L7.102|
;;;104    	}
;;;105    }
000066  bd10              POP      {r4,pc}
;;;106    
                          ENDP

                  |L7.104|
                          DCD      g_tIR+0x2c

                          AREA ||i.bsp_IR_SoftTimerInit||, CODE, READONLY, ALIGN=2

                  bsp_IR_SoftTimerInit PROC
;;;527    */
;;;528    static void bsp_IR_SoftTimerInit(void)
000000  2000              MOVS     r0,#0
;;;529    {
;;;530    	g_tIR.softTimer[IR_CH1][IR_TX_SITE_LEFT]   = 0 ;
000002  4908              LDR      r1,|L8.36|
000004  6448              STR      r0,[r1,#0x44]  ; g_tIR
;;;531    	g_tIR.softTimer[IR_CH1][IR_TX_SITE_CENTER] = 0 ;
000006  2100              MOVS     r1,#0
000008  4806              LDR      r0,|L8.36|
00000a  6481              STR      r1,[r0,#0x48]
;;;532    	g_tIR.softTimer[IR_CH1][IR_TX_SITE_RIGHT]  = 0 ;
00000c  64c1              STR      r1,[r0,#0x4c]
;;;533    	
;;;534    	g_tIR.softTimer[IR_CH2][IR_TX_SITE_LEFT]   = 0 ;
00000e  6501              STR      r1,[r0,#0x50]
;;;535    	g_tIR.softTimer[IR_CH2][IR_TX_SITE_CENTER] = 0 ;
000010  6541              STR      r1,[r0,#0x54]
;;;536    	g_tIR.softTimer[IR_CH2][IR_TX_SITE_RIGHT]  = 0 ;
000012  6581              STR      r1,[r0,#0x58]
;;;537    	
;;;538    	g_tIR.softTimer[IR_CH3][IR_TX_SITE_LEFT]   = 0 ;
000014  65c1              STR      r1,[r0,#0x5c]
;;;539    	g_tIR.softTimer[IR_CH3][IR_TX_SITE_CENTER] = 0 ;
000016  6601              STR      r1,[r0,#0x60]
;;;540    	g_tIR.softTimer[IR_CH3][IR_TX_SITE_RIGHT]  = 0 ;
000018  6641              STR      r1,[r0,#0x64]
;;;541    	
;;;542    	g_tIR.softTimer[IR_CH4][IR_TX_SITE_LEFT]   = 0 ;
00001a  6681              STR      r1,[r0,#0x68]
;;;543    	g_tIR.softTimer[IR_CH4][IR_TX_SITE_CENTER] = 0 ;
00001c  66c1              STR      r1,[r0,#0x6c]
;;;544    	g_tIR.softTimer[IR_CH4][IR_TX_SITE_RIGHT]  = 0 ;
00001e  6701              STR      r1,[r0,#0x70]
;;;545    	
;;;546    }
000020  4770              BX       lr
;;;547    
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      g_tIR

                          AREA ||i.bsp_IR_SoftTimerTickPerMS||, CODE, READONLY, ALIGN=1

                  bsp_IR_SoftTimerTickPerMS PROC
;;;116    */
;;;117    void bsp_IR_SoftTimerTickPerMS(void)
000000  b510              PUSH     {r4,lr}
;;;118    {
;;;119    	bsp_IR_SoftTick(IR_CH1,IR_TX_SITE_LEFT);
000002  2100              MOVS     r1,#0
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       bsp_IR_SoftTick
;;;120    	bsp_IR_SoftTick(IR_CH1,IR_TX_SITE_CENTER);
00000a  2101              MOVS     r1,#1
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       bsp_IR_SoftTick
;;;121    	bsp_IR_SoftTick(IR_CH1,IR_TX_SITE_RIGHT);
000012  2102              MOVS     r1,#2
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       bsp_IR_SoftTick
;;;122    	
;;;123    	bsp_IR_SoftTick(IR_CH2,IR_TX_SITE_LEFT);
00001a  2100              MOVS     r1,#0
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       bsp_IR_SoftTick
;;;124    	bsp_IR_SoftTick(IR_CH2,IR_TX_SITE_CENTER);
000022  2101              MOVS     r1,#1
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       bsp_IR_SoftTick
;;;125    	bsp_IR_SoftTick(IR_CH2,IR_TX_SITE_RIGHT);
00002a  2102              MOVS     r1,#2
00002c  2001              MOVS     r0,#1
00002e  f7fffffe          BL       bsp_IR_SoftTick
;;;126    	
;;;127    	bsp_IR_SoftTick(IR_CH3,IR_TX_SITE_LEFT);
000032  2100              MOVS     r1,#0
000034  2002              MOVS     r0,#2
000036  f7fffffe          BL       bsp_IR_SoftTick
;;;128    	bsp_IR_SoftTick(IR_CH3,IR_TX_SITE_CENTER);
00003a  2101              MOVS     r1,#1
00003c  2002              MOVS     r0,#2
00003e  f7fffffe          BL       bsp_IR_SoftTick
;;;129    	bsp_IR_SoftTick(IR_CH3,IR_TX_SITE_RIGHT);
000042  2102              MOVS     r1,#2
000044  4608              MOV      r0,r1
000046  f7fffffe          BL       bsp_IR_SoftTick
;;;130    	
;;;131    	bsp_IR_SoftTick(IR_CH4,IR_TX_SITE_LEFT);
00004a  2100              MOVS     r1,#0
00004c  2003              MOVS     r0,#3
00004e  f7fffffe          BL       bsp_IR_SoftTick
;;;132    	bsp_IR_SoftTick(IR_CH4,IR_TX_SITE_CENTER);
000052  2101              MOVS     r1,#1
000054  2003              MOVS     r0,#3
000056  f7fffffe          BL       bsp_IR_SoftTick
;;;133    	bsp_IR_SoftTick(IR_CH4,IR_TX_SITE_RIGHT);
00005a  2102              MOVS     r1,#2
00005c  2003              MOVS     r0,#3
00005e  f7fffffe          BL       bsp_IR_SoftTick
;;;134    }
000062  bd10              POP      {r4,pc}
;;;135    
                          ENDP


                          AREA ||i.bsp_IR_TimeOutProc||, CODE, READONLY, ALIGN=2

                  bsp_IR_TimeOutProc PROC
;;;406    */
;;;407    static void bsp_IR_TimeOutProc(IR_CH ch)
000000  b510              PUSH     {r4,lr}
;;;408    {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;409    	uint32_t TIM_CH[IR_COUNT] = {TIM_Channel_1,TIM_Channel_2,TIM_Channel_3,TIM_Channel_4};
000006  4b28              LDR      r3,|L10.168|
000008  cb0f              LDM      r3,{r0-r3}
00000a  e9cd2306          STRD     r2,r3,[sp,#0x18]
00000e  e9cd0104          STRD     r0,r1,[sp,#0x10]
;;;410    	
;;;411    	/* TIM3 计数器源频率10us, 655360us = 0.655ms; */
;;;412    	if (g_tIR.TimeOut[ch] < 2)
000012  4826              LDR      r0,|L10.172|
000014  f8300014          LDRH     r0,[r0,r4,LSL #1]
000018  2802              CMP      r0,#2
00001a  da42              BGE      |L10.162|
;;;413    	{
;;;414    		if (++g_tIR.TimeOut[ch] == 2)
00001c  4823              LDR      r0,|L10.172|
00001e  f8300014          LDRH     r0,[r0,r4,LSL #1]
000022  1c40              ADDS     r0,r0,#1
000024  b281              UXTH     r1,r0
000026  4821              LDR      r0,|L10.172|
000028  f8201014          STRH     r1,[r0,r4,LSL #1]
00002c  2902              CMP      r1,#2
00002e  d138              BNE      |L10.162|
;;;415    		{
;;;416    			/* 强制设置为下降沿触发 */
;;;417    			{
;;;418    				TIM_ICInitTypeDef  TIM_ICInitStructure;
;;;419    				
;;;420    				TIM_ICInitStructure.TIM_Channel = TIM_CH[ch];
000030  a804              ADD      r0,sp,#0x10
000032  f8300024          LDRH     r0,[r0,r4,LSL #2]
000036  b280              UXTH     r0,r0
000038  f8ad0004          STRH     r0,[sp,#4]
;;;421    				TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling;	/* 等待下降沿 */
00003c  2002              MOVS     r0,#2
00003e  f8ad0006          STRH     r0,[sp,#6]
;;;422    				TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
000042  2001              MOVS     r0,#1
000044  f8ad0008          STRH     r0,[sp,#8]
;;;423    				TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			/* 每次跳变都产生1次捕获事件 */
000048  2000              MOVS     r0,#0
00004a  f8ad000a          STRH     r0,[sp,#0xa]
;;;424    				TIM_ICInitStructure.TIM_ICFilter = 0x0;	
00004e  f8ad000c          STRH     r0,[sp,#0xc]
;;;425    				TIM_ICInit(TIM3, &TIM_ICInitStructure);	
000052  a901              ADD      r1,sp,#4
000054  4816              LDR      r0,|L10.176|
000056  f7fffffe          BL       TIM_ICInit
;;;426    				
;;;427    				g_tIR.WaitFallEdge[ch] = 1;
00005a  2101              MOVS     r1,#1
00005c  4813              LDR      r0,|L10.172|
00005e  1f00              SUBS     r0,r0,#4
000060  5501              STRB     r1,[r0,r4]
;;;428    			}
;;;429    
;;;430    			g_tIR.Status[ch] = 0;	/* 等待下一组编码 */
000062  2100              MOVS     r1,#0
000064  3818              SUBS     r0,r0,#0x18
000066  5501              STRB     r1,[r0,r4]
;;;431    			
;;;432    			/*长时间都没得脉冲了，说明没有红外信号*/
;;;433    			g_tIR.isRev[ch][IR_TX_SITE_LEFT] = false;
000068  eb040244          ADD      r2,r4,r4,LSL #1
00006c  3024              ADDS     r0,r0,#0x24
00006e  5481              STRB     r1,[r0,r2]
;;;434    			g_tIR.isRev[ch][IR_TX_SITE_CENTER] = false;
000070  eb040244          ADD      r2,r4,r4,LSL #1
000074  4410              ADD      r0,r0,r2
000076  7041              STRB     r1,[r0,#1]
;;;435    			g_tIR.isRev[ch][IR_TX_SITE_RIGHT] = false;
000078  eb040244          ADD      r2,r4,r4,LSL #1
00007c  480b              LDR      r0,|L10.172|
00007e  3008              ADDS     r0,r0,#8
000080  4410              ADD      r0,r0,r2
000082  7081              STRB     r1,[r0,#2]
;;;436    			
;;;437    			g_tIR.isRevFilter[ch][IR_TX_SITE_LEFT] = false;
000084  eb040244          ADD      r2,r4,r4,LSL #1
000088  4808              LDR      r0,|L10.172|
00008a  3014              ADDS     r0,r0,#0x14
00008c  5481              STRB     r1,[r0,r2]
;;;438    			g_tIR.isRevFilter[ch][IR_TX_SITE_CENTER] = false;
00008e  eb040244          ADD      r2,r4,r4,LSL #1
000092  4410              ADD      r0,r0,r2
000094  7041              STRB     r1,[r0,#1]
;;;439    			g_tIR.isRevFilter[ch][IR_TX_SITE_RIGHT] = false;
000096  eb040244          ADD      r2,r4,r4,LSL #1
00009a  4804              LDR      r0,|L10.172|
00009c  3014              ADDS     r0,r0,#0x14
00009e  4410              ADD      r0,r0,r2
0000a0  7081              STRB     r1,[r0,#2]
                  |L10.162|
;;;440    		}
;;;441    	}
;;;442    }
0000a2  b008              ADD      sp,sp,#0x20
0000a4  bd10              POP      {r4,pc}
;;;443    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L10.168|
                          DCD      ||.constdata||
                  |L10.172|
                          DCD      g_tIR+0x24
                  |L10.176|
                          DCD      0x40000400

                          AREA ||i.bsp_PrintIR_Rev||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  bsp_PrintIR_Rev PROC
;;;58     */
;;;59     void bsp_PrintIR_Rev(void)
000000  b510              PUSH     {r4,lr}
;;;60     {
;;;61     	DEBUG("CH1  %d  %d  %d\r\n",
000002  4814              LDR      r0,|L11.84|
000004  f890302e          LDRB     r3,[r0,#0x2e]
000008  f890202d          LDRB     r2,[r0,#0x2d]
00000c  f890102c          LDRB     r1,[r0,#0x2c]  ; g_tIR
000010  a011              ADR      r0,|L11.88|
000012  f7fffffe          BL       __2printf
;;;62     	g_tIR.isRev[IR_CH1][IR_TX_SITE_LEFT],
;;;63     	g_tIR.isRev[IR_CH1][IR_TX_SITE_CENTER],
;;;64     	g_tIR.isRev[IR_CH1][IR_TX_SITE_RIGHT]);
;;;65     	
;;;66     	DEBUG("CH2  %d  %d  %d\r\n",
000016  480f              LDR      r0,|L11.84|
000018  f8903031          LDRB     r3,[r0,#0x31]
00001c  f8902030          LDRB     r2,[r0,#0x30]
000020  f890102f          LDRB     r1,[r0,#0x2f]
000024  a011              ADR      r0,|L11.108|
000026  f7fffffe          BL       __2printf
;;;67     	g_tIR.isRev[IR_CH2][IR_TX_SITE_LEFT],
;;;68     	g_tIR.isRev[IR_CH2][IR_TX_SITE_CENTER],
;;;69     	g_tIR.isRev[IR_CH2][IR_TX_SITE_RIGHT]);
;;;70     	
;;;71     	DEBUG("CH3  %d  %d  %d\r\n",
00002a  480a              LDR      r0,|L11.84|
00002c  f8903034          LDRB     r3,[r0,#0x34]
000030  f8902033          LDRB     r2,[r0,#0x33]
000034  f8901032          LDRB     r1,[r0,#0x32]
000038  a011              ADR      r0,|L11.128|
00003a  f7fffffe          BL       __2printf
;;;72     	g_tIR.isRev[IR_CH3][IR_TX_SITE_LEFT],
;;;73     	g_tIR.isRev[IR_CH3][IR_TX_SITE_CENTER],
;;;74     	g_tIR.isRev[IR_CH3][IR_TX_SITE_RIGHT]);
;;;75     	
;;;76     	DEBUG("CH4  %d  %d  %d\r\n\r\n",
00003e  4805              LDR      r0,|L11.84|
000040  f8903037          LDRB     r3,[r0,#0x37]
000044  f8902036          LDRB     r2,[r0,#0x36]
000048  f8901035          LDRB     r1,[r0,#0x35]
00004c  a011              ADR      r0,|L11.148|
00004e  f7fffffe          BL       __2printf
;;;77     	g_tIR.isRev[IR_CH4][IR_TX_SITE_LEFT],
;;;78     	g_tIR.isRev[IR_CH4][IR_TX_SITE_CENTER],
;;;79     	g_tIR.isRev[IR_CH4][IR_TX_SITE_RIGHT]);
;;;80     }
000052  bd10              POP      {r4,pc}
;;;81     
                          ENDP

                  |L11.84|
                          DCD      g_tIR
                  |L11.88|
000058  43483120          DCB      "CH1  %d  %d  %d\r\n",0
00005c  20256420
000060  20256420
000064  2025640d
000068  0a00    
00006a  00                DCB      0
00006b  00                DCB      0
                  |L11.108|
00006c  43483220          DCB      "CH2  %d  %d  %d\r\n",0
000070  20256420
000074  20256420
000078  2025640d
00007c  0a00    
00007e  00                DCB      0
00007f  00                DCB      0
                  |L11.128|
000080  43483320          DCB      "CH3  %d  %d  %d\r\n",0
000084  20256420
000088  20256420
00008c  2025640d
000090  0a00    
000092  00                DCB      0
000093  00                DCB      0
                  |L11.148|
000094  43483420          DCB      "CH4  %d  %d  %d\r\n\r\n",0
000098  20256420
00009c  20256420
0000a0  2025640d
0000a4  0a0d0a00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tIR
                          %        140

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x0000000c
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x0000000c

                          AREA ||.data||, DATA, ALIGN=0

                  ||sss||
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_ir_decode.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_ir_decode_c_5d9b690b____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_ir_decode_c_5d9b690b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_ir_decode_c_5d9b690b____REVSH|
#line 128
|__asm___15_bsp_ir_decode_c_5d9b690b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
