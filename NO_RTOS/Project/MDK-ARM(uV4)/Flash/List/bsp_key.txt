; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_key.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_key.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I..\..\..\User\angle\gan_rui_Angle -I..\..\User\angle\yuan_zi_Angle -I..\..\User\dx8\inc -IF:\LuckyXRQ\CleanCar\NO_RTOS\Project\MDK-ARM(uV4)\RTE -ID:\soft\MDK5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\soft\MDK5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_key.crf ..\..\User\bsp\src\bsp_key.c]
                          THUMB

                          AREA ||i.IsKeyDown1||, CODE, READONLY, ALIGN=2

                  IsKeyDown1 PROC
;;;86     #if 1	/* 为了区分3个事件:　K1单独按下, K2单独按下， K1和K2同时按下 */
;;;87     static uint8_t IsKeyDown1(void)
000000  4809              LDR      r0,|L1.40|
;;;88     {
;;;89     	if ((GPIO_PORT_K1->IDR & GPIO_PIN_K1) == 0 && (GPIO_PORT_K2->IDR & GPIO_PIN_K2) != 0
000002  6800              LDR      r0,[r0,#0]
000004  f4006080          AND      r0,r0,#0x400
000008  b958              CBNZ     r0,|L1.34|
00000a  4807              LDR      r0,|L1.40|
00000c  6800              LDR      r0,[r0,#0]
00000e  f4007080          AND      r0,r0,#0x100
000012  b130              CBZ      r0,|L1.34|
;;;90     		&& (GPIO_PORT_K3->IDR & GPIO_PIN_K3) != 0)
000014  4804              LDR      r0,|L1.40|
000016  6800              LDR      r0,[r0,#0]
000018  f0000080          AND      r0,r0,#0x80
00001c  b108              CBZ      r0,|L1.34|
;;;91     		return 1;
00001e  2001              MOVS     r0,#1
                  |L1.32|
;;;92     	else 
;;;93     		return 0;
;;;94     }
000020  4770              BX       lr
                  |L1.34|
000022  2000              MOVS     r0,#0                 ;93
000024  e7fc              B        |L1.32|
;;;95     static uint8_t IsKeyDown2(void)
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x40011808

                          AREA ||i.IsKeyDown10||, CODE, READONLY, ALIGN=2

                  IsKeyDown10 PROC
;;;118    }
;;;119    static uint8_t IsKeyDown10(void)	/* K1 K3组合键 */
000000  4809              LDR      r0,|L2.40|
;;;120    {
;;;121    	if ((GPIO_PORT_K1->IDR & GPIO_PIN_K1) == 0 && (GPIO_PORT_K2->IDR & GPIO_PIN_K2) != 0
000002  6800              LDR      r0,[r0,#0]
000004  f4006080          AND      r0,r0,#0x400
000008  b958              CBNZ     r0,|L2.34|
00000a  4807              LDR      r0,|L2.40|
00000c  6800              LDR      r0,[r0,#0]
00000e  f4007080          AND      r0,r0,#0x100
000012  b130              CBZ      r0,|L2.34|
;;;122    		&& (GPIO_PORT_K3->IDR & GPIO_PIN_K3) == 0)
000014  4804              LDR      r0,|L2.40|
000016  6800              LDR      r0,[r0,#0]
000018  f0000080          AND      r0,r0,#0x80
00001c  b908              CBNZ     r0,|L2.34|
;;;123    		return 1;
00001e  2001              MOVS     r0,#1
                  |L2.32|
;;;124    	else 
;;;125    		return 0;
;;;126    }
000020  4770              BX       lr
                  |L2.34|
000022  2000              MOVS     r0,#0                 ;125
000024  e7fc              B        |L2.32|
;;;127    #else	
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      0x40011808

                          AREA ||i.IsKeyDown2||, CODE, READONLY, ALIGN=2

                  IsKeyDown2 PROC
;;;94     }
;;;95     static uint8_t IsKeyDown2(void)
000000  4809              LDR      r0,|L3.40|
;;;96     {
;;;97     	if ((GPIO_PORT_K1->IDR & GPIO_PIN_K1) != 0 && (GPIO_PORT_K2->IDR & GPIO_PIN_K2) == 0
000002  6800              LDR      r0,[r0,#0]
000004  f4006080          AND      r0,r0,#0x400
000008  b158              CBZ      r0,|L3.34|
00000a  4807              LDR      r0,|L3.40|
00000c  6800              LDR      r0,[r0,#0]
00000e  f4007080          AND      r0,r0,#0x100
000012  b930              CBNZ     r0,|L3.34|
;;;98     		&& (GPIO_PORT_K3->IDR & GPIO_PIN_K3) != 0)
000014  4804              LDR      r0,|L3.40|
000016  6800              LDR      r0,[r0,#0]
000018  f0000080          AND      r0,r0,#0x80
00001c  b108              CBZ      r0,|L3.34|
;;;99     		return 1;
00001e  2001              MOVS     r0,#1
                  |L3.32|
;;;100    	else 
;;;101    		return 0;
;;;102    }
000020  4770              BX       lr
                  |L3.34|
000022  2000              MOVS     r0,#0                 ;101
000024  e7fc              B        |L3.32|
;;;103    static uint8_t IsKeyDown3(void)
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      0x40011808

                          AREA ||i.IsKeyDown3||, CODE, READONLY, ALIGN=2

                  IsKeyDown3 PROC
;;;102    }
;;;103    static uint8_t IsKeyDown3(void)
000000  4809              LDR      r0,|L4.40|
;;;104    {
;;;105    	if ((GPIO_PORT_K1->IDR & GPIO_PIN_K1) != 0 && (GPIO_PORT_K2->IDR & GPIO_PIN_K2) != 0
000002  6800              LDR      r0,[r0,#0]
000004  f4006080          AND      r0,r0,#0x400
000008  b158              CBZ      r0,|L4.34|
00000a  4807              LDR      r0,|L4.40|
00000c  6800              LDR      r0,[r0,#0]
00000e  f4007080          AND      r0,r0,#0x100
000012  b130              CBZ      r0,|L4.34|
;;;106    		&& (GPIO_PORT_K3->IDR & GPIO_PIN_K3) == 0)
000014  4804              LDR      r0,|L4.40|
000016  6800              LDR      r0,[r0,#0]
000018  f0000080          AND      r0,r0,#0x80
00001c  b908              CBNZ     r0,|L4.34|
;;;107    		return 1;
00001e  2001              MOVS     r0,#1
                  |L4.32|
;;;108    	else 
;;;109    		return 0;
;;;110    }
000020  4770              BX       lr
                  |L4.34|
000022  2000              MOVS     r0,#0                 ;109
000024  e7fc              B        |L4.32|
;;;111    static uint8_t IsKeyDown9(void)	/* K1 K2组合键 */
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      0x40011808

                          AREA ||i.IsKeyDown4||, CODE, READONLY, ALIGN=2

                  IsKeyDown4 PROC
;;;136    /* 5方向摇杆 */
;;;137    static uint8_t IsKeyDown4(void) {if ((GPIO_PORT_K4->IDR & GPIO_PIN_K4) == 1) return 1;else return 0;}
000000  4804              LDR      r0,|L5.20|
000002  6800              LDR      r0,[r0,#0]
000004  f0000080          AND      r0,r0,#0x80
000008  2801              CMP      r0,#1
00000a  d100              BNE      |L5.14|
                  |L5.12|
00000c  4770              BX       lr
                  |L5.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L5.12|
;;;138    static uint8_t IsKeyDown5(void) {if ((GPIO_PORT_K5->IDR & GPIO_PIN_K5) == 1) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40011808

                          AREA ||i.IsKeyDown5||, CODE, READONLY, ALIGN=2

                  IsKeyDown5 PROC
;;;137    static uint8_t IsKeyDown4(void) {if ((GPIO_PORT_K4->IDR & GPIO_PIN_K4) == 1) return 1;else return 0;}
;;;138    static uint8_t IsKeyDown5(void) {if ((GPIO_PORT_K5->IDR & GPIO_PIN_K5) == 1) return 1;else return 0;}
000000  4804              LDR      r0,|L6.20|
000002  6800              LDR      r0,[r0,#0]
000004  f0000080          AND      r0,r0,#0x80
000008  2801              CMP      r0,#1
00000a  d100              BNE      |L6.14|
                  |L6.12|
00000c  4770              BX       lr
                  |L6.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L6.12|
;;;139    static uint8_t IsKeyDown6(void) {if ((GPIO_PORT_K6->IDR & GPIO_PIN_K6) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40011808

                          AREA ||i.IsKeyDown6||, CODE, READONLY, ALIGN=2

                  IsKeyDown6 PROC
;;;138    static uint8_t IsKeyDown5(void) {if ((GPIO_PORT_K5->IDR & GPIO_PIN_K5) == 1) return 1;else return 0;}
;;;139    static uint8_t IsKeyDown6(void) {if ((GPIO_PORT_K6->IDR & GPIO_PIN_K6) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L7.20|
000002  6800              LDR      r0,[r0,#0]
000004  f0000080          AND      r0,r0,#0x80
000008  b908              CBNZ     r0,|L7.14|
00000a  2001              MOVS     r0,#1
                  |L7.12|
00000c  4770              BX       lr
                  |L7.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L7.12|
;;;140    static uint8_t IsKeyDown7(void) {if ((GPIO_PORT_K7->IDR & GPIO_PIN_K7) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40011808

                          AREA ||i.IsKeyDown7||, CODE, READONLY, ALIGN=2

                  IsKeyDown7 PROC
;;;139    static uint8_t IsKeyDown6(void) {if ((GPIO_PORT_K6->IDR & GPIO_PIN_K6) == 0) return 1;else return 0;}
;;;140    static uint8_t IsKeyDown7(void) {if ((GPIO_PORT_K7->IDR & GPIO_PIN_K7) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L8.20|
000002  6800              LDR      r0,[r0,#0]
000004  f0000080          AND      r0,r0,#0x80
000008  b908              CBNZ     r0,|L8.14|
00000a  2001              MOVS     r0,#1
                  |L8.12|
00000c  4770              BX       lr
                  |L8.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L8.12|
;;;141    static uint8_t IsKeyDown8(void) {if ((GPIO_PORT_K8->IDR & GPIO_PIN_K8) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40011808

                          AREA ||i.IsKeyDown8||, CODE, READONLY, ALIGN=2

                  IsKeyDown8 PROC
;;;140    static uint8_t IsKeyDown7(void) {if ((GPIO_PORT_K7->IDR & GPIO_PIN_K7) == 0) return 1;else return 0;}
;;;141    static uint8_t IsKeyDown8(void) {if ((GPIO_PORT_K8->IDR & GPIO_PIN_K8) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L9.20|
000002  6800              LDR      r0,[r0,#0]
000004  f0000080          AND      r0,r0,#0x80
000008  b908              CBNZ     r0,|L9.14|
00000a  2001              MOVS     r0,#1
                  |L9.12|
00000c  4770              BX       lr
                  |L9.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L9.12|
;;;142    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40011808

                          AREA ||i.IsKeyDown9||, CODE, READONLY, ALIGN=2

                  IsKeyDown9 PROC
;;;110    }
;;;111    static uint8_t IsKeyDown9(void)	/* K1 K2组合键 */
000000  4809              LDR      r0,|L10.40|
;;;112    {
;;;113    	if ((GPIO_PORT_K1->IDR & GPIO_PIN_K1) == 0 && (GPIO_PORT_K2->IDR & GPIO_PIN_K2) == 0
000002  6800              LDR      r0,[r0,#0]
000004  f4006080          AND      r0,r0,#0x400
000008  b958              CBNZ     r0,|L10.34|
00000a  4807              LDR      r0,|L10.40|
00000c  6800              LDR      r0,[r0,#0]
00000e  f4007080          AND      r0,r0,#0x100
000012  b930              CBNZ     r0,|L10.34|
;;;114    		&& (GPIO_PORT_K3->IDR & GPIO_PIN_K3) != 0)
000014  4804              LDR      r0,|L10.40|
000016  6800              LDR      r0,[r0,#0]
000018  f0000080          AND      r0,r0,#0x80
00001c  b108              CBZ      r0,|L10.34|
;;;115    		return 1;
00001e  2001              MOVS     r0,#1
                  |L10.32|
;;;116    	else 
;;;117    		return 0;
;;;118    }
000020  4770              BX       lr
                  |L10.34|
000022  2000              MOVS     r0,#0                 ;117
000024  e7fc              B        |L10.32|
;;;119    static uint8_t IsKeyDown10(void)	/* K1 K3组合键 */
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      0x40011808

                          AREA ||i.bsp_ClearKey||, CODE, READONLY, ALIGN=2

                  bsp_ClearKey PROC
;;;272    */
;;;273    void bsp_ClearKey(void)
000000  4802              LDR      r0,|L11.12|
;;;274    {
;;;275    	s_tKey.Read = s_tKey.Write;
000002  7ac0              LDRB     r0,[r0,#0xb]  ; s_tKey
000004  4901              LDR      r1,|L11.12|
000006  7288              STRB     r0,[r1,#0xa]
;;;276    }
000008  4770              BX       lr
;;;277    
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      s_tKey

                          AREA ||i.bsp_DetectKey||, CODE, READONLY, ALIGN=2

                  bsp_DetectKey PROC
;;;380    */
;;;381    static void bsp_DetectKey(uint8_t i)
000000  b570              PUSH     {r4-r6,lr}
;;;382    {
000002  4605              MOV      r5,r0
;;;383    	KEY_T *pBtn;
;;;384    
;;;385    	/*
;;;386    		如果没有初始化按键函数，则报错
;;;387    		if (s_tBtn[i].IsKeyDownFunc == 0)
;;;388    		{
;;;389    			printf("Fault : DetectButton(), s_tBtn[i].IsKeyDownFunc undefine");
;;;390    		}
;;;391    	*/
;;;392    
;;;393    	pBtn = &s_tBtn[i];
000004  4830              LDR      r0,|L12.200|
000006  eb001405          ADD      r4,r0,r5,LSL #4
;;;394    	if (pBtn->IsKeyDownFunc())
00000a  6820              LDR      r0,[r4,#0]
00000c  4780              BLX      r0
00000e  2800              CMP      r0,#0
000010  d03e              BEQ      |L12.144|
;;;395    	{
;;;396    		if (pBtn->Count < KEY_FILTER_TIME)
000012  7920              LDRB     r0,[r4,#4]
000014  2806              CMP      r0,#6
000016  da02              BGE      |L12.30|
;;;397    		{
;;;398    			pBtn->Count = KEY_FILTER_TIME;
000018  2006              MOVS     r0,#6
00001a  7120              STRB     r0,[r4,#4]
00001c  e052              B        |L12.196|
                  |L12.30|
;;;399    		}
;;;400    		else if(pBtn->Count < 2 * KEY_FILTER_TIME)
00001e  7920              LDRB     r0,[r4,#4]
000020  280c              CMP      r0,#0xc
000022  da03              BGE      |L12.44|
;;;401    		{
;;;402    			pBtn->Count++;
000024  7920              LDRB     r0,[r4,#4]
000026  1c40              ADDS     r0,r0,#1
000028  7120              STRB     r0,[r4,#4]
00002a  e04b              B        |L12.196|
                  |L12.44|
;;;403    		}
;;;404    		else
;;;405    		{
;;;406    			if (pBtn->State == 0)
00002c  7aa0              LDRB     r0,[r4,#0xa]
00002e  b938              CBNZ     r0,|L12.64|
;;;407    			{
;;;408    				pBtn->State = 1;
000030  2001              MOVS     r0,#1
000032  72a0              STRB     r0,[r4,#0xa]
;;;409    
;;;410    				/* 发送按钮按下的消息 */
;;;411    				bsp_PutKey((uint8_t)(3 * i + 1));
000034  eb050145          ADD      r1,r5,r5,LSL #1
000038  1c49              ADDS     r1,r1,#1
00003a  b2c8              UXTB     r0,r1
00003c  f7fffffe          BL       bsp_PutKey
                  |L12.64|
;;;412    			}
;;;413    
;;;414    			if (pBtn->LongTime > 0)
000040  8920              LDRH     r0,[r4,#8]
000042  2800              CMP      r0,#0
000044  dd3e              BLE      |L12.196|
;;;415    			{
;;;416    				if (pBtn->LongCount < pBtn->LongTime)
000046  88e0              LDRH     r0,[r4,#6]
000048  8921              LDRH     r1,[r4,#8]
00004a  4288              CMP      r0,r1
00004c  da0d              BGE      |L12.106|
;;;417    				{
;;;418    					/* 发送按钮持续按下的消息 */
;;;419    					if (++pBtn->LongCount == pBtn->LongTime)
00004e  88e0              LDRH     r0,[r4,#6]
000050  1c40              ADDS     r0,r0,#1
000052  b280              UXTH     r0,r0
000054  80e0              STRH     r0,[r4,#6]
000056  8921              LDRH     r1,[r4,#8]
000058  4288              CMP      r0,r1
00005a  d133              BNE      |L12.196|
;;;420    					{
;;;421    						/* 键值放入按键FIFO */
;;;422    						bsp_PutKey((uint8_t)(3 * i + 3));
00005c  eb050145          ADD      r1,r5,r5,LSL #1
000060  1cc9              ADDS     r1,r1,#3
000062  b2c8              UXTB     r0,r1
000064  f7fffffe          BL       bsp_PutKey
000068  e02c              B        |L12.196|
                  |L12.106|
;;;423    					}
;;;424    				}
;;;425    				else
;;;426    				{
;;;427    					if (pBtn->RepeatSpeed > 0)
00006a  7ae0              LDRB     r0,[r4,#0xb]
00006c  2800              CMP      r0,#0
00006e  dd29              BLE      |L12.196|
;;;428    					{
;;;429    						if (++pBtn->RepeatCount >= pBtn->RepeatSpeed)
000070  7b20              LDRB     r0,[r4,#0xc]
000072  1c40              ADDS     r0,r0,#1
000074  b2c0              UXTB     r0,r0
000076  7320              STRB     r0,[r4,#0xc]
000078  7ae1              LDRB     r1,[r4,#0xb]
00007a  4288              CMP      r0,r1
00007c  db22              BLT      |L12.196|
;;;430    						{
;;;431    							pBtn->RepeatCount = 0;
00007e  2000              MOVS     r0,#0
000080  7320              STRB     r0,[r4,#0xc]
;;;432    							/* 常按键后，每隔10ms发送1个按键 */
;;;433    							bsp_PutKey((uint8_t)(3 * i + 1));
000082  eb050145          ADD      r1,r5,r5,LSL #1
000086  1c49              ADDS     r1,r1,#1
000088  b2c8              UXTB     r0,r1
00008a  f7fffffe          BL       bsp_PutKey
00008e  e019              B        |L12.196|
                  |L12.144|
;;;434    						}
;;;435    					}
;;;436    				}
;;;437    			}
;;;438    		}
;;;439    	}
;;;440    	else
;;;441    	{
;;;442    		if(pBtn->Count > KEY_FILTER_TIME)
000090  7920              LDRB     r0,[r4,#4]
000092  2806              CMP      r0,#6
000094  dd02              BLE      |L12.156|
;;;443    		{
;;;444    			pBtn->Count = KEY_FILTER_TIME;
000096  2006              MOVS     r0,#6
000098  7120              STRB     r0,[r4,#4]
00009a  e010              B        |L12.190|
                  |L12.156|
;;;445    		}
;;;446    		else if(pBtn->Count != 0)
00009c  7920              LDRB     r0,[r4,#4]
00009e  b118              CBZ      r0,|L12.168|
;;;447    		{
;;;448    			pBtn->Count--;
0000a0  7920              LDRB     r0,[r4,#4]
0000a2  1e40              SUBS     r0,r0,#1
0000a4  7120              STRB     r0,[r4,#4]
0000a6  e00a              B        |L12.190|
                  |L12.168|
;;;449    		}
;;;450    		else
;;;451    		{
;;;452    			if (pBtn->State == 1)
0000a8  7aa0              LDRB     r0,[r4,#0xa]
0000aa  2801              CMP      r0,#1
0000ac  d107              BNE      |L12.190|
;;;453    			{
;;;454    				pBtn->State = 0;
0000ae  2000              MOVS     r0,#0
0000b0  72a0              STRB     r0,[r4,#0xa]
;;;455    
;;;456    				/* 发送按钮弹起的消息 */
;;;457    				bsp_PutKey((uint8_t)(3 * i + 2));
0000b2  eb050145          ADD      r1,r5,r5,LSL #1
0000b6  1c89              ADDS     r1,r1,#2
0000b8  b2c8              UXTB     r0,r1
0000ba  f7fffffe          BL       bsp_PutKey
                  |L12.190|
;;;458    			}
;;;459    		}
;;;460    
;;;461    		pBtn->LongCount = 0;
0000be  2000              MOVS     r0,#0
0000c0  80e0              STRH     r0,[r4,#6]
;;;462    		pBtn->RepeatCount = 0;
0000c2  7320              STRB     r0,[r4,#0xc]
                  |L12.196|
;;;463    	}
;;;464    }
0000c4  bd70              POP      {r4-r6,pc}
;;;465    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L12.200|
                          DCD      s_tBtn

                          AREA ||i.bsp_GetKey||, CODE, READONLY, ALIGN=2

                  bsp_GetKey PROC
;;;185    */
;;;186    uint8_t bsp_GetKey(void)
000000  480b              LDR      r0,|L13.48|
;;;187    {
;;;188    	uint8_t ret;
;;;189    
;;;190    	if (s_tKey.Read == s_tKey.Write)
000002  7a80              LDRB     r0,[r0,#0xa]  ; s_tKey
000004  4a0a              LDR      r2,|L13.48|
000006  7ad2              LDRB     r2,[r2,#0xb]  ; s_tKey
000008  4290              CMP      r0,r2
00000a  d101              BNE      |L13.16|
;;;191    	{
;;;192    		return KEY_NONE;
00000c  2000              MOVS     r0,#0
                  |L13.14|
;;;193    	}
;;;194    	else
;;;195    	{
;;;196    		ret = s_tKey.Buf[s_tKey.Read];
;;;197    
;;;198    		if (++s_tKey.Read >= KEY_FIFO_SIZE)
;;;199    		{
;;;200    			s_tKey.Read = 0;
;;;201    		}
;;;202    		return ret;
;;;203    	}
;;;204    }
00000e  4770              BX       lr
                  |L13.16|
000010  4807              LDR      r0,|L13.48|
000012  7a80              LDRB     r0,[r0,#0xa]          ;196  ; s_tKey
000014  4a06              LDR      r2,|L13.48|
000016  5c11              LDRB     r1,[r2,r0]            ;196
000018  4610              MOV      r0,r2                 ;198
00001a  7a80              LDRB     r0,[r0,#0xa]          ;198  ; s_tKey
00001c  1c40              ADDS     r0,r0,#1              ;198
00001e  b2c0              UXTB     r0,r0                 ;198
000020  7290              STRB     r0,[r2,#0xa]          ;198
000022  280a              CMP      r0,#0xa               ;198
000024  db01              BLT      |L13.42|
000026  2000              MOVS     r0,#0                 ;200
000028  7290              STRB     r0,[r2,#0xa]          ;200
                  |L13.42|
00002a  4608              MOV      r0,r1                 ;202
00002c  e7ef              B        |L13.14|
;;;205    
                          ENDP

00002e  0000              DCW      0x0000
                  |L13.48|
                          DCD      s_tKey

                          AREA ||i.bsp_GetKey2||, CODE, READONLY, ALIGN=2

                  bsp_GetKey2 PROC
;;;213    */
;;;214    uint8_t bsp_GetKey2(void)
000000  480b              LDR      r0,|L14.48|
;;;215    {
;;;216    	uint8_t ret;
;;;217    
;;;218    	if (s_tKey.Read2 == s_tKey.Write)
000002  7b00              LDRB     r0,[r0,#0xc]  ; s_tKey
000004  4a0a              LDR      r2,|L14.48|
000006  7ad2              LDRB     r2,[r2,#0xb]  ; s_tKey
000008  4290              CMP      r0,r2
00000a  d101              BNE      |L14.16|
;;;219    	{
;;;220    		return KEY_NONE;
00000c  2000              MOVS     r0,#0
                  |L14.14|
;;;221    	}
;;;222    	else
;;;223    	{
;;;224    		ret = s_tKey.Buf[s_tKey.Read2];
;;;225    
;;;226    		if (++s_tKey.Read2 >= KEY_FIFO_SIZE)
;;;227    		{
;;;228    			s_tKey.Read2 = 0;
;;;229    		}
;;;230    		return ret;
;;;231    	}
;;;232    }
00000e  4770              BX       lr
                  |L14.16|
000010  4807              LDR      r0,|L14.48|
000012  7b00              LDRB     r0,[r0,#0xc]          ;224  ; s_tKey
000014  4a06              LDR      r2,|L14.48|
000016  5c11              LDRB     r1,[r2,r0]            ;224
000018  4610              MOV      r0,r2                 ;226
00001a  7b00              LDRB     r0,[r0,#0xc]          ;226  ; s_tKey
00001c  1c40              ADDS     r0,r0,#1              ;226
00001e  b2c0              UXTB     r0,r0                 ;226
000020  7310              STRB     r0,[r2,#0xc]          ;226
000022  280a              CMP      r0,#0xa               ;226
000024  db01              BLT      |L14.42|
000026  2000              MOVS     r0,#0                 ;228
000028  7310              STRB     r0,[r2,#0xc]          ;228
                  |L14.42|
00002a  4608              MOV      r0,r1                 ;230
00002c  e7ef              B        |L14.14|
;;;233    
                          ENDP

00002e  0000              DCW      0x0000
                  |L14.48|
                          DCD      s_tKey

                          AREA ||i.bsp_GetKeyState||, CODE, READONLY, ALIGN=2

                  bsp_GetKeyState PROC
;;;241    */
;;;242    uint8_t bsp_GetKeyState(KEY_ID_E _ucKeyID)
000000  4601              MOV      r1,r0
;;;243    {
;;;244    	return s_tBtn[_ucKeyID].State;
000002  4802              LDR      r0,|L15.12|
000004  eb001001          ADD      r0,r0,r1,LSL #4
000008  7a80              LDRB     r0,[r0,#0xa]
;;;245    }
00000a  4770              BX       lr
;;;246    
                          ENDP

                  |L15.12|
                          DCD      s_tBtn

                          AREA ||i.bsp_InitKey||, CODE, READONLY, ALIGN=1

                  bsp_InitKey PROC
;;;153    */
;;;154    void bsp_InitKey(void)
000000  b510              PUSH     {r4,lr}
;;;155    {
;;;156    	bsp_InitKeyVar();		/* 初始化按键变量 */
000002  f7fffffe          BL       bsp_InitKeyVar
;;;157    	bsp_InitKeyHard();		/* 初始化按键硬件 */
000006  f7fffffe          BL       bsp_InitKeyHard
;;;158    }
00000a  bd10              POP      {r4,pc}
;;;159    
                          ENDP


                          AREA ||i.bsp_InitKeyHard||, CODE, READONLY, ALIGN=2

                  bsp_InitKeyHard PROC
;;;285    */
;;;286    static void bsp_InitKeyHard(void)
000000  b508              PUSH     {r3,lr}
;;;287    {
;;;288    	GPIO_InitTypeDef GPIO_InitStructure;
;;;289    
;;;290    	/* 第1步：打开GPIO时钟 */
;;;291    	RCC_APB2PeriphClockCmd(RCC_ALL_KEY, ENABLE);
000002  2101              MOVS     r1,#1
000004  20c4              MOVS     r0,#0xc4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;292    
;;;293    	/* 第2步：配置所有的按键GPIO为浮动输入模式(实际上CPU复位后就是输入状态) */
;;;294    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;295    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;	/* 输入浮空模式 */
000010  2048              MOVS     r0,#0x48
000012  f88d0003          STRB     r0,[sp,#3]
;;;296    	
;;;297    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K1;
000016  f44f6080          MOV      r0,#0x400
00001a  f8ad0000          STRH     r0,[sp,#0]
;;;298    	GPIO_Init(GPIO_PORT_K1, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  481a              LDR      r0,|L17.140|
000022  f7fffffe          BL       GPIO_Init
;;;299    
;;;300    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K2;
000026  f44f7080          MOV      r0,#0x100
00002a  f8ad0000          STRH     r0,[sp,#0]
;;;301    	GPIO_Init(GPIO_PORT_K2, &GPIO_InitStructure);
00002e  4669              MOV      r1,sp
000030  4816              LDR      r0,|L17.140|
000032  f7fffffe          BL       GPIO_Init
;;;302    
;;;303    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K3;
000036  2080              MOVS     r0,#0x80
000038  f8ad0000          STRH     r0,[sp,#0]
;;;304    	GPIO_Init(GPIO_PORT_K3, &GPIO_InitStructure);
00003c  4669              MOV      r1,sp
00003e  4813              LDR      r0,|L17.140|
000040  f7fffffe          BL       GPIO_Init
;;;305    
;;;306    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K4;
000044  2080              MOVS     r0,#0x80
000046  f8ad0000          STRH     r0,[sp,#0]
;;;307    	GPIO_Init(GPIO_PORT_K4, &GPIO_InitStructure);
00004a  4669              MOV      r1,sp
00004c  480f              LDR      r0,|L17.140|
00004e  f7fffffe          BL       GPIO_Init
;;;308    
;;;309    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K5;
000052  2080              MOVS     r0,#0x80
000054  f8ad0000          STRH     r0,[sp,#0]
;;;310    	GPIO_Init(GPIO_PORT_K5, &GPIO_InitStructure);
000058  4669              MOV      r1,sp
00005a  480c              LDR      r0,|L17.140|
00005c  f7fffffe          BL       GPIO_Init
;;;311    
;;;312    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K6;
000060  2080              MOVS     r0,#0x80
000062  f8ad0000          STRH     r0,[sp,#0]
;;;313    	GPIO_Init(GPIO_PORT_K6, &GPIO_InitStructure);
000066  4669              MOV      r1,sp
000068  4808              LDR      r0,|L17.140|
00006a  f7fffffe          BL       GPIO_Init
;;;314    
;;;315    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K7;
00006e  2080              MOVS     r0,#0x80
000070  f8ad0000          STRH     r0,[sp,#0]
;;;316    	GPIO_Init(GPIO_PORT_K7, &GPIO_InitStructure);
000074  4669              MOV      r1,sp
000076  4805              LDR      r0,|L17.140|
000078  f7fffffe          BL       GPIO_Init
;;;317    
;;;318    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K8;
00007c  2080              MOVS     r0,#0x80
00007e  f8ad0000          STRH     r0,[sp,#0]
;;;319    	GPIO_Init(GPIO_PORT_K8, &GPIO_InitStructure);
000082  4669              MOV      r1,sp
000084  4801              LDR      r0,|L17.140|
000086  f7fffffe          BL       GPIO_Init
;;;320    }
00008a  bd08              POP      {r3,pc}
;;;321    
                          ENDP

                  |L17.140|
                          DCD      0x40011800

                          AREA ||i.bsp_InitKeyVar||, CODE, READONLY, ALIGN=2

                  bsp_InitKeyVar PROC
;;;329    */
;;;330    static void bsp_InitKeyVar(void)
000000  2100              MOVS     r1,#0
;;;331    {
;;;332    	uint8_t i;
;;;333    
;;;334    	/* 对按键FIFO读写指针清零 */
;;;335    	s_tKey.Read = 0;
000002  4a1f              LDR      r2,|L18.128|
000004  7291              STRB     r1,[r2,#0xa]
;;;336    	s_tKey.Write = 0;
000006  72d1              STRB     r1,[r2,#0xb]
;;;337    	s_tKey.Read2 = 0;
000008  7311              STRB     r1,[r2,#0xc]
;;;338    
;;;339    	/* 给每个按键结构体成员变量赋一组缺省值 */
;;;340    	for (i = 0; i < KEY_COUNT; i++)
00000a  2000              MOVS     r0,#0
00000c  e018              B        |L18.64|
                  |L18.14|
;;;341    	{
;;;342    		s_tBtn[i].LongTime = KEY_LONG_TIME;			/* 长按时间 0 表示不检测长按键事件 */
00000e  2150              MOVS     r1,#0x50
000010  4a1c              LDR      r2,|L18.132|
000012  eb021200          ADD      r2,r2,r0,LSL #4
000016  8111              STRH     r1,[r2,#8]
;;;343    		s_tBtn[i].Count = KEY_FILTER_TIME / 2;		/* 计数器设置为滤波时间的一半 */
000018  2103              MOVS     r1,#3
00001a  4a1a              LDR      r2,|L18.132|
00001c  eb021200          ADD      r2,r2,r0,LSL #4
000020  7111              STRB     r1,[r2,#4]
;;;344    		s_tBtn[i].State = 0;							/* 按键缺省状态，0为未按下 */
000022  2100              MOVS     r1,#0
000024  4a17              LDR      r2,|L18.132|
000026  eb021200          ADD      r2,r2,r0,LSL #4
00002a  7291              STRB     r1,[r2,#0xa]
;;;345    		//s_tBtn[i].KeyCodeDown = 3 * i + 1;				/* 按键按下的键值代码 */
;;;346    		//s_tBtn[i].KeyCodeUp   = 3 * i + 2;				/* 按键弹起的键值代码 */
;;;347    		//s_tBtn[i].KeyCodeLong = 3 * i + 3;				/* 按键被持续按下的键值代码 */
;;;348    		s_tBtn[i].RepeatSpeed = 0;						/* 按键连发的速度，0表示不支持连发 */
00002c  4a15              LDR      r2,|L18.132|
00002e  eb021200          ADD      r2,r2,r0,LSL #4
000032  72d1              STRB     r1,[r2,#0xb]
;;;349    		s_tBtn[i].RepeatCount = 0;						/* 连发计数器 */
000034  4a13              LDR      r2,|L18.132|
000036  eb021200          ADD      r2,r2,r0,LSL #4
00003a  7311              STRB     r1,[r2,#0xc]
00003c  1c41              ADDS     r1,r0,#1              ;340
00003e  b2c8              UXTB     r0,r1                 ;340
                  |L18.64|
000040  280a              CMP      r0,#0xa               ;340
000042  dbe4              BLT      |L18.14|
;;;350    		
;;;351    	}
;;;352    
;;;353    	/* 如果需要单独更改某个按键的参数，可以在此单独重新赋值 */
;;;354    	/* 比如，我们希望按键1按下超过1秒后，自动重发相同键值 */
;;;355    	s_tBtn[KID_K3].LongTime = KEY_LONG_TIME*3;
000044  22f0              MOVS     r2,#0xf0
000046  490f              LDR      r1,|L18.132|
000048  850a              STRH     r2,[r1,#0x28]
;;;356    	s_tBtn[KID_K3].RepeatSpeed = 0;	/* 每隔x ms自动发送键值（单位10ms） */
00004a  2200              MOVS     r2,#0
00004c  f881202b          STRB     r2,[r1,#0x2b]
;;;357    
;;;358    	/* 判断按键按下的函数 */
;;;359    	s_tBtn[0].IsKeyDownFunc = IsKeyDown1;
000050  490d              LDR      r1,|L18.136|
000052  4a0c              LDR      r2,|L18.132|
000054  6011              STR      r1,[r2,#0]  ; s_tBtn
;;;360    	s_tBtn[1].IsKeyDownFunc = IsKeyDown2;
000056  490d              LDR      r1,|L18.140|
000058  6111              STR      r1,[r2,#0x10]  ; s_tBtn
;;;361    	s_tBtn[2].IsKeyDownFunc = IsKeyDown3;
00005a  490d              LDR      r1,|L18.144|
00005c  6211              STR      r1,[r2,#0x20]  ; s_tBtn
;;;362    	s_tBtn[3].IsKeyDownFunc = IsKeyDown4;
00005e  490d              LDR      r1,|L18.148|
000060  6311              STR      r1,[r2,#0x30]  ; s_tBtn
;;;363    	s_tBtn[4].IsKeyDownFunc = IsKeyDown5;
000062  490d              LDR      r1,|L18.152|
000064  6411              STR      r1,[r2,#0x40]  ; s_tBtn
;;;364    	s_tBtn[5].IsKeyDownFunc = IsKeyDown6;
000066  490d              LDR      r1,|L18.156|
000068  6511              STR      r1,[r2,#0x50]  ; s_tBtn
;;;365    	s_tBtn[6].IsKeyDownFunc = IsKeyDown7;
00006a  490d              LDR      r1,|L18.160|
00006c  6611              STR      r1,[r2,#0x60]  ; s_tBtn
;;;366    	s_tBtn[7].IsKeyDownFunc = IsKeyDown8;
00006e  490d              LDR      r1,|L18.164|
000070  6711              STR      r1,[r2,#0x70]  ; s_tBtn
;;;367    
;;;368    	/* 组合键 */
;;;369    	s_tBtn[8].IsKeyDownFunc = IsKeyDown9;
000072  490d              LDR      r1,|L18.168|
000074  f8c21080          STR      r1,[r2,#0x80]  ; s_tBtn
;;;370    	s_tBtn[9].IsKeyDownFunc = IsKeyDown10;
000078  490c              LDR      r1,|L18.172|
00007a  f8c21090          STR      r1,[r2,#0x90]  ; s_tBtn
;;;371    }
00007e  4770              BX       lr
;;;372    
                          ENDP

                  |L18.128|
                          DCD      s_tKey
                  |L18.132|
                          DCD      s_tBtn
                  |L18.136|
                          DCD      IsKeyDown1
                  |L18.140|
                          DCD      IsKeyDown2
                  |L18.144|
                          DCD      IsKeyDown3
                  |L18.148|
                          DCD      IsKeyDown4
                  |L18.152|
                          DCD      IsKeyDown5
                  |L18.156|
                          DCD      IsKeyDown6
                  |L18.160|
                          DCD      IsKeyDown7
                  |L18.164|
                          DCD      IsKeyDown8
                  |L18.168|
                          DCD      IsKeyDown9
                  |L18.172|
                          DCD      IsKeyDown10

                          AREA ||i.bsp_IsLongPressedAgo||, CODE, READONLY, ALIGN=2

                  bsp_IsLongPressedAgo PROC
;;;491    */
;;;492    bool bsp_IsLongPressedAgo(KEY_SN sn)
000000  4601              MOV      r1,r0
;;;493    {
;;;494    	return isLongPressedAgo[sn];
000002  4801              LDR      r0,|L19.8|
000004  5c40              LDRB     r0,[r0,r1]
;;;495    }
000006  4770              BX       lr
;;;496    
                          ENDP

                  |L19.8|
                          DCD      isLongPressedAgo

                          AREA ||i.bsp_KeyScan||, CODE, READONLY, ALIGN=1

                  bsp_KeyScan PROC
;;;473    */
;;;474    void bsp_KeyScan(void)
000000  b510              PUSH     {r4,lr}
;;;475    {
;;;476    	uint8_t i;
;;;477    
;;;478    	for (i = 0; i < KEY_COUNT; i++)
000002  2400              MOVS     r4,#0
000004  e004              B        |L20.16|
                  |L20.6|
;;;479    	{
;;;480    		bsp_DetectKey(i);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       bsp_DetectKey
00000c  1c60              ADDS     r0,r4,#1              ;478
00000e  b2c4              UXTB     r4,r0                 ;478
                  |L20.16|
000010  2c0a              CMP      r4,#0xa               ;478
000012  dbf8              BLT      |L20.6|
;;;481    	}
;;;482    }
000014  bd10              POP      {r4,pc}
;;;483    
                          ENDP


                          AREA ||i.bsp_PutKey||, CODE, READONLY, ALIGN=2

                  bsp_PutKey PROC
;;;167    */
;;;168    void bsp_PutKey(uint8_t _KeyCode)
000000  4906              LDR      r1,|L21.28|
;;;169    {
;;;170    	s_tKey.Buf[s_tKey.Write] = _KeyCode;
000002  7ac9              LDRB     r1,[r1,#0xb]  ; s_tKey
000004  4a05              LDR      r2,|L21.28|
000006  5450              STRB     r0,[r2,r1]
;;;171    
;;;172    	if (++s_tKey.Write  >= KEY_FIFO_SIZE)
000008  4611              MOV      r1,r2
00000a  7ac9              LDRB     r1,[r1,#0xb]  ; s_tKey
00000c  1c49              ADDS     r1,r1,#1
00000e  b2c9              UXTB     r1,r1
000010  72d1              STRB     r1,[r2,#0xb]
000012  290a              CMP      r1,#0xa
000014  db01              BLT      |L21.26|
;;;173    	{
;;;174    		s_tKey.Write = 0;
000016  2100              MOVS     r1,#0
000018  72d1              STRB     r1,[r2,#0xb]
                  |L21.26|
;;;175    	}
;;;176    }
00001a  4770              BX       lr
;;;177    
                          ENDP

                  |L21.28|
                          DCD      s_tKey

                          AREA ||i.bsp_SetIsLongPressedAgo||, CODE, READONLY, ALIGN=2

                  bsp_SetIsLongPressedAgo PROC
;;;504    */
;;;505    void bsp_SetIsLongPressedAgo(KEY_SN sn , bool state)
000000  4a01              LDR      r2,|L22.8|
;;;506    {
;;;507    	isLongPressedAgo[sn] = state;
000002  5411              STRB     r1,[r2,r0]
;;;508    }
000004  4770              BX       lr
;;;509    
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      isLongPressedAgo

                          AREA ||i.bsp_SetKeyParam||, CODE, READONLY, ALIGN=2

                  bsp_SetKeyParam PROC
;;;256    */
;;;257    void bsp_SetKeyParam(uint8_t _ucKeyID, uint16_t _LongTime, uint8_t  _RepeatSpeed)
000000  b510              PUSH     {r4,lr}
;;;258    {
;;;259    	s_tBtn[_ucKeyID].LongTime = _LongTime;			/* 长按时间 0 表示不检测长按键事件 */
000002  4b07              LDR      r3,|L23.32|
000004  eb031300          ADD      r3,r3,r0,LSL #4
000008  8119              STRH     r1,[r3,#8]
;;;260    	s_tBtn[_ucKeyID].RepeatSpeed = _RepeatSpeed;			/* 按键连发的速度，0表示不支持连发 */
00000a  4b05              LDR      r3,|L23.32|
00000c  eb031300          ADD      r3,r3,r0,LSL #4
000010  72da              STRB     r2,[r3,#0xb]
;;;261    	s_tBtn[_ucKeyID].RepeatCount = 0;						/* 连发计数器 */
000012  2300              MOVS     r3,#0
000014  4c02              LDR      r4,|L23.32|
000016  eb041400          ADD      r4,r4,r0,LSL #4
00001a  7323              STRB     r3,[r4,#0xc]
;;;262    }
00001c  bd10              POP      {r4,pc}
;;;263    
                          ENDP

00001e  0000              DCW      0x0000
                  |L23.32|
                          DCD      s_tBtn

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_tBtn
                          %        160
                  s_tKey
                          %        13

                          AREA ||.data||, DATA, ALIGN=0

                  isLongPressedAgo
000000  000000            DCB      0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_key.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_key_c_dc6aca1d____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_bsp_key_c_dc6aca1d____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_key_c_dc6aca1d____REVSH|
#line 128
|__asm___9_bsp_key_c_dc6aca1d____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
