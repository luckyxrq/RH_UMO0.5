; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_i2c_gpio.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_i2c_gpio.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I..\..\..\User\angle\gan_rui_Angle -I..\..\User\angle\yuan_zi_Angle -IF:\LuckyXRQ\CleanCar\NO_RTOS\Project\MDK-ARM(uV4)\RTE -ID:\soft\MDK5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\soft\MDK5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_i2c_gpio.crf ..\..\User\bsp\src\bsp_i2c_gpio.c]
                          THUMB

                          AREA ||i.bsp_InitI2C||, CODE, READONLY, ALIGN=2

                  bsp_InitI2C PROC
;;;74     */
;;;75     void bsp_InitI2C(void)
000000  b508              PUSH     {r3,lr}
;;;76     {
;;;77     	GPIO_InitTypeDef GPIO_InitStructure;
;;;78     
;;;79     	RCC_APB2PeriphClockCmd(RCC_I2C_PORT, ENABLE);	/* 打开GPIO时钟 */
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;80     
;;;81     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;82     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;	/* 开漏输出模式 */
000010  2014              MOVS     r0,#0x14
000012  f88d0003          STRB     r0,[sp,#3]
;;;83     	
;;;84     	GPIO_InitStructure.GPIO_Pin = PIN_I2C_SCL;
000016  2002              MOVS     r0,#2
000018  f8ad0000          STRH     r0,[sp,#0]
;;;85     	GPIO_Init(PORT_I2C_SCL, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4806              LDR      r0,|L1.56|
000020  f7fffffe          BL       GPIO_Init
;;;86     
;;;87     	GPIO_InitStructure.GPIO_Pin = PIN_I2C_SDA;
000024  2010              MOVS     r0,#0x10
000026  f8ad0000          STRH     r0,[sp,#0]
;;;88     	GPIO_Init(PORT_I2C_SDA, &GPIO_InitStructure);
00002a  4669              MOV      r1,sp
00002c  4802              LDR      r0,|L1.56|
00002e  f7fffffe          BL       GPIO_Init
;;;89     
;;;90     	/* 给一个停止信号, 复位I2C总线上的所有设备到待机模式 */
;;;91     	i2c_Stop();
000032  f7fffffe          BL       i2c_Stop
;;;92     }
000036  bd08              POP      {r3,pc}
;;;93     
                          ENDP

                  |L1.56|
                          DCD      0x40010800

                          AREA ||i.i2c_Ack||, CODE, READONLY, ALIGN=2

                  i2c_Ack PROC
;;;266    */
;;;267    void i2c_Ack(void)
000000  b510              PUSH     {r4,lr}
;;;268    {
;;;269    	I2C_SDA_0();	/* CPU驱动SDA = 0 */
000002  2010              MOVS     r0,#0x10
000004  4909              LDR      r1,|L2.44|
000006  6008              STR      r0,[r1,#0]
;;;270    	i2c_Delay();
000008  f7fffffe          BL       i2c_Delay
;;;271    	I2C_SCL_1();	/* CPU产生1个时钟 */
00000c  2002              MOVS     r0,#2
00000e  4907              LDR      r1,|L2.44|
000010  1f09              SUBS     r1,r1,#4
000012  6008              STR      r0,[r1,#0]
;;;272    	i2c_Delay();
000014  f7fffffe          BL       i2c_Delay
;;;273    	I2C_SCL_0();
000018  2002              MOVS     r0,#2
00001a  4904              LDR      r1,|L2.44|
00001c  6008              STR      r0,[r1,#0]
;;;274    	i2c_Delay();
00001e  f7fffffe          BL       i2c_Delay
;;;275    	I2C_SDA_1();	/* CPU释放SDA总线 */
000022  2010              MOVS     r0,#0x10
000024  4901              LDR      r1,|L2.44|
000026  1f09              SUBS     r1,r1,#4
000028  6008              STR      r0,[r1,#0]
;;;276    }
00002a  bd10              POP      {r4,pc}
;;;277    
                          ENDP

                  |L2.44|
                          DCD      0x40010814

                          AREA ||i.i2c_CheckDevice||, CODE, READONLY, ALIGN=2

                  i2c_CheckDevice PROC
;;;303    */
;;;304    uint8_t i2c_CheckDevice(uint8_t _Address)
000000  b570              PUSH     {r4-r6,lr}
;;;305    {
000002  4604              MOV      r4,r0
;;;306    	uint8_t ucAck;
;;;307    
;;;308    	if (I2C_SDA_READ() && I2C_SCL_READ())
000004  480b              LDR      r0,|L3.52|
000006  6800              LDR      r0,[r0,#0]
000008  f0000010          AND      r0,r0,#0x10
00000c  b180              CBZ      r0,|L3.48|
00000e  4809              LDR      r0,|L3.52|
000010  6800              LDR      r0,[r0,#0]
000012  f0000002          AND      r0,r0,#2
000016  b158              CBZ      r0,|L3.48|
;;;309    	{
;;;310    		i2c_Start();		/* 发送启动信号 */
000018  f7fffffe          BL       i2c_Start
;;;311    
;;;312    		/* 发送设备地址+读写控制bit（0 = w， 1 = r) bit7 先传 */
;;;313    		i2c_SendByte(_Address | I2C_WR);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       i2c_SendByte
;;;314    		ucAck = i2c_WaitAck();	/* 检测设备的ACK应答 */
000022  f7fffffe          BL       i2c_WaitAck
000026  4605              MOV      r5,r0
;;;315    
;;;316    		i2c_Stop();			/* 发送停止信号 */
000028  f7fffffe          BL       i2c_Stop
;;;317    
;;;318    		return ucAck;
00002c  4628              MOV      r0,r5
                  |L3.46|
;;;319    	}
;;;320    	return 1;	/* I2C总线异常 */
;;;321    }
00002e  bd70              POP      {r4-r6,pc}
                  |L3.48|
000030  2001              MOVS     r0,#1                 ;320
000032  e7fc              B        |L3.46|
;;;322    
                          ENDP

                  |L3.52|
                          DCD      0x40010808

                          AREA ||i.i2c_Delay||, CODE, READONLY, ALIGN=1

                  i2c_Delay PROC
;;;101    */
;;;102    static void i2c_Delay(void)
000000  2000              MOVS     r0,#0
;;;103    {
;;;104    	uint8_t i;
;;;105    
;;;106    	/*　
;;;107    		CPU主频168MHz时，在内部Flash运行, MDK工程不优化。用台式示波器观测波形。
;;;108    		循环次数为5时，SCL频率 = 1.78MHz (读耗时: 92ms, 读写正常，但是用示波器探头碰上就读写失败。时序接近临界)
;;;109    		循环次数为10时，SCL频率 = 1.1MHz (读耗时: 138ms, 读速度: 118724B/s)
;;;110    		循环次数为30时，SCL频率 = 440KHz， SCL高电平时间1.0us，SCL低电平时间1.2us
;;;111    
;;;112    		上拉电阻选择2.2K欧时，SCL上升沿时间约0.5us，如果选4.7K欧，则上升沿约1us
;;;113    
;;;114    		实际应用选择400KHz左右的速率即可
;;;115    	*/
;;;116    	
;;;117    	/*　
;;;118    		扫地机使用的103ZET6，经过实测，这里取值4，大致为400KHz
;;;119    	*/
;;;120    	
;;;121    	
;;;122    	for (i = 0; i < 4; i++);
000002  e001              B        |L4.8|
                  |L4.4|
000004  1c41              ADDS     r1,r0,#1
000006  b2c8              UXTB     r0,r1
                  |L4.8|
000008  2804              CMP      r0,#4
00000a  dbfb              BLT      |L4.4|
;;;123    }
00000c  4770              BX       lr
;;;124    
                          ENDP


                          AREA ||i.i2c_NAck||, CODE, READONLY, ALIGN=2

                  i2c_NAck PROC
;;;285    */
;;;286    void i2c_NAck(void)
000000  b510              PUSH     {r4,lr}
;;;287    {
;;;288    	I2C_SDA_1();	/* CPU驱动SDA = 1 */
000002  2010              MOVS     r0,#0x10
000004  4907              LDR      r1,|L5.36|
000006  6008              STR      r0,[r1,#0]
;;;289    	i2c_Delay();
000008  f7fffffe          BL       i2c_Delay
;;;290    	I2C_SCL_1();	/* CPU产生1个时钟 */
00000c  2002              MOVS     r0,#2
00000e  4905              LDR      r1,|L5.36|
000010  6008              STR      r0,[r1,#0]
;;;291    	i2c_Delay();
000012  f7fffffe          BL       i2c_Delay
;;;292    	I2C_SCL_0();
000016  2002              MOVS     r0,#2
000018  4902              LDR      r1,|L5.36|
00001a  1d09              ADDS     r1,r1,#4
00001c  6008              STR      r0,[r1,#0]
;;;293    	i2c_Delay();
00001e  f7fffffe          BL       i2c_Delay
;;;294    }
000022  bd10              POP      {r4,pc}
;;;295    
                          ENDP

                  |L5.36|
                          DCD      0x40010810

                          AREA ||i.i2c_ReadByte||, CODE, READONLY, ALIGN=2

                  i2c_ReadByte PROC
;;;207    */
;;;208    uint8_t i2c_ReadByte(void)
000000  b570              PUSH     {r4-r6,lr}
;;;209    {
;;;210    	uint8_t i;
;;;211    	uint8_t value;
;;;212    
;;;213    	/* 读到第1个bit为数据的bit7 */
;;;214    	value = 0;
000002  2400              MOVS     r4,#0
;;;215    	for (i = 0; i < 8; i++)
000004  2500              MOVS     r5,#0
000006  e016              B        |L6.54|
                  |L6.8|
;;;216    	{
;;;217    		value <<= 1;
000008  0660              LSLS     r0,r4,#25
00000a  0e04              LSRS     r4,r0,#24
;;;218    		I2C_SCL_1();
00000c  2002              MOVS     r0,#2
00000e  490c              LDR      r1,|L6.64|
000010  6008              STR      r0,[r1,#0]
;;;219    		i2c_Delay();
000012  f7fffffe          BL       i2c_Delay
;;;220    		if (I2C_SDA_READ())
000016  480a              LDR      r0,|L6.64|
000018  3808              SUBS     r0,r0,#8
00001a  6800              LDR      r0,[r0,#0]
00001c  f0000010          AND      r0,r0,#0x10
000020  b108              CBZ      r0,|L6.38|
;;;221    		{
;;;222    			value++;
000022  1c60              ADDS     r0,r4,#1
000024  b2c4              UXTB     r4,r0
                  |L6.38|
;;;223    		}
;;;224    		I2C_SCL_0();
000026  2002              MOVS     r0,#2
000028  4905              LDR      r1,|L6.64|
00002a  1d09              ADDS     r1,r1,#4
00002c  6008              STR      r0,[r1,#0]
;;;225    		i2c_Delay();
00002e  f7fffffe          BL       i2c_Delay
000032  1c68              ADDS     r0,r5,#1              ;215
000034  b2c5              UXTB     r5,r0                 ;215
                  |L6.54|
000036  2d08              CMP      r5,#8                 ;215
000038  dbe6              BLT      |L6.8|
;;;226    	}
;;;227    	return value;
00003a  4620              MOV      r0,r4
;;;228    }
00003c  bd70              POP      {r4-r6,pc}
;;;229    
                          ENDP

00003e  0000              DCW      0x0000
                  |L6.64|
                          DCD      0x40010810

                          AREA ||i.i2c_SendByte||, CODE, READONLY, ALIGN=2

                  i2c_SendByte PROC
;;;171    */
;;;172    void i2c_SendByte(uint8_t _ucByte)
000000  b570              PUSH     {r4-r6,lr}
;;;173    {
000002  4604              MOV      r4,r0
;;;174    	uint8_t i;
;;;175    
;;;176    	/* 先发送字节的高位bit7 */
;;;177    	for (i = 0; i < 8; i++)
000004  2500              MOVS     r5,#0
000006  e020              B        |L7.74|
                  |L7.8|
;;;178    	{
;;;179    		if (_ucByte & 0x80)
000008  f0040080          AND      r0,r4,#0x80
00000c  b118              CBZ      r0,|L7.22|
;;;180    		{
;;;181    			I2C_SDA_1();
00000e  2010              MOVS     r0,#0x10
000010  490f              LDR      r1,|L7.80|
000012  6008              STR      r0,[r1,#0]
000014  e003              B        |L7.30|
                  |L7.22|
;;;182    		}
;;;183    		else
;;;184    		{
;;;185    			I2C_SDA_0();
000016  2010              MOVS     r0,#0x10
000018  490d              LDR      r1,|L7.80|
00001a  1d09              ADDS     r1,r1,#4
00001c  6008              STR      r0,[r1,#0]
                  |L7.30|
;;;186    		}
;;;187    		i2c_Delay();
00001e  f7fffffe          BL       i2c_Delay
;;;188    		I2C_SCL_1();
000022  2002              MOVS     r0,#2
000024  490a              LDR      r1,|L7.80|
000026  6008              STR      r0,[r1,#0]
;;;189    		i2c_Delay();
000028  f7fffffe          BL       i2c_Delay
;;;190    		I2C_SCL_0();
00002c  2002              MOVS     r0,#2
00002e  4908              LDR      r1,|L7.80|
000030  1d09              ADDS     r1,r1,#4
000032  6008              STR      r0,[r1,#0]
;;;191    		if (i == 7)
000034  2d07              CMP      r5,#7
000036  d102              BNE      |L7.62|
;;;192    		{
;;;193    			 I2C_SDA_1(); // 释放总线
000038  2010              MOVS     r0,#0x10
00003a  1f09              SUBS     r1,r1,#4
00003c  6008              STR      r0,[r1,#0]
                  |L7.62|
;;;194    		}
;;;195    		_ucByte <<= 1;	/* 左移一个bit */
00003e  0660              LSLS     r0,r4,#25
000040  0e04              LSRS     r4,r0,#24
;;;196    		i2c_Delay();
000042  f7fffffe          BL       i2c_Delay
000046  1c68              ADDS     r0,r5,#1              ;177
000048  b2c5              UXTB     r5,r0                 ;177
                  |L7.74|
00004a  2d08              CMP      r5,#8                 ;177
00004c  dbdc              BLT      |L7.8|
;;;197    	}
;;;198    }
00004e  bd70              POP      {r4-r6,pc}
;;;199    
                          ENDP

                  |L7.80|
                          DCD      0x40010810

                          AREA ||i.i2c_Start||, CODE, READONLY, ALIGN=2

                  i2c_Start PROC
;;;132    */
;;;133    void i2c_Start(void)
000000  b510              PUSH     {r4,lr}
;;;134    {
;;;135    	/* 当SCL高电平时，SDA出现一个下跳沿表示I2C总线启动信号 */
;;;136    	I2C_SDA_1();
000002  2010              MOVS     r0,#0x10
000004  4909              LDR      r1,|L8.44|
000006  6008              STR      r0,[r1,#0]
;;;137    	I2C_SCL_1();
000008  2002              MOVS     r0,#2
00000a  6008              STR      r0,[r1,#0]
;;;138    	i2c_Delay();
00000c  f7fffffe          BL       i2c_Delay
;;;139    	I2C_SDA_0();
000010  2010              MOVS     r0,#0x10
000012  4906              LDR      r1,|L8.44|
000014  1d09              ADDS     r1,r1,#4
000016  6008              STR      r0,[r1,#0]
;;;140    	i2c_Delay();
000018  f7fffffe          BL       i2c_Delay
;;;141    	
;;;142    	I2C_SCL_0();
00001c  2002              MOVS     r0,#2
00001e  4903              LDR      r1,|L8.44|
000020  1d09              ADDS     r1,r1,#4
000022  6008              STR      r0,[r1,#0]
;;;143    	i2c_Delay();
000024  f7fffffe          BL       i2c_Delay
;;;144    }
000028  bd10              POP      {r4,pc}
;;;145    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0x40010810

                          AREA ||i.i2c_Stop||, CODE, READONLY, ALIGN=2

                  i2c_Stop PROC
;;;153    */
;;;154    void i2c_Stop(void)
000000  b510              PUSH     {r4,lr}
;;;155    {
;;;156    	/* 当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号 */
;;;157    	I2C_SDA_0();
000002  2010              MOVS     r0,#0x10
000004  4906              LDR      r1,|L9.32|
000006  6008              STR      r0,[r1,#0]
;;;158    	I2C_SCL_1();
000008  2002              MOVS     r0,#2
00000a  1f09              SUBS     r1,r1,#4
00000c  6008              STR      r0,[r1,#0]
;;;159    	i2c_Delay();
00000e  f7fffffe          BL       i2c_Delay
;;;160    	I2C_SDA_1();
000012  2010              MOVS     r0,#0x10
000014  4902              LDR      r1,|L9.32|
000016  1f09              SUBS     r1,r1,#4
000018  6008              STR      r0,[r1,#0]
;;;161    	i2c_Delay();
00001a  f7fffffe          BL       i2c_Delay
;;;162    }
00001e  bd10              POP      {r4,pc}
;;;163    
                          ENDP

                  |L9.32|
                          DCD      0x40010814

                          AREA ||i.i2c_WaitAck||, CODE, READONLY, ALIGN=2

                  i2c_WaitAck PROC
;;;237    */
;;;238    uint8_t i2c_WaitAck(void)
000000  b510              PUSH     {r4,lr}
;;;239    {
;;;240    	uint8_t re;
;;;241    
;;;242    	I2C_SDA_1();	/* CPU释放SDA总线 */
000002  2010              MOVS     r0,#0x10
000004  490c              LDR      r1,|L10.56|
000006  6008              STR      r0,[r1,#0]
;;;243    	i2c_Delay();
000008  f7fffffe          BL       i2c_Delay
;;;244    	I2C_SCL_1();	/* CPU驱动SCL = 1, 此时器件会返回ACK应答 */
00000c  2002              MOVS     r0,#2
00000e  490a              LDR      r1,|L10.56|
000010  6008              STR      r0,[r1,#0]
;;;245    	i2c_Delay();
000012  f7fffffe          BL       i2c_Delay
;;;246    	if (I2C_SDA_READ())	/* CPU读取SDA口线状态 */
000016  4808              LDR      r0,|L10.56|
000018  3808              SUBS     r0,r0,#8
00001a  6800              LDR      r0,[r0,#0]
00001c  f0000010          AND      r0,r0,#0x10
000020  b108              CBZ      r0,|L10.38|
;;;247    	{
;;;248    		re = 1;
000022  2401              MOVS     r4,#1
000024  e000              B        |L10.40|
                  |L10.38|
;;;249    	}
;;;250    	else
;;;251    	{
;;;252    		re = 0;
000026  2400              MOVS     r4,#0
                  |L10.40|
;;;253    	}
;;;254    	I2C_SCL_0();
000028  2002              MOVS     r0,#2
00002a  4903              LDR      r1,|L10.56|
00002c  1d09              ADDS     r1,r1,#4
00002e  6008              STR      r0,[r1,#0]
;;;255    	i2c_Delay();
000030  f7fffffe          BL       i2c_Delay
;;;256    	return re;
000034  4620              MOV      r0,r4
;;;257    }
000036  bd10              POP      {r4,pc}
;;;258    
                          ENDP

                  |L10.56|
                          DCD      0x40010810

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_i2c_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_bsp_i2c_gpio_c_ec180c52____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_bsp_i2c_gpio_c_ec180c52____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_bsp_i2c_gpio_c_ec180c52____REVSH|
#line 128
|__asm___14_bsp_i2c_gpio_c_ec180c52____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
