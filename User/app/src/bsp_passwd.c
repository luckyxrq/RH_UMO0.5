#include "bsp.h"

/**************************************************************

	!!! 添加秘钥需要修改的地方，注释有 “待修改”，搜索 “待修改”

***************************************************************/


/*秘钥总个数 ， 如果添加了新秘钥这里需要修改+N，待修改*/
#define DX8_ARR_CNT  4


typedef struct
{
    unsigned char ppppp[20];
    unsigned char kkkkk[20];
}DX8_ARR;


/*秘钥合集 新生成的秘钥 复制到这里，待修改*/

#define A1_PPPPP   0xea,0x0a,0x3c,0x87,0x99,0x8c,0x43,0xaa
#define A1_KKKKK   0xe2,0xe1,0x31,0x8a,0xf1,0x34,0x08,0xef,0x7e,0x73,0x70,0xd6,0x97,0x5b,0xe1,0x85 
#define A1_ZZZZZ0  0xe3,0x27,0xc2,0x74,0xe1,0x48,0x4a,0xb0,0x13,0xc7,0x34,0xd0,0x4a,0x44,0x32,0xd7 
#define A1_ZZZZZ1  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 
#define A1_ZZZZZ2  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 
#define A1_ZZZZZ3  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 


#define A2_PPPPP   0x46,0x28,0x5c,0xc6,0xef,0x4f,0x93,0xa8 
#define A2_KKKKK   0x41,0xd6,0x01,0xf0,0x2b,0x98,0xbd,0xfc,0x87,0xaa,0x44,0x8a,0xb3,0xac,0x88,0x6d 
#define A2_ZZZZZ0  0x1d,0xcd,0x6d,0xbc,0xab,0x34,0xe2,0xc3,0x61,0x44,0xba,0x1b,0xf0,0x7d,0xa6,0x1e 
#define A2_ZZZZZ1  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 
#define A2_ZZZZZ2  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 
#define A2_ZZZZZ3  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 



#define A3_PPPPP   0xdd,0xd9,0x66,0x43,0x3e,0x72,0xf8,0x08 
#define A3_KKKKK   0xdc,0xdf,0x3e,0x51,0x35,0x0b,0x6e,0x0d,0xa4,0x24,0xfc,0xbf,0x4c,0x7f,0xe8,0xce 
#define A3_ZZZZZ0  0xca,0x0b,0xa7,0x63,0x66,0x38,0x30,0xcd,0x00,0xf0,0xd1,0x34,0xdd,0x3d,0xdb,0x48 
#define A3_ZZZZZ1  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 
#define A3_ZZZZZ2  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 
#define A3_ZZZZZ3  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 



#define A4_PPPPP   0xc4,0xbd,0xa6,0x06,0x6d,0x1d,0xbb,0xb8 
#define A4_KKKKK   0xd4,0xad,0x96,0xa4,0xdb,0x34,0xac,0x32,0xb1,0xf5,0x81,0xd1,0xd8,0x16,0x0f,0x10 
#define A4_ZZZZZ0  0xe8,0xa6,0xd7,0xb9,0x0a,0xa0,0xe6,0x1e,0xf7,0xb5,0xcb,0x7c,0x81,0xea,0x85,0xd8 
#define A4_ZZZZZ1  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 
#define A4_ZZZZZ2  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 
#define A4_ZZZZZ3  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 



/*待修改*/
static DX8_ARR dx8_arr[DX8_ARR_CNT] = 
{
    {A1_PPPPP,A1_KKKKK},
    {A2_PPPPP,A2_KKKKK},
    {A3_PPPPP,A3_KKKKK},
    {A4_PPPPP,A4_KKKKK},
}; 


//------------------------------------------------------------------------------
//  Host CPU Random Number Generation
//------------------------------------------------------------------------------
void GetSoftRandom(unsigned char *random, unsigned short len)
{
    unsigned short i;
    // Strongly recommended the seed involved by system time !!!!!
    //srand((unsigned int)time(NULL) + srand_cnt++); 
    srand(srand_cnt++); 
    for (i=0; i<len; i++) random[i] = rand() % 256;
}


#define LED_ARR_SZIE  6

static LED_SN ledArr[LED_ARR_SZIE] = {LED_LOGO_CLEAN,LED_LOGO_POWER,LED_LOGO_CHARGE,LED_COLOR_YELLOW,LED_COLOR_GREEN,LED_COLOR_RED};

void bsp_PwdFailShow(void)
{
    static uint8_t toggleIndex = 0 ;
    
    bsp_LedToggle(ledArr[toggleIndex % LED_ARR_SZIE]);
    
    if(++toggleIndex >= LED_ARR_SZIE)
    {
        toggleIndex = 0;
    }
}

/*
*********************************************************************************************************
*	函 数 名: bsp_ChkSinglePwd
*	功能说明: 指定PPPP KKKK，校验
*	形    参：无
*	返 回 值: 失败1 ， 成功0 
*********************************************************************************************************
*/
unsigned char bsp_ChkSinglePwd(unsigned char pppp[] , unsigned char kkkk[])
{
    unsigned char rv;
    unsigned char random[32];
    unsigned char tmpBuf1[20] ;
    unsigned char tmpBuf2[20] ;
    
    /*拷贝传进来的秘钥*/
    memcpy(tmpBuf1,pppp,20);
    memcpy(tmpBuf2,kkkk,20);
    
    
    // Wakeup and Reset DX8
    rv = DX8_Reset();
    if (rv) return rv;
    
    // PIN Authentication
    GetSoftRandom(random,32); // Generate random for verify PIN
    rv = DX8_VerifyPin(random,tmpBuf1);
    if (rv) return rv;
    
    // Host Authentication
    memset(tmpBuf1,0x00,20);
    GetSoftRandom(random,32);
    rv = DX8_HostAuth(random,32,tmpBuf1);
    if (rv) return rv;
    Lib_HostAuth(random,32,tmpBuf2,tmpBuf2);
    rv = memcmp(tmpBuf1,tmpBuf2,20);
    if (rv) return rv;
    
    // DX8 Sleep to save power
    rv = DX8_Sleep(); 
    if (rv) return rv;
    
    return 0;
}


/*
*********************************************************************************************************
*	函 数 名: bsp_ChkAllPwd
*	功能说明: 校验所有的秘钥，有一个通过，则全部通过
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
bool bsp_ChkAllPwd(void)
{
    uint32_t i = 0 ;
	
	
	for(i=0;i<DX8_ARR_CNT;++i)
	{
		if(bsp_ChkSinglePwd(dx8_arr[i].kkkkk , dx8_arr[i].ppppp) == 0) /*返回0 表示校验通过了*/
		{
			return true;
		}
	}
	
	/*前面的秘钥全部未能校验通过，失败*/
	return false;
}


/*
*********************************************************************************************************
*	函 数 名: bsp_DX8_CMD
*	功能说明: 唯一对外开放接口，不通过则显示不通过的灯光效果
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
bool bsp_DX8_CMD(void)
{
    char *dx8Version;
    bool rv;
    
    UNUSED(dx8Version);
    
    dx8_Init();
    /*获取加密版本信息*/
    dx8Version = DX8_Version();
    DEBUG("加密版本：%s\r\n",dx8Version);
    
    // Authention Test
    rv = bsp_ChkAllPwd();
    if(!rv)
    {
        
        while(1)
        {
            bsp_PwdFailShow();
            
            
            RTT("FAIL\r\n");
            bsp_DelayMS(100);
        };
    }
    else
    {
        RTT("SUCCESS\r\n");
    }
    
    return rv;
}
