; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_currentfeedback.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_currentfeedback.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\app\inc -IF:\LuckyXRQ\CleanCar\Project\MDK-ARM(uV4)\RTE -ID:\soft\MDK5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\soft\MDK5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_currentfeedback.crf ..\..\User\app\src\bsp_CurrentFeedback.c]
                          THUMB

                          AREA ||i.bsp_InitCurrentFeedbackADC||, CODE, READONLY, ALIGN=2

                  bsp_InitCurrentFeedbackADC PROC
;;;10     */
;;;11     void bsp_InitCurrentFeedbackADC(void)
000000  b500              PUSH     {lr}
;;;12     {
000002  b087              SUB      sp,sp,#0x1c
;;;13     	ADC_InitTypeDef ADC_InitStructure; 
;;;14     	GPIO_InitTypeDef GPIO_InitStructure;
;;;15     
;;;16     	/*左轮机*/
;;;17     	{
;;;18     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB |RCC_APB2Periph_ADC2, ENABLE );
000004  2101              MOVS     r1,#1
000006  f44f6081          MOV      r0,#0x408
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;19      
;;;20     		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;21     		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
00000e  f44f4000          MOV      r0,#0x8000
000012  f7fffffe          BL       RCC_ADCCLKConfig
;;;22                       
;;;23     		/*配置引脚为模拟输入模式*/
;;;24     		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
000016  2002              MOVS     r0,#2
000018  f8ad0004          STRH     r0,[sp,#4]
;;;25     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00001c  2000              MOVS     r0,#0
00001e  f88d0007          STRB     r0,[sp,#7]
;;;26     		GPIO_Init(GPIOB, &GPIO_InitStructure);	
000022  a901              ADD      r1,sp,#4
000024  48e7              LDR      r0,|L1.964|
000026  f7fffffe          BL       GPIO_Init
;;;27     
;;;28     		/*复位ADC*/
;;;29     		ADC_DeInit(ADC2);
00002a  48e7              LDR      r0,|L1.968|
00002c  f7fffffe          BL       ADC_DeInit
;;;30     
;;;31     		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000030  2000              MOVS     r0,#0
000032  9002              STR      r0,[sp,#8]
;;;32     		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
000034  f88d000c          STRB     r0,[sp,#0xc]
;;;33     		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
000038  f88d000d          STRB     r0,[sp,#0xd]
;;;34     		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
00003c  f44f2060          MOV      r0,#0xe0000
000040  9004              STR      r0,[sp,#0x10]
;;;35     		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000042  2000              MOVS     r0,#0
000044  9005              STR      r0,[sp,#0x14]
;;;36     		ADC_InitStructure.ADC_NbrOfChannel = 1;
000046  2001              MOVS     r0,#1
000048  f88d0018          STRB     r0,[sp,#0x18]
;;;37     		ADC_Init(ADC2, &ADC_InitStructure);  
00004c  a902              ADD      r1,sp,#8
00004e  48de              LDR      r0,|L1.968|
000050  f7fffffe          BL       ADC_Init
;;;38     
;;;39     		/*使能指定的ADC*/
;;;40     		ADC_Cmd(ADC2, ENABLE);
000054  2101              MOVS     r1,#1
000056  48dc              LDR      r0,|L1.968|
000058  f7fffffe          BL       ADC_Cmd
;;;41     		
;;;42     		/*使能复位校准 */
;;;43     		ADC_ResetCalibration(ADC2);
00005c  48da              LDR      r0,|L1.968|
00005e  f7fffffe          BL       ADC_ResetCalibration
;;;44     		 
;;;45     		/*等待复位校准结束*/
;;;46     		while(ADC_GetResetCalibrationStatus(ADC2));
000062  bf00              NOP      
                  |L1.100|
000064  48d8              LDR      r0,|L1.968|
000066  f7fffffe          BL       ADC_GetResetCalibrationStatus
00006a  2800              CMP      r0,#0
00006c  d1fa              BNE      |L1.100|
;;;47     		
;;;48     		/*开启AD校准*/
;;;49     		ADC_StartCalibration(ADC2);
00006e  48d6              LDR      r0,|L1.968|
000070  f7fffffe          BL       ADC_StartCalibration
;;;50     	 
;;;51     		/*等待校准结束*/
;;;52     		while(ADC_GetCalibrationStatus(ADC2));
000074  bf00              NOP      
                  |L1.118|
000076  48d4              LDR      r0,|L1.968|
000078  f7fffffe          BL       ADC_GetCalibrationStatus
00007c  2800              CMP      r0,#0
00007e  d1fa              BNE      |L1.118|
;;;53     		
;;;54     		/*ADC,ADC通道,采样时间为239.5周期*/
;;;55     		ADC_RegularChannelConfig(ADC2, ADC_Channel_9, 1, ADC_SampleTime_239Cycles5 );
000080  2307              MOVS     r3,#7
000082  2201              MOVS     r2,#1
000084  2109              MOVS     r1,#9
000086  48d0              LDR      r0,|L1.968|
000088  f7fffffe          BL       ADC_RegularChannelConfig
;;;56     	}
;;;57     	
;;;58     	/*右轮机*/
;;;59     	{
;;;60     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF |RCC_APB2Periph_ADC3, ENABLE );
00008c  2101              MOVS     r1,#1
00008e  f2480080          MOV      r0,#0x8080
000092  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;61      
;;;62     		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;63     		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
000096  f44f4000          MOV      r0,#0x8000
00009a  f7fffffe          BL       RCC_ADCCLKConfig
;;;64                       
;;;65     		/*配置引脚为模拟输入模式*/
;;;66     		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
00009e  f44f6080          MOV      r0,#0x400
0000a2  f8ad0004          STRH     r0,[sp,#4]
;;;67     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
0000a6  2000              MOVS     r0,#0
0000a8  f88d0007          STRB     r0,[sp,#7]
;;;68     		GPIO_Init(GPIOF, &GPIO_InitStructure);	
0000ac  a901              ADD      r1,sp,#4
0000ae  48c7              LDR      r0,|L1.972|
0000b0  f7fffffe          BL       GPIO_Init
;;;69     
;;;70     		/*复位ADC*/
;;;71     		ADC_DeInit(ADC3);
0000b4  48c6              LDR      r0,|L1.976|
0000b6  f7fffffe          BL       ADC_DeInit
;;;72     
;;;73     		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
0000ba  2000              MOVS     r0,#0
0000bc  9002              STR      r0,[sp,#8]
;;;74     		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
0000be  f88d000c          STRB     r0,[sp,#0xc]
;;;75     		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
0000c2  f88d000d          STRB     r0,[sp,#0xd]
;;;76     		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
0000c6  f44f2060          MOV      r0,#0xe0000
0000ca  9004              STR      r0,[sp,#0x10]
;;;77     		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
0000cc  2000              MOVS     r0,#0
0000ce  9005              STR      r0,[sp,#0x14]
;;;78     		ADC_InitStructure.ADC_NbrOfChannel = 1;
0000d0  2001              MOVS     r0,#1
0000d2  f88d0018          STRB     r0,[sp,#0x18]
;;;79     		ADC_Init(ADC3, &ADC_InitStructure);  
0000d6  a902              ADD      r1,sp,#8
0000d8  48bd              LDR      r0,|L1.976|
0000da  f7fffffe          BL       ADC_Init
;;;80     
;;;81     		/*使能指定的ADC*/
;;;82     		ADC_Cmd(ADC3, ENABLE);
0000de  2101              MOVS     r1,#1
0000e0  48bb              LDR      r0,|L1.976|
0000e2  f7fffffe          BL       ADC_Cmd
;;;83     		
;;;84     		/*使能复位校准 */
;;;85     		ADC_ResetCalibration(ADC3);
0000e6  48ba              LDR      r0,|L1.976|
0000e8  f7fffffe          BL       ADC_ResetCalibration
;;;86     		 
;;;87     		/*等待复位校准结束*/
;;;88     		while(ADC_GetResetCalibrationStatus(ADC3));
0000ec  bf00              NOP      
                  |L1.238|
0000ee  48b8              LDR      r0,|L1.976|
0000f0  f7fffffe          BL       ADC_GetResetCalibrationStatus
0000f4  2800              CMP      r0,#0
0000f6  d1fa              BNE      |L1.238|
;;;89     		
;;;90     		/*开启AD校准*/
;;;91     		ADC_StartCalibration(ADC3);
0000f8  48b5              LDR      r0,|L1.976|
0000fa  f7fffffe          BL       ADC_StartCalibration
;;;92     	 
;;;93     		/*等待校准结束*/
;;;94     		while(ADC_GetCalibrationStatus(ADC3));
0000fe  bf00              NOP      
                  |L1.256|
000100  48b3              LDR      r0,|L1.976|
000102  f7fffffe          BL       ADC_GetCalibrationStatus
000106  2800              CMP      r0,#0
000108  d1fa              BNE      |L1.256|
;;;95     		
;;;96     		/*ADC,ADC通道,采样时间为239.5周期*/
;;;97     		ADC_RegularChannelConfig(ADC3, ADC_Channel_8, 1, ADC_SampleTime_239Cycles5 );
00010a  2307              MOVS     r3,#7
00010c  2201              MOVS     r2,#1
00010e  2108              MOVS     r1,#8
000110  48af              LDR      r0,|L1.976|
000112  f7fffffe          BL       ADC_RegularChannelConfig
;;;98     	}	
;;;99     	
;;;100    	
;;;101    	/*吸尘*/
;;;102    	{
;;;103    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC |RCC_APB2Periph_ADC2, ENABLE );
000116  2101              MOVS     r1,#1
000118  f44f6082          MOV      r0,#0x410
00011c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;104     
;;;105    		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;106    		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
000120  f44f4000          MOV      r0,#0x8000
000124  f7fffffe          BL       RCC_ADCCLKConfig
;;;107                      
;;;108    		/*配置引脚为模拟输入模式*/
;;;109    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000128  2004              MOVS     r0,#4
00012a  f8ad0004          STRH     r0,[sp,#4]
;;;110    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00012e  2000              MOVS     r0,#0
000130  f88d0007          STRB     r0,[sp,#7]
;;;111    		GPIO_Init(GPIOC, &GPIO_InitStructure);	
000134  a901              ADD      r1,sp,#4
000136  48a7              LDR      r0,|L1.980|
000138  f7fffffe          BL       GPIO_Init
;;;112    
;;;113    		/*复位ADC*/
;;;114    		ADC_DeInit(ADC2);
00013c  48a2              LDR      r0,|L1.968|
00013e  f7fffffe          BL       ADC_DeInit
;;;115    
;;;116    		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000142  2000              MOVS     r0,#0
000144  9002              STR      r0,[sp,#8]
;;;117    		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
000146  f88d000c          STRB     r0,[sp,#0xc]
;;;118    		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
00014a  f88d000d          STRB     r0,[sp,#0xd]
;;;119    		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
00014e  f44f2060          MOV      r0,#0xe0000
000152  9004              STR      r0,[sp,#0x10]
;;;120    		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000154  2000              MOVS     r0,#0
000156  9005              STR      r0,[sp,#0x14]
;;;121    		ADC_InitStructure.ADC_NbrOfChannel = 1;
000158  2001              MOVS     r0,#1
00015a  f88d0018          STRB     r0,[sp,#0x18]
;;;122    		ADC_Init(ADC2, &ADC_InitStructure);  
00015e  a902              ADD      r1,sp,#8
000160  4899              LDR      r0,|L1.968|
000162  f7fffffe          BL       ADC_Init
;;;123    
;;;124    		/*使能指定的ADC*/
;;;125    		ADC_Cmd(ADC2, ENABLE);
000166  2101              MOVS     r1,#1
000168  4897              LDR      r0,|L1.968|
00016a  f7fffffe          BL       ADC_Cmd
;;;126    		
;;;127    		/*使能复位校准 */
;;;128    		ADC_ResetCalibration(ADC2);
00016e  4896              LDR      r0,|L1.968|
000170  f7fffffe          BL       ADC_ResetCalibration
;;;129    		 
;;;130    		/*等待复位校准结束*/
;;;131    		while(ADC_GetResetCalibrationStatus(ADC2));
000174  bf00              NOP      
                  |L1.374|
000176  4894              LDR      r0,|L1.968|
000178  f7fffffe          BL       ADC_GetResetCalibrationStatus
00017c  2800              CMP      r0,#0
00017e  d1fa              BNE      |L1.374|
;;;132    		
;;;133    		/*开启AD校准*/
;;;134    		ADC_StartCalibration(ADC2);
000180  4891              LDR      r0,|L1.968|
000182  f7fffffe          BL       ADC_StartCalibration
;;;135    	 
;;;136    		/*等待校准结束*/
;;;137    		while(ADC_GetCalibrationStatus(ADC2));
000186  bf00              NOP      
                  |L1.392|
000188  488f              LDR      r0,|L1.968|
00018a  f7fffffe          BL       ADC_GetCalibrationStatus
00018e  2800              CMP      r0,#0
000190  d1fa              BNE      |L1.392|
;;;138    		
;;;139    		/*ADC,ADC通道,采样时间为239.5周期*/
;;;140    		ADC_RegularChannelConfig(ADC2, ADC_Channel_12, 1, ADC_SampleTime_239Cycles5 );
000192  2307              MOVS     r3,#7
000194  2201              MOVS     r2,#1
000196  210c              MOVS     r1,#0xc
000198  488b              LDR      r0,|L1.968|
00019a  f7fffffe          BL       ADC_RegularChannelConfig
;;;141    	}
;;;142    	
;;;143    	/*滚刷*/
;;;144    	{
;;;145    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC |RCC_APB2Periph_ADC2, ENABLE );
00019e  2101              MOVS     r1,#1
0001a0  f44f6082          MOV      r0,#0x410
0001a4  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;146     
;;;147    		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;148    		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
0001a8  f44f4000          MOV      r0,#0x8000
0001ac  f7fffffe          BL       RCC_ADCCLKConfig
;;;149                      
;;;150    		/*配置引脚为模拟输入模式*/
;;;151    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
0001b0  2001              MOVS     r0,#1
0001b2  f8ad0004          STRH     r0,[sp,#4]
;;;152    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
0001b6  2000              MOVS     r0,#0
0001b8  f88d0007          STRB     r0,[sp,#7]
;;;153    		GPIO_Init(GPIOC, &GPIO_InitStructure);	
0001bc  a901              ADD      r1,sp,#4
0001be  4885              LDR      r0,|L1.980|
0001c0  f7fffffe          BL       GPIO_Init
;;;154    
;;;155    		/*复位ADC*/
;;;156    		ADC_DeInit(ADC2);
0001c4  4880              LDR      r0,|L1.968|
0001c6  f7fffffe          BL       ADC_DeInit
;;;157    
;;;158    		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
0001ca  2000              MOVS     r0,#0
0001cc  9002              STR      r0,[sp,#8]
;;;159    		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
0001ce  f88d000c          STRB     r0,[sp,#0xc]
;;;160    		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
0001d2  f88d000d          STRB     r0,[sp,#0xd]
;;;161    		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
0001d6  f44f2060          MOV      r0,#0xe0000
0001da  9004              STR      r0,[sp,#0x10]
;;;162    		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
0001dc  2000              MOVS     r0,#0
0001de  9005              STR      r0,[sp,#0x14]
;;;163    		ADC_InitStructure.ADC_NbrOfChannel = 1;
0001e0  2001              MOVS     r0,#1
0001e2  f88d0018          STRB     r0,[sp,#0x18]
;;;164    		ADC_Init(ADC2, &ADC_InitStructure);  
0001e6  a902              ADD      r1,sp,#8
0001e8  4877              LDR      r0,|L1.968|
0001ea  f7fffffe          BL       ADC_Init
;;;165    
;;;166    		/*使能指定的ADC*/
;;;167    		ADC_Cmd(ADC2, ENABLE);
0001ee  2101              MOVS     r1,#1
0001f0  4875              LDR      r0,|L1.968|
0001f2  f7fffffe          BL       ADC_Cmd
;;;168    		
;;;169    		/*使能复位校准 */
;;;170    		ADC_ResetCalibration(ADC2);
0001f6  4874              LDR      r0,|L1.968|
0001f8  f7fffffe          BL       ADC_ResetCalibration
;;;171    		 
;;;172    		/*等待复位校准结束*/
;;;173    		while(ADC_GetResetCalibrationStatus(ADC2));
0001fc  bf00              NOP      
                  |L1.510|
0001fe  4872              LDR      r0,|L1.968|
000200  f7fffffe          BL       ADC_GetResetCalibrationStatus
000204  2800              CMP      r0,#0
000206  d1fa              BNE      |L1.510|
;;;174    		
;;;175    		/*开启AD校准*/
;;;176    		ADC_StartCalibration(ADC2);
000208  486f              LDR      r0,|L1.968|
00020a  f7fffffe          BL       ADC_StartCalibration
;;;177    	 
;;;178    		/*等待校准结束*/
;;;179    		while(ADC_GetCalibrationStatus(ADC2));
00020e  bf00              NOP      
                  |L1.528|
000210  486d              LDR      r0,|L1.968|
000212  f7fffffe          BL       ADC_GetCalibrationStatus
000216  2800              CMP      r0,#0
000218  d1fa              BNE      |L1.528|
;;;180    		
;;;181    		/*ADC,ADC通道,采样时间为239.5周期*/
;;;182    		ADC_RegularChannelConfig(ADC2, ADC_Channel_10, 1, ADC_SampleTime_239Cycles5 );
00021a  2307              MOVS     r3,#7
00021c  2201              MOVS     r2,#1
00021e  210a              MOVS     r1,#0xa
000220  4869              LDR      r0,|L1.968|
000222  f7fffffe          BL       ADC_RegularChannelConfig
;;;183    	}
;;;184     
;;;185    	/*边刷*/
;;;186    	{
;;;187    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC |RCC_APB2Periph_ADC2, ENABLE );
000226  2101              MOVS     r1,#1
000228  f44f6082          MOV      r0,#0x410
00022c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;188     
;;;189    		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;190    		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
000230  f44f4000          MOV      r0,#0x8000
000234  f7fffffe          BL       RCC_ADCCLKConfig
;;;191                      
;;;192    		/*配置引脚为模拟输入模式*/
;;;193    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
000238  2002              MOVS     r0,#2
00023a  f8ad0004          STRH     r0,[sp,#4]
;;;194    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00023e  2000              MOVS     r0,#0
000240  f88d0007          STRB     r0,[sp,#7]
;;;195    		GPIO_Init(GPIOC, &GPIO_InitStructure);	
000244  a901              ADD      r1,sp,#4
000246  4863              LDR      r0,|L1.980|
000248  f7fffffe          BL       GPIO_Init
;;;196    
;;;197    		/*复位ADC*/
;;;198    		ADC_DeInit(ADC2);
00024c  485e              LDR      r0,|L1.968|
00024e  f7fffffe          BL       ADC_DeInit
;;;199    
;;;200    		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000252  2000              MOVS     r0,#0
000254  9002              STR      r0,[sp,#8]
;;;201    		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
000256  f88d000c          STRB     r0,[sp,#0xc]
;;;202    		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
00025a  f88d000d          STRB     r0,[sp,#0xd]
;;;203    		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
00025e  f44f2060          MOV      r0,#0xe0000
000262  9004              STR      r0,[sp,#0x10]
;;;204    		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000264  2000              MOVS     r0,#0
000266  9005              STR      r0,[sp,#0x14]
;;;205    		ADC_InitStructure.ADC_NbrOfChannel = 1;
000268  2001              MOVS     r0,#1
00026a  f88d0018          STRB     r0,[sp,#0x18]
;;;206    		ADC_Init(ADC2, &ADC_InitStructure);  
00026e  a902              ADD      r1,sp,#8
000270  4855              LDR      r0,|L1.968|
000272  f7fffffe          BL       ADC_Init
;;;207    
;;;208    		/*使能指定的ADC*/
;;;209    		ADC_Cmd(ADC2, ENABLE);
000276  2101              MOVS     r1,#1
000278  4853              LDR      r0,|L1.968|
00027a  f7fffffe          BL       ADC_Cmd
;;;210    		
;;;211    		/*使能复位校准 */
;;;212    		ADC_ResetCalibration(ADC2);
00027e  4852              LDR      r0,|L1.968|
000280  f7fffffe          BL       ADC_ResetCalibration
;;;213    		 
;;;214    		/*等待复位校准结束*/
;;;215    		while(ADC_GetResetCalibrationStatus(ADC2));
000284  bf00              NOP      
                  |L1.646|
000286  4850              LDR      r0,|L1.968|
000288  f7fffffe          BL       ADC_GetResetCalibrationStatus
00028c  2800              CMP      r0,#0
00028e  d1fa              BNE      |L1.646|
;;;216    		
;;;217    		/*开启AD校准*/
;;;218    		ADC_StartCalibration(ADC2);
000290  484d              LDR      r0,|L1.968|
000292  f7fffffe          BL       ADC_StartCalibration
;;;219    	 
;;;220    		/*等待校准结束*/
;;;221    		while(ADC_GetCalibrationStatus(ADC2));
000296  bf00              NOP      
                  |L1.664|
000298  484b              LDR      r0,|L1.968|
00029a  f7fffffe          BL       ADC_GetCalibrationStatus
00029e  2800              CMP      r0,#0
0002a0  d1fa              BNE      |L1.664|
;;;222    		
;;;223    		/*ADC,ADC通道,采样时间为239.5周期*/
;;;224    		ADC_RegularChannelConfig(ADC2, ADC_Channel_11, 1, ADC_SampleTime_239Cycles5 );
0002a2  2307              MOVS     r3,#7
0002a4  2201              MOVS     r2,#1
0002a6  210b              MOVS     r1,#0xb
0002a8  4847              LDR      r0,|L1.968|
0002aa  f7fffffe          BL       ADC_RegularChannelConfig
;;;225    	}
;;;226    	
;;;227    	
;;;228    	/*电池电压*/
;;;229    	{
;;;230    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB |RCC_APB2Periph_ADC2, ENABLE );
0002ae  2101              MOVS     r1,#1
0002b0  f44f6081          MOV      r0,#0x408
0002b4  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;231     
;;;232    		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;233    		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
0002b8  f44f4000          MOV      r0,#0x8000
0002bc  f7fffffe          BL       RCC_ADCCLKConfig
;;;234                      
;;;235    		/*配置引脚为模拟输入模式*/
;;;236    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
0002c0  2001              MOVS     r0,#1
0002c2  f8ad0004          STRH     r0,[sp,#4]
;;;237    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
0002c6  2000              MOVS     r0,#0
0002c8  f88d0007          STRB     r0,[sp,#7]
;;;238    		GPIO_Init(GPIOB, &GPIO_InitStructure);	
0002cc  a901              ADD      r1,sp,#4
0002ce  483d              LDR      r0,|L1.964|
0002d0  f7fffffe          BL       GPIO_Init
;;;239    
;;;240    		/*复位ADC*/
;;;241    		ADC_DeInit(ADC2);
0002d4  483c              LDR      r0,|L1.968|
0002d6  f7fffffe          BL       ADC_DeInit
;;;242    
;;;243    		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
0002da  2000              MOVS     r0,#0
0002dc  9002              STR      r0,[sp,#8]
;;;244    		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
0002de  f88d000c          STRB     r0,[sp,#0xc]
;;;245    		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
0002e2  f88d000d          STRB     r0,[sp,#0xd]
;;;246    		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
0002e6  f44f2060          MOV      r0,#0xe0000
0002ea  9004              STR      r0,[sp,#0x10]
;;;247    		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
0002ec  2000              MOVS     r0,#0
0002ee  9005              STR      r0,[sp,#0x14]
;;;248    		ADC_InitStructure.ADC_NbrOfChannel = 1;
0002f0  2001              MOVS     r0,#1
0002f2  f88d0018          STRB     r0,[sp,#0x18]
;;;249    		ADC_Init(ADC2, &ADC_InitStructure);  
0002f6  a902              ADD      r1,sp,#8
0002f8  4833              LDR      r0,|L1.968|
0002fa  f7fffffe          BL       ADC_Init
;;;250    
;;;251    		/*使能指定的ADC*/
;;;252    		ADC_Cmd(ADC2, ENABLE);
0002fe  2101              MOVS     r1,#1
000300  4831              LDR      r0,|L1.968|
000302  f7fffffe          BL       ADC_Cmd
;;;253    		
;;;254    		/*使能复位校准 */
;;;255    		ADC_ResetCalibration(ADC2);
000306  4830              LDR      r0,|L1.968|
000308  f7fffffe          BL       ADC_ResetCalibration
;;;256    		 
;;;257    		/*等待复位校准结束*/
;;;258    		while(ADC_GetResetCalibrationStatus(ADC2));
00030c  bf00              NOP      
                  |L1.782|
00030e  482e              LDR      r0,|L1.968|
000310  f7fffffe          BL       ADC_GetResetCalibrationStatus
000314  2800              CMP      r0,#0
000316  d1fa              BNE      |L1.782|
;;;259    		
;;;260    		/*开启AD校准*/
;;;261    		ADC_StartCalibration(ADC2);
000318  482b              LDR      r0,|L1.968|
00031a  f7fffffe          BL       ADC_StartCalibration
;;;262    	 
;;;263    		/*等待校准结束*/
;;;264    		while(ADC_GetCalibrationStatus(ADC2));
00031e  bf00              NOP      
                  |L1.800|
000320  4829              LDR      r0,|L1.968|
000322  f7fffffe          BL       ADC_GetCalibrationStatus
000326  2800              CMP      r0,#0
000328  d1fa              BNE      |L1.800|
;;;265    		
;;;266    		/*ADC,ADC通道,采样时间为239.5周期*/
;;;267    		ADC_RegularChannelConfig(ADC2, ADC_Channel_8, 1, ADC_SampleTime_239Cycles5 );
00032a  2307              MOVS     r3,#7
00032c  2201              MOVS     r2,#1
00032e  2108              MOVS     r1,#8
000330  4825              LDR      r0,|L1.968|
000332  f7fffffe          BL       ADC_RegularChannelConfig
;;;268    	}
;;;269    	
;;;270    	/*充电电流*/
;;;271    	{
;;;272    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF |RCC_APB2Periph_ADC3, ENABLE );
000336  2101              MOVS     r1,#1
000338  f2480080          MOV      r0,#0x8080
00033c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;273     
;;;274    		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;275    		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
000340  f44f4000          MOV      r0,#0x8000
000344  f7fffffe          BL       RCC_ADCCLKConfig
;;;276                      
;;;277    		/*配置引脚为模拟输入模式*/
;;;278    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
000348  2040              MOVS     r0,#0x40
00034a  f8ad0004          STRH     r0,[sp,#4]
;;;279    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00034e  2000              MOVS     r0,#0
000350  f88d0007          STRB     r0,[sp,#7]
;;;280    		GPIO_Init(GPIOF, &GPIO_InitStructure);	
000354  a901              ADD      r1,sp,#4
000356  481d              LDR      r0,|L1.972|
000358  f7fffffe          BL       GPIO_Init
;;;281    
;;;282    		/*复位ADC*/
;;;283    		ADC_DeInit(ADC3);
00035c  481c              LDR      r0,|L1.976|
00035e  f7fffffe          BL       ADC_DeInit
;;;284    
;;;285    		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000362  2000              MOVS     r0,#0
000364  9002              STR      r0,[sp,#8]
;;;286    		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
000366  f88d000c          STRB     r0,[sp,#0xc]
;;;287    		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
00036a  f88d000d          STRB     r0,[sp,#0xd]
;;;288    		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
00036e  f44f2060          MOV      r0,#0xe0000
000372  9004              STR      r0,[sp,#0x10]
;;;289    		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000374  2000              MOVS     r0,#0
000376  9005              STR      r0,[sp,#0x14]
;;;290    		ADC_InitStructure.ADC_NbrOfChannel = 1;
000378  2001              MOVS     r0,#1
00037a  f88d0018          STRB     r0,[sp,#0x18]
;;;291    		ADC_Init(ADC3, &ADC_InitStructure);  
00037e  a902              ADD      r1,sp,#8
000380  4813              LDR      r0,|L1.976|
000382  f7fffffe          BL       ADC_Init
;;;292    
;;;293    		/*使能指定的ADC*/
;;;294    		ADC_Cmd(ADC3, ENABLE);
000386  2101              MOVS     r1,#1
000388  4811              LDR      r0,|L1.976|
00038a  f7fffffe          BL       ADC_Cmd
;;;295    		
;;;296    		/*使能复位校准 */
;;;297    		ADC_ResetCalibration(ADC3);
00038e  4810              LDR      r0,|L1.976|
000390  f7fffffe          BL       ADC_ResetCalibration
;;;298    		 
;;;299    		/*等待复位校准结束*/
;;;300    		while(ADC_GetResetCalibrationStatus(ADC3));
000394  bf00              NOP      
                  |L1.918|
000396  480e              LDR      r0,|L1.976|
000398  f7fffffe          BL       ADC_GetResetCalibrationStatus
00039c  2800              CMP      r0,#0
00039e  d1fa              BNE      |L1.918|
;;;301    		
;;;302    		/*开启AD校准*/
;;;303    		ADC_StartCalibration(ADC3);
0003a0  480b              LDR      r0,|L1.976|
0003a2  f7fffffe          BL       ADC_StartCalibration
;;;304    	 
;;;305    		/*等待校准结束*/
;;;306    		while(ADC_GetCalibrationStatus(ADC3));
0003a6  bf00              NOP      
                  |L1.936|
0003a8  4809              LDR      r0,|L1.976|
0003aa  f7fffffe          BL       ADC_GetCalibrationStatus
0003ae  2800              CMP      r0,#0
0003b0  d1fa              BNE      |L1.936|
;;;307    		
;;;308    		/*ADC,ADC通道,采样时间为239.5周期*/
;;;309    		ADC_RegularChannelConfig(ADC3, ADC_Channel_4, 1, ADC_SampleTime_239Cycles5 );
0003b2  2307              MOVS     r3,#7
0003b4  2201              MOVS     r2,#1
0003b6  2104              MOVS     r1,#4
0003b8  4805              LDR      r0,|L1.976|
0003ba  f7fffffe          BL       ADC_RegularChannelConfig
;;;310    	}
;;;311    	
;;;312    }
0003be  b007              ADD      sp,sp,#0x1c
0003c0  bd00              POP      {pc}
                          ENDP

0003c2  0000              DCW      0x0000
                  |L1.964|
                          DCD      0x40010c00
                  |L1.968|
                          DCD      0x40012800
                  |L1.972|
                          DCD      0x40011c00
                  |L1.976|
                          DCD      0x40013c00
                  |L1.980|
                          DCD      0x40011000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\src\\bsp_CurrentFeedback.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_bsp_CurrentFeedback_c_91b4e5ab____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___21_bsp_CurrentFeedback_c_91b4e5ab____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_bsp_CurrentFeedback_c_91b4e5ab____REVSH|
#line 128
|__asm___21_bsp_CurrentFeedback_c_91b4e5ab____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
