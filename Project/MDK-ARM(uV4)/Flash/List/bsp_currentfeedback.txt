; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_currentfeedback.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_currentfeedback.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\app\inc -IF:\LuckyXRQ\CleanCar\Project\MDK-ARM(uV4)\RTE -ID:\soft\MDK5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\soft\MDK5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_currentfeedback.crf ..\..\User\app\src\bsp_CurrentFeedback.c]
                          THUMB

                          AREA ||i.bsp_GetFeedbackVoltage||, CODE, READONLY, ALIGN=2

                  bsp_GetFeedbackVoltage PROC
;;;324    */
;;;325    float bsp_GetFeedbackVoltage(FeedbackSN sn)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;326    {
000004  4604              MOV      r4,r0
;;;327    	float ret = 0;
000006  2500              MOVS     r5,#0
;;;328    	
;;;329    	switch(sn)
000008  2c07              CMP      r4,#7
00000a  d226              BCS      |L1.90|
00000c  e8dff004          TBB      [pc,r4]
000010  0426486a          DCB      0x04,0x26,0x48,0x6a
000014  8caed000          DCB      0x8c,0xae,0xd0,0x00
;;;330    	{
;;;331    		case eMotorLeft:
;;;332    		{
;;;333    			ADC_RegularChannelConfig(ADC2, ADC_Channel_9, 1, ADC_SampleTime_239Cycles5 );
000018  2307              MOVS     r3,#7
00001a  2201              MOVS     r2,#1
00001c  2109              MOVS     r1,#9
00001e  4877              LDR      r0,|L1.508|
000020  f7fffffe          BL       ADC_RegularChannelConfig
;;;334    			ADC_SoftwareStartConvCmd(ADC2, ENABLE);	
000024  2101              MOVS     r1,#1
000026  4875              LDR      r0,|L1.508|
000028  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;335    			while(!ADC_GetFlagStatus(ADC2, ADC_FLAG_EOC ));
00002c  bf00              NOP      
                  |L1.46|
00002e  2102              MOVS     r1,#2
000030  4872              LDR      r0,|L1.508|
000032  f7fffffe          BL       ADC_GetFlagStatus
000036  2800              CMP      r0,#0
000038  d0f9              BEQ      |L1.46|
;;;336    			ret = ADC_GetConversionValue(ADC2) * 3.3F / 4096;
00003a  4870              LDR      r0,|L1.508|
00003c  f7fffffe          BL       ADC_GetConversionValue
000040  4680              MOV      r8,r0
000042  f7fffffe          BL       __aeabi_ui2f
000046  4607              MOV      r7,r0
000048  496d              LDR      r1,|L1.512|
00004a  f7fffffe          BL       __aeabi_fmul
00004e  4606              MOV      r6,r0
000050  f04f418b          MOV      r1,#0x45800000
000054  f7fffffe          BL       __aeabi_fdiv
000058  4605              MOV      r5,r0
                  |L1.90|
;;;337    		}break;
00005a  e0cb              B        |L1.500|
;;;338    		
;;;339    		case eMotorRight:
;;;340    		{
;;;341    			ADC_RegularChannelConfig(ADC3, ADC_Channel_8, 1, ADC_SampleTime_239Cycles5 );
00005c  2307              MOVS     r3,#7
00005e  2201              MOVS     r2,#1
000060  2108              MOVS     r1,#8
000062  4868              LDR      r0,|L1.516|
000064  f7fffffe          BL       ADC_RegularChannelConfig
;;;342    			ADC_SoftwareStartConvCmd(ADC3, ENABLE);	
000068  2101              MOVS     r1,#1
00006a  4866              LDR      r0,|L1.516|
00006c  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;343    			while(!ADC_GetFlagStatus(ADC3, ADC_FLAG_EOC ));
000070  bf00              NOP      
                  |L1.114|
000072  2102              MOVS     r1,#2
000074  4863              LDR      r0,|L1.516|
000076  f7fffffe          BL       ADC_GetFlagStatus
00007a  2800              CMP      r0,#0
00007c  d0f9              BEQ      |L1.114|
;;;344    			ret = ADC_GetConversionValue(ADC3) * 3.3F / 4096;
00007e  4861              LDR      r0,|L1.516|
000080  f7fffffe          BL       ADC_GetConversionValue
000084  4680              MOV      r8,r0
000086  f7fffffe          BL       __aeabi_ui2f
00008a  4607              MOV      r7,r0
00008c  495c              LDR      r1,|L1.512|
00008e  f7fffffe          BL       __aeabi_fmul
000092  4606              MOV      r6,r0
000094  f04f418b          MOV      r1,#0x45800000
000098  f7fffffe          BL       __aeabi_fdiv
00009c  4605              MOV      r5,r0
;;;345    		}break;
00009e  e0a9              B        |L1.500|
;;;346    		
;;;347    		case eVacuum:
;;;348    		{
;;;349    			ADC_RegularChannelConfig(ADC2, ADC_Channel_12, 1, ADC_SampleTime_239Cycles5 );
0000a0  2307              MOVS     r3,#7
0000a2  2201              MOVS     r2,#1
0000a4  210c              MOVS     r1,#0xc
0000a6  4855              LDR      r0,|L1.508|
0000a8  f7fffffe          BL       ADC_RegularChannelConfig
;;;350    			ADC_SoftwareStartConvCmd(ADC2, ENABLE);	
0000ac  2101              MOVS     r1,#1
0000ae  4853              LDR      r0,|L1.508|
0000b0  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;351    			while(!ADC_GetFlagStatus(ADC2, ADC_FLAG_EOC ));
0000b4  bf00              NOP      
                  |L1.182|
0000b6  2102              MOVS     r1,#2
0000b8  4850              LDR      r0,|L1.508|
0000ba  f7fffffe          BL       ADC_GetFlagStatus
0000be  2800              CMP      r0,#0
0000c0  d0f9              BEQ      |L1.182|
;;;352    			ret = ADC_GetConversionValue(ADC2) * 3.3F / 4096;
0000c2  484e              LDR      r0,|L1.508|
0000c4  f7fffffe          BL       ADC_GetConversionValue
0000c8  4680              MOV      r8,r0
0000ca  f7fffffe          BL       __aeabi_ui2f
0000ce  4607              MOV      r7,r0
0000d0  494b              LDR      r1,|L1.512|
0000d2  f7fffffe          BL       __aeabi_fmul
0000d6  4606              MOV      r6,r0
0000d8  f04f418b          MOV      r1,#0x45800000
0000dc  f7fffffe          BL       __aeabi_fdiv
0000e0  4605              MOV      r5,r0
;;;353    		}break;
0000e2  e087              B        |L1.500|
;;;354    		
;;;355    		case eRollingBrush:
;;;356    		{
;;;357    			ADC_RegularChannelConfig(ADC2, ADC_Channel_10, 1, ADC_SampleTime_239Cycles5 );
0000e4  2307              MOVS     r3,#7
0000e6  2201              MOVS     r2,#1
0000e8  210a              MOVS     r1,#0xa
0000ea  4844              LDR      r0,|L1.508|
0000ec  f7fffffe          BL       ADC_RegularChannelConfig
;;;358    			ADC_SoftwareStartConvCmd(ADC2, ENABLE);	
0000f0  2101              MOVS     r1,#1
0000f2  4842              LDR      r0,|L1.508|
0000f4  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;359    			while(!ADC_GetFlagStatus(ADC2, ADC_FLAG_EOC ));
0000f8  bf00              NOP      
                  |L1.250|
0000fa  2102              MOVS     r1,#2
0000fc  483f              LDR      r0,|L1.508|
0000fe  f7fffffe          BL       ADC_GetFlagStatus
000102  2800              CMP      r0,#0
000104  d0f9              BEQ      |L1.250|
;;;360    			ret = ADC_GetConversionValue(ADC2) * 3.3F / 4096;
000106  483d              LDR      r0,|L1.508|
000108  f7fffffe          BL       ADC_GetConversionValue
00010c  4680              MOV      r8,r0
00010e  f7fffffe          BL       __aeabi_ui2f
000112  4607              MOV      r7,r0
000114  493a              LDR      r1,|L1.512|
000116  f7fffffe          BL       __aeabi_fmul
00011a  4606              MOV      r6,r0
00011c  f04f418b          MOV      r1,#0x45800000
000120  f7fffffe          BL       __aeabi_fdiv
000124  4605              MOV      r5,r0
;;;361    		}break;
000126  e065              B        |L1.500|
;;;362    		
;;;363    		case eSideBrush:
;;;364    		{
;;;365    			ADC_RegularChannelConfig(ADC2, ADC_Channel_11, 1, ADC_SampleTime_239Cycles5 );
000128  2307              MOVS     r3,#7
00012a  2201              MOVS     r2,#1
00012c  210b              MOVS     r1,#0xb
00012e  4833              LDR      r0,|L1.508|
000130  f7fffffe          BL       ADC_RegularChannelConfig
;;;366    			ADC_SoftwareStartConvCmd(ADC2, ENABLE);	
000134  2101              MOVS     r1,#1
000136  4831              LDR      r0,|L1.508|
000138  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;367    			while(!ADC_GetFlagStatus(ADC2, ADC_FLAG_EOC ));
00013c  bf00              NOP      
                  |L1.318|
00013e  2102              MOVS     r1,#2
000140  482e              LDR      r0,|L1.508|
000142  f7fffffe          BL       ADC_GetFlagStatus
000146  2800              CMP      r0,#0
000148  d0f9              BEQ      |L1.318|
;;;368    			ret = ADC_GetConversionValue(ADC2) * 3.3F / 4096;
00014a  482c              LDR      r0,|L1.508|
00014c  f7fffffe          BL       ADC_GetConversionValue
000150  4680              MOV      r8,r0
000152  f7fffffe          BL       __aeabi_ui2f
000156  4607              MOV      r7,r0
000158  4929              LDR      r1,|L1.512|
00015a  f7fffffe          BL       __aeabi_fmul
00015e  4606              MOV      r6,r0
000160  f04f418b          MOV      r1,#0x45800000
000164  f7fffffe          BL       __aeabi_fdiv
000168  4605              MOV      r5,r0
;;;369    		}break;
00016a  e043              B        |L1.500|
;;;370    		
;;;371    		case eBatteryVoltage:
;;;372    		{
;;;373    			ADC_RegularChannelConfig(ADC2, ADC_Channel_8, 1, ADC_SampleTime_239Cycles5 );
00016c  2307              MOVS     r3,#7
00016e  2201              MOVS     r2,#1
000170  2108              MOVS     r1,#8
000172  4822              LDR      r0,|L1.508|
000174  f7fffffe          BL       ADC_RegularChannelConfig
;;;374    			ADC_SoftwareStartConvCmd(ADC2, ENABLE);	
000178  2101              MOVS     r1,#1
00017a  4820              LDR      r0,|L1.508|
00017c  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;375    			while(!ADC_GetFlagStatus(ADC2, ADC_FLAG_EOC ));
000180  bf00              NOP      
                  |L1.386|
000182  2102              MOVS     r1,#2
000184  481d              LDR      r0,|L1.508|
000186  f7fffffe          BL       ADC_GetFlagStatus
00018a  2800              CMP      r0,#0
00018c  d0f9              BEQ      |L1.386|
;;;376    			ret = ADC_GetConversionValue(ADC2) * 3.3F / 4096;
00018e  481b              LDR      r0,|L1.508|
000190  f7fffffe          BL       ADC_GetConversionValue
000194  4680              MOV      r8,r0
000196  f7fffffe          BL       __aeabi_ui2f
00019a  4607              MOV      r7,r0
00019c  4918              LDR      r1,|L1.512|
00019e  f7fffffe          BL       __aeabi_fmul
0001a2  4606              MOV      r6,r0
0001a4  f04f418b          MOV      r1,#0x45800000
0001a8  f7fffffe          BL       __aeabi_fdiv
0001ac  4605              MOV      r5,r0
;;;377    		}break;
0001ae  e021              B        |L1.500|
;;;378    		
;;;379    		case eBatteryCurrent:
;;;380    		{
;;;381    			ADC_RegularChannelConfig(ADC3, ADC_Channel_4, 1, ADC_SampleTime_239Cycles5 );
0001b0  2307              MOVS     r3,#7
0001b2  2201              MOVS     r2,#1
0001b4  2104              MOVS     r1,#4
0001b6  4813              LDR      r0,|L1.516|
0001b8  f7fffffe          BL       ADC_RegularChannelConfig
;;;382    			ADC_SoftwareStartConvCmd(ADC3, ENABLE);	
0001bc  2101              MOVS     r1,#1
0001be  4811              LDR      r0,|L1.516|
0001c0  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;383    			while(!ADC_GetFlagStatus(ADC3, ADC_FLAG_EOC ));
0001c4  bf00              NOP      
                  |L1.454|
0001c6  2102              MOVS     r1,#2
0001c8  480e              LDR      r0,|L1.516|
0001ca  f7fffffe          BL       ADC_GetFlagStatus
0001ce  2800              CMP      r0,#0
0001d0  d0f9              BEQ      |L1.454|
;;;384    			ret = ADC_GetConversionValue(ADC3) * 3.3F / 4096;
0001d2  480c              LDR      r0,|L1.516|
0001d4  f7fffffe          BL       ADC_GetConversionValue
0001d8  4680              MOV      r8,r0
0001da  f7fffffe          BL       __aeabi_ui2f
0001de  4607              MOV      r7,r0
0001e0  4907              LDR      r1,|L1.512|
0001e2  f7fffffe          BL       __aeabi_fmul
0001e6  4606              MOV      r6,r0
0001e8  f04f418b          MOV      r1,#0x45800000
0001ec  f7fffffe          BL       __aeabi_fdiv
0001f0  4605              MOV      r5,r0
;;;385    		}break;
0001f2  bf00              NOP      
                  |L1.500|
0001f4  bf00              NOP                            ;337
;;;386    	}
;;;387    	
;;;388    	return ret ;
0001f6  4628              MOV      r0,r5
;;;389    }
0001f8  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

                  |L1.508|
                          DCD      0x40012800
                  |L1.512|
                          DCD      0x40533333
                  |L1.516|
                          DCD      0x40013c00

                          AREA ||i.bsp_InitCurrentFeedbackADC||, CODE, READONLY, ALIGN=2

                  bsp_InitCurrentFeedbackADC PROC
;;;12     */
;;;13     void bsp_InitCurrentFeedbackADC(void)
000000  b500              PUSH     {lr}
;;;14     {
000002  b087              SUB      sp,sp,#0x1c
;;;15     	ADC_InitTypeDef ADC_InitStructure; 
;;;16     	GPIO_InitTypeDef GPIO_InitStructure;
;;;17     
;;;18     	/*左轮机*/
;;;19     	{
;;;20     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB |RCC_APB2Periph_ADC2, ENABLE );
000004  2101              MOVS     r1,#1
000006  f44f6081          MOV      r0,#0x408
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;21      
;;;22     		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;23     		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
00000e  f44f4000          MOV      r0,#0x8000
000012  f7fffffe          BL       RCC_ADCCLKConfig
;;;24                       
;;;25     		/*配置引脚为模拟输入模式*/
;;;26     		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
000016  2002              MOVS     r0,#2
000018  f8ad0004          STRH     r0,[sp,#4]
;;;27     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00001c  2000              MOVS     r0,#0
00001e  f88d0007          STRB     r0,[sp,#7]
;;;28     		GPIO_Init(GPIOB, &GPIO_InitStructure);	
000022  a901              ADD      r1,sp,#4
000024  48e7              LDR      r0,|L2.964|
000026  f7fffffe          BL       GPIO_Init
;;;29     
;;;30     		/*复位ADC*/
;;;31     		ADC_DeInit(ADC2);
00002a  48e7              LDR      r0,|L2.968|
00002c  f7fffffe          BL       ADC_DeInit
;;;32     
;;;33     		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000030  2000              MOVS     r0,#0
000032  9002              STR      r0,[sp,#8]
;;;34     		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
000034  f88d000c          STRB     r0,[sp,#0xc]
;;;35     		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
000038  f88d000d          STRB     r0,[sp,#0xd]
;;;36     		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
00003c  f44f2060          MOV      r0,#0xe0000
000040  9004              STR      r0,[sp,#0x10]
;;;37     		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000042  2000              MOVS     r0,#0
000044  9005              STR      r0,[sp,#0x14]
;;;38     		ADC_InitStructure.ADC_NbrOfChannel = 1;
000046  2001              MOVS     r0,#1
000048  f88d0018          STRB     r0,[sp,#0x18]
;;;39     		ADC_Init(ADC2, &ADC_InitStructure);  
00004c  a902              ADD      r1,sp,#8
00004e  48de              LDR      r0,|L2.968|
000050  f7fffffe          BL       ADC_Init
;;;40     
;;;41     		/*使能指定的ADC*/
;;;42     		ADC_Cmd(ADC2, ENABLE);
000054  2101              MOVS     r1,#1
000056  48dc              LDR      r0,|L2.968|
000058  f7fffffe          BL       ADC_Cmd
;;;43     		
;;;44     		/*使能复位校准 */
;;;45     		ADC_ResetCalibration(ADC2);
00005c  48da              LDR      r0,|L2.968|
00005e  f7fffffe          BL       ADC_ResetCalibration
;;;46     		 
;;;47     		/*等待复位校准结束*/
;;;48     		while(ADC_GetResetCalibrationStatus(ADC2));
000062  bf00              NOP      
                  |L2.100|
000064  48d8              LDR      r0,|L2.968|
000066  f7fffffe          BL       ADC_GetResetCalibrationStatus
00006a  2800              CMP      r0,#0
00006c  d1fa              BNE      |L2.100|
;;;49     		
;;;50     		/*开启AD校准*/
;;;51     		ADC_StartCalibration(ADC2);
00006e  48d6              LDR      r0,|L2.968|
000070  f7fffffe          BL       ADC_StartCalibration
;;;52     	 
;;;53     		/*等待校准结束*/
;;;54     		while(ADC_GetCalibrationStatus(ADC2));
000074  bf00              NOP      
                  |L2.118|
000076  48d4              LDR      r0,|L2.968|
000078  f7fffffe          BL       ADC_GetCalibrationStatus
00007c  2800              CMP      r0,#0
00007e  d1fa              BNE      |L2.118|
;;;55     		
;;;56     		/*ADC,ADC通道,采样时间为239.5周期*/
;;;57     		ADC_RegularChannelConfig(ADC2, ADC_Channel_9, 1, ADC_SampleTime_239Cycles5 );
000080  2307              MOVS     r3,#7
000082  2201              MOVS     r2,#1
000084  2109              MOVS     r1,#9
000086  48d0              LDR      r0,|L2.968|
000088  f7fffffe          BL       ADC_RegularChannelConfig
;;;58     	}
;;;59     	
;;;60     	/*右轮机*/
;;;61     	{
;;;62     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF |RCC_APB2Periph_ADC3, ENABLE );
00008c  2101              MOVS     r1,#1
00008e  f2480080          MOV      r0,#0x8080
000092  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;63      
;;;64     		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;65     		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
000096  f44f4000          MOV      r0,#0x8000
00009a  f7fffffe          BL       RCC_ADCCLKConfig
;;;66                       
;;;67     		/*配置引脚为模拟输入模式*/
;;;68     		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
00009e  f44f6080          MOV      r0,#0x400
0000a2  f8ad0004          STRH     r0,[sp,#4]
;;;69     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
0000a6  2000              MOVS     r0,#0
0000a8  f88d0007          STRB     r0,[sp,#7]
;;;70     		GPIO_Init(GPIOF, &GPIO_InitStructure);	
0000ac  a901              ADD      r1,sp,#4
0000ae  48c7              LDR      r0,|L2.972|
0000b0  f7fffffe          BL       GPIO_Init
;;;71     
;;;72     		/*复位ADC*/
;;;73     		ADC_DeInit(ADC3);
0000b4  48c6              LDR      r0,|L2.976|
0000b6  f7fffffe          BL       ADC_DeInit
;;;74     
;;;75     		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
0000ba  2000              MOVS     r0,#0
0000bc  9002              STR      r0,[sp,#8]
;;;76     		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
0000be  f88d000c          STRB     r0,[sp,#0xc]
;;;77     		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
0000c2  f88d000d          STRB     r0,[sp,#0xd]
;;;78     		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
0000c6  f44f2060          MOV      r0,#0xe0000
0000ca  9004              STR      r0,[sp,#0x10]
;;;79     		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
0000cc  2000              MOVS     r0,#0
0000ce  9005              STR      r0,[sp,#0x14]
;;;80     		ADC_InitStructure.ADC_NbrOfChannel = 1;
0000d0  2001              MOVS     r0,#1
0000d2  f88d0018          STRB     r0,[sp,#0x18]
;;;81     		ADC_Init(ADC3, &ADC_InitStructure);  
0000d6  a902              ADD      r1,sp,#8
0000d8  48bd              LDR      r0,|L2.976|
0000da  f7fffffe          BL       ADC_Init
;;;82     
;;;83     		/*使能指定的ADC*/
;;;84     		ADC_Cmd(ADC3, ENABLE);
0000de  2101              MOVS     r1,#1
0000e0  48bb              LDR      r0,|L2.976|
0000e2  f7fffffe          BL       ADC_Cmd
;;;85     		
;;;86     		/*使能复位校准 */
;;;87     		ADC_ResetCalibration(ADC3);
0000e6  48ba              LDR      r0,|L2.976|
0000e8  f7fffffe          BL       ADC_ResetCalibration
;;;88     		 
;;;89     		/*等待复位校准结束*/
;;;90     		while(ADC_GetResetCalibrationStatus(ADC3));
0000ec  bf00              NOP      
                  |L2.238|
0000ee  48b8              LDR      r0,|L2.976|
0000f0  f7fffffe          BL       ADC_GetResetCalibrationStatus
0000f4  2800              CMP      r0,#0
0000f6  d1fa              BNE      |L2.238|
;;;91     		
;;;92     		/*开启AD校准*/
;;;93     		ADC_StartCalibration(ADC3);
0000f8  48b5              LDR      r0,|L2.976|
0000fa  f7fffffe          BL       ADC_StartCalibration
;;;94     	 
;;;95     		/*等待校准结束*/
;;;96     		while(ADC_GetCalibrationStatus(ADC3));
0000fe  bf00              NOP      
                  |L2.256|
000100  48b3              LDR      r0,|L2.976|
000102  f7fffffe          BL       ADC_GetCalibrationStatus
000106  2800              CMP      r0,#0
000108  d1fa              BNE      |L2.256|
;;;97     		
;;;98     		/*ADC,ADC通道,采样时间为239.5周期*/
;;;99     		ADC_RegularChannelConfig(ADC3, ADC_Channel_8, 1, ADC_SampleTime_239Cycles5 );
00010a  2307              MOVS     r3,#7
00010c  2201              MOVS     r2,#1
00010e  2108              MOVS     r1,#8
000110  48af              LDR      r0,|L2.976|
000112  f7fffffe          BL       ADC_RegularChannelConfig
;;;100    	}	
;;;101    	
;;;102    	
;;;103    	/*吸尘*/
;;;104    	{
;;;105    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC |RCC_APB2Periph_ADC2, ENABLE );
000116  2101              MOVS     r1,#1
000118  f44f6082          MOV      r0,#0x410
00011c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;106     
;;;107    		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;108    		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
000120  f44f4000          MOV      r0,#0x8000
000124  f7fffffe          BL       RCC_ADCCLKConfig
;;;109                      
;;;110    		/*配置引脚为模拟输入模式*/
;;;111    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000128  2004              MOVS     r0,#4
00012a  f8ad0004          STRH     r0,[sp,#4]
;;;112    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00012e  2000              MOVS     r0,#0
000130  f88d0007          STRB     r0,[sp,#7]
;;;113    		GPIO_Init(GPIOC, &GPIO_InitStructure);	
000134  a901              ADD      r1,sp,#4
000136  48a7              LDR      r0,|L2.980|
000138  f7fffffe          BL       GPIO_Init
;;;114    
;;;115    		/*复位ADC*/
;;;116    		ADC_DeInit(ADC2);
00013c  48a2              LDR      r0,|L2.968|
00013e  f7fffffe          BL       ADC_DeInit
;;;117    
;;;118    		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000142  2000              MOVS     r0,#0
000144  9002              STR      r0,[sp,#8]
;;;119    		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
000146  f88d000c          STRB     r0,[sp,#0xc]
;;;120    		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
00014a  f88d000d          STRB     r0,[sp,#0xd]
;;;121    		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
00014e  f44f2060          MOV      r0,#0xe0000
000152  9004              STR      r0,[sp,#0x10]
;;;122    		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000154  2000              MOVS     r0,#0
000156  9005              STR      r0,[sp,#0x14]
;;;123    		ADC_InitStructure.ADC_NbrOfChannel = 1;
000158  2001              MOVS     r0,#1
00015a  f88d0018          STRB     r0,[sp,#0x18]
;;;124    		ADC_Init(ADC2, &ADC_InitStructure);  
00015e  a902              ADD      r1,sp,#8
000160  4899              LDR      r0,|L2.968|
000162  f7fffffe          BL       ADC_Init
;;;125    
;;;126    		/*使能指定的ADC*/
;;;127    		ADC_Cmd(ADC2, ENABLE);
000166  2101              MOVS     r1,#1
000168  4897              LDR      r0,|L2.968|
00016a  f7fffffe          BL       ADC_Cmd
;;;128    		
;;;129    		/*使能复位校准 */
;;;130    		ADC_ResetCalibration(ADC2);
00016e  4896              LDR      r0,|L2.968|
000170  f7fffffe          BL       ADC_ResetCalibration
;;;131    		 
;;;132    		/*等待复位校准结束*/
;;;133    		while(ADC_GetResetCalibrationStatus(ADC2));
000174  bf00              NOP      
                  |L2.374|
000176  4894              LDR      r0,|L2.968|
000178  f7fffffe          BL       ADC_GetResetCalibrationStatus
00017c  2800              CMP      r0,#0
00017e  d1fa              BNE      |L2.374|
;;;134    		
;;;135    		/*开启AD校准*/
;;;136    		ADC_StartCalibration(ADC2);
000180  4891              LDR      r0,|L2.968|
000182  f7fffffe          BL       ADC_StartCalibration
;;;137    	 
;;;138    		/*等待校准结束*/
;;;139    		while(ADC_GetCalibrationStatus(ADC2));
000186  bf00              NOP      
                  |L2.392|
000188  488f              LDR      r0,|L2.968|
00018a  f7fffffe          BL       ADC_GetCalibrationStatus
00018e  2800              CMP      r0,#0
000190  d1fa              BNE      |L2.392|
;;;140    		
;;;141    		/*ADC,ADC通道,采样时间为239.5周期*/
;;;142    		ADC_RegularChannelConfig(ADC2, ADC_Channel_12, 1, ADC_SampleTime_239Cycles5 );
000192  2307              MOVS     r3,#7
000194  2201              MOVS     r2,#1
000196  210c              MOVS     r1,#0xc
000198  488b              LDR      r0,|L2.968|
00019a  f7fffffe          BL       ADC_RegularChannelConfig
;;;143    	}
;;;144    	
;;;145    	/*滚刷*/
;;;146    	{
;;;147    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC |RCC_APB2Periph_ADC2, ENABLE );
00019e  2101              MOVS     r1,#1
0001a0  f44f6082          MOV      r0,#0x410
0001a4  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;148     
;;;149    		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;150    		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
0001a8  f44f4000          MOV      r0,#0x8000
0001ac  f7fffffe          BL       RCC_ADCCLKConfig
;;;151                      
;;;152    		/*配置引脚为模拟输入模式*/
;;;153    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
0001b0  2001              MOVS     r0,#1
0001b2  f8ad0004          STRH     r0,[sp,#4]
;;;154    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
0001b6  2000              MOVS     r0,#0
0001b8  f88d0007          STRB     r0,[sp,#7]
;;;155    		GPIO_Init(GPIOC, &GPIO_InitStructure);	
0001bc  a901              ADD      r1,sp,#4
0001be  4885              LDR      r0,|L2.980|
0001c0  f7fffffe          BL       GPIO_Init
;;;156    
;;;157    		/*复位ADC*/
;;;158    		ADC_DeInit(ADC2);
0001c4  4880              LDR      r0,|L2.968|
0001c6  f7fffffe          BL       ADC_DeInit
;;;159    
;;;160    		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
0001ca  2000              MOVS     r0,#0
0001cc  9002              STR      r0,[sp,#8]
;;;161    		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
0001ce  f88d000c          STRB     r0,[sp,#0xc]
;;;162    		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
0001d2  f88d000d          STRB     r0,[sp,#0xd]
;;;163    		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
0001d6  f44f2060          MOV      r0,#0xe0000
0001da  9004              STR      r0,[sp,#0x10]
;;;164    		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
0001dc  2000              MOVS     r0,#0
0001de  9005              STR      r0,[sp,#0x14]
;;;165    		ADC_InitStructure.ADC_NbrOfChannel = 1;
0001e0  2001              MOVS     r0,#1
0001e2  f88d0018          STRB     r0,[sp,#0x18]
;;;166    		ADC_Init(ADC2, &ADC_InitStructure);  
0001e6  a902              ADD      r1,sp,#8
0001e8  4877              LDR      r0,|L2.968|
0001ea  f7fffffe          BL       ADC_Init
;;;167    
;;;168    		/*使能指定的ADC*/
;;;169    		ADC_Cmd(ADC2, ENABLE);
0001ee  2101              MOVS     r1,#1
0001f0  4875              LDR      r0,|L2.968|
0001f2  f7fffffe          BL       ADC_Cmd
;;;170    		
;;;171    		/*使能复位校准 */
;;;172    		ADC_ResetCalibration(ADC2);
0001f6  4874              LDR      r0,|L2.968|
0001f8  f7fffffe          BL       ADC_ResetCalibration
;;;173    		 
;;;174    		/*等待复位校准结束*/
;;;175    		while(ADC_GetResetCalibrationStatus(ADC2));
0001fc  bf00              NOP      
                  |L2.510|
0001fe  4872              LDR      r0,|L2.968|
000200  f7fffffe          BL       ADC_GetResetCalibrationStatus
000204  2800              CMP      r0,#0
000206  d1fa              BNE      |L2.510|
;;;176    		
;;;177    		/*开启AD校准*/
;;;178    		ADC_StartCalibration(ADC2);
000208  486f              LDR      r0,|L2.968|
00020a  f7fffffe          BL       ADC_StartCalibration
;;;179    	 
;;;180    		/*等待校准结束*/
;;;181    		while(ADC_GetCalibrationStatus(ADC2));
00020e  bf00              NOP      
                  |L2.528|
000210  486d              LDR      r0,|L2.968|
000212  f7fffffe          BL       ADC_GetCalibrationStatus
000216  2800              CMP      r0,#0
000218  d1fa              BNE      |L2.528|
;;;182    		
;;;183    		/*ADC,ADC通道,采样时间为239.5周期*/
;;;184    		ADC_RegularChannelConfig(ADC2, ADC_Channel_10, 1, ADC_SampleTime_239Cycles5 );
00021a  2307              MOVS     r3,#7
00021c  2201              MOVS     r2,#1
00021e  210a              MOVS     r1,#0xa
000220  4869              LDR      r0,|L2.968|
000222  f7fffffe          BL       ADC_RegularChannelConfig
;;;185    	}
;;;186     
;;;187    	/*边刷*/
;;;188    	{
;;;189    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC |RCC_APB2Periph_ADC2, ENABLE );
000226  2101              MOVS     r1,#1
000228  f44f6082          MOV      r0,#0x410
00022c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;190     
;;;191    		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;192    		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
000230  f44f4000          MOV      r0,#0x8000
000234  f7fffffe          BL       RCC_ADCCLKConfig
;;;193                      
;;;194    		/*配置引脚为模拟输入模式*/
;;;195    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
000238  2002              MOVS     r0,#2
00023a  f8ad0004          STRH     r0,[sp,#4]
;;;196    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00023e  2000              MOVS     r0,#0
000240  f88d0007          STRB     r0,[sp,#7]
;;;197    		GPIO_Init(GPIOC, &GPIO_InitStructure);	
000244  a901              ADD      r1,sp,#4
000246  4863              LDR      r0,|L2.980|
000248  f7fffffe          BL       GPIO_Init
;;;198    
;;;199    		/*复位ADC*/
;;;200    		ADC_DeInit(ADC2);
00024c  485e              LDR      r0,|L2.968|
00024e  f7fffffe          BL       ADC_DeInit
;;;201    
;;;202    		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000252  2000              MOVS     r0,#0
000254  9002              STR      r0,[sp,#8]
;;;203    		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
000256  f88d000c          STRB     r0,[sp,#0xc]
;;;204    		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
00025a  f88d000d          STRB     r0,[sp,#0xd]
;;;205    		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
00025e  f44f2060          MOV      r0,#0xe0000
000262  9004              STR      r0,[sp,#0x10]
;;;206    		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000264  2000              MOVS     r0,#0
000266  9005              STR      r0,[sp,#0x14]
;;;207    		ADC_InitStructure.ADC_NbrOfChannel = 1;
000268  2001              MOVS     r0,#1
00026a  f88d0018          STRB     r0,[sp,#0x18]
;;;208    		ADC_Init(ADC2, &ADC_InitStructure);  
00026e  a902              ADD      r1,sp,#8
000270  4855              LDR      r0,|L2.968|
000272  f7fffffe          BL       ADC_Init
;;;209    
;;;210    		/*使能指定的ADC*/
;;;211    		ADC_Cmd(ADC2, ENABLE);
000276  2101              MOVS     r1,#1
000278  4853              LDR      r0,|L2.968|
00027a  f7fffffe          BL       ADC_Cmd
;;;212    		
;;;213    		/*使能复位校准 */
;;;214    		ADC_ResetCalibration(ADC2);
00027e  4852              LDR      r0,|L2.968|
000280  f7fffffe          BL       ADC_ResetCalibration
;;;215    		 
;;;216    		/*等待复位校准结束*/
;;;217    		while(ADC_GetResetCalibrationStatus(ADC2));
000284  bf00              NOP      
                  |L2.646|
000286  4850              LDR      r0,|L2.968|
000288  f7fffffe          BL       ADC_GetResetCalibrationStatus
00028c  2800              CMP      r0,#0
00028e  d1fa              BNE      |L2.646|
;;;218    		
;;;219    		/*开启AD校准*/
;;;220    		ADC_StartCalibration(ADC2);
000290  484d              LDR      r0,|L2.968|
000292  f7fffffe          BL       ADC_StartCalibration
;;;221    	 
;;;222    		/*等待校准结束*/
;;;223    		while(ADC_GetCalibrationStatus(ADC2));
000296  bf00              NOP      
                  |L2.664|
000298  484b              LDR      r0,|L2.968|
00029a  f7fffffe          BL       ADC_GetCalibrationStatus
00029e  2800              CMP      r0,#0
0002a0  d1fa              BNE      |L2.664|
;;;224    		
;;;225    		/*ADC,ADC通道,采样时间为239.5周期*/
;;;226    		ADC_RegularChannelConfig(ADC2, ADC_Channel_11, 1, ADC_SampleTime_239Cycles5 );
0002a2  2307              MOVS     r3,#7
0002a4  2201              MOVS     r2,#1
0002a6  210b              MOVS     r1,#0xb
0002a8  4847              LDR      r0,|L2.968|
0002aa  f7fffffe          BL       ADC_RegularChannelConfig
;;;227    	}
;;;228    	
;;;229    	
;;;230    	/*电池电压*/
;;;231    	{
;;;232    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB |RCC_APB2Periph_ADC2, ENABLE );
0002ae  2101              MOVS     r1,#1
0002b0  f44f6081          MOV      r0,#0x408
0002b4  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;233     
;;;234    		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;235    		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
0002b8  f44f4000          MOV      r0,#0x8000
0002bc  f7fffffe          BL       RCC_ADCCLKConfig
;;;236                      
;;;237    		/*配置引脚为模拟输入模式*/
;;;238    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
0002c0  2001              MOVS     r0,#1
0002c2  f8ad0004          STRH     r0,[sp,#4]
;;;239    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
0002c6  2000              MOVS     r0,#0
0002c8  f88d0007          STRB     r0,[sp,#7]
;;;240    		GPIO_Init(GPIOB, &GPIO_InitStructure);	
0002cc  a901              ADD      r1,sp,#4
0002ce  483d              LDR      r0,|L2.964|
0002d0  f7fffffe          BL       GPIO_Init
;;;241    
;;;242    		/*复位ADC*/
;;;243    		ADC_DeInit(ADC2);
0002d4  483c              LDR      r0,|L2.968|
0002d6  f7fffffe          BL       ADC_DeInit
;;;244    
;;;245    		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
0002da  2000              MOVS     r0,#0
0002dc  9002              STR      r0,[sp,#8]
;;;246    		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
0002de  f88d000c          STRB     r0,[sp,#0xc]
;;;247    		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
0002e2  f88d000d          STRB     r0,[sp,#0xd]
;;;248    		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
0002e6  f44f2060          MOV      r0,#0xe0000
0002ea  9004              STR      r0,[sp,#0x10]
;;;249    		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
0002ec  2000              MOVS     r0,#0
0002ee  9005              STR      r0,[sp,#0x14]
;;;250    		ADC_InitStructure.ADC_NbrOfChannel = 1;
0002f0  2001              MOVS     r0,#1
0002f2  f88d0018          STRB     r0,[sp,#0x18]
;;;251    		ADC_Init(ADC2, &ADC_InitStructure);  
0002f6  a902              ADD      r1,sp,#8
0002f8  4833              LDR      r0,|L2.968|
0002fa  f7fffffe          BL       ADC_Init
;;;252    
;;;253    		/*使能指定的ADC*/
;;;254    		ADC_Cmd(ADC2, ENABLE);
0002fe  2101              MOVS     r1,#1
000300  4831              LDR      r0,|L2.968|
000302  f7fffffe          BL       ADC_Cmd
;;;255    		
;;;256    		/*使能复位校准 */
;;;257    		ADC_ResetCalibration(ADC2);
000306  4830              LDR      r0,|L2.968|
000308  f7fffffe          BL       ADC_ResetCalibration
;;;258    		 
;;;259    		/*等待复位校准结束*/
;;;260    		while(ADC_GetResetCalibrationStatus(ADC2));
00030c  bf00              NOP      
                  |L2.782|
00030e  482e              LDR      r0,|L2.968|
000310  f7fffffe          BL       ADC_GetResetCalibrationStatus
000314  2800              CMP      r0,#0
000316  d1fa              BNE      |L2.782|
;;;261    		
;;;262    		/*开启AD校准*/
;;;263    		ADC_StartCalibration(ADC2);
000318  482b              LDR      r0,|L2.968|
00031a  f7fffffe          BL       ADC_StartCalibration
;;;264    	 
;;;265    		/*等待校准结束*/
;;;266    		while(ADC_GetCalibrationStatus(ADC2));
00031e  bf00              NOP      
                  |L2.800|
000320  4829              LDR      r0,|L2.968|
000322  f7fffffe          BL       ADC_GetCalibrationStatus
000326  2800              CMP      r0,#0
000328  d1fa              BNE      |L2.800|
;;;267    		
;;;268    		/*ADC,ADC通道,采样时间为239.5周期*/
;;;269    		ADC_RegularChannelConfig(ADC2, ADC_Channel_8, 1, ADC_SampleTime_239Cycles5 );
00032a  2307              MOVS     r3,#7
00032c  2201              MOVS     r2,#1
00032e  2108              MOVS     r1,#8
000330  4825              LDR      r0,|L2.968|
000332  f7fffffe          BL       ADC_RegularChannelConfig
;;;270    	}
;;;271    	
;;;272    	/*充电电流*/
;;;273    	{
;;;274    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF |RCC_APB2Periph_ADC3, ENABLE );
000336  2101              MOVS     r1,#1
000338  f2480080          MOV      r0,#0x8080
00033c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;275     
;;;276    		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;277    		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
000340  f44f4000          MOV      r0,#0x8000
000344  f7fffffe          BL       RCC_ADCCLKConfig
;;;278                      
;;;279    		/*配置引脚为模拟输入模式*/
;;;280    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
000348  2040              MOVS     r0,#0x40
00034a  f8ad0004          STRH     r0,[sp,#4]
;;;281    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00034e  2000              MOVS     r0,#0
000350  f88d0007          STRB     r0,[sp,#7]
;;;282    		GPIO_Init(GPIOF, &GPIO_InitStructure);	
000354  a901              ADD      r1,sp,#4
000356  481d              LDR      r0,|L2.972|
000358  f7fffffe          BL       GPIO_Init
;;;283    
;;;284    		/*复位ADC*/
;;;285    		ADC_DeInit(ADC3);
00035c  481c              LDR      r0,|L2.976|
00035e  f7fffffe          BL       ADC_DeInit
;;;286    
;;;287    		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000362  2000              MOVS     r0,#0
000364  9002              STR      r0,[sp,#8]
;;;288    		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
000366  f88d000c          STRB     r0,[sp,#0xc]
;;;289    		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
00036a  f88d000d          STRB     r0,[sp,#0xd]
;;;290    		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
00036e  f44f2060          MOV      r0,#0xe0000
000372  9004              STR      r0,[sp,#0x10]
;;;291    		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000374  2000              MOVS     r0,#0
000376  9005              STR      r0,[sp,#0x14]
;;;292    		ADC_InitStructure.ADC_NbrOfChannel = 1;
000378  2001              MOVS     r0,#1
00037a  f88d0018          STRB     r0,[sp,#0x18]
;;;293    		ADC_Init(ADC3, &ADC_InitStructure);  
00037e  a902              ADD      r1,sp,#8
000380  4813              LDR      r0,|L2.976|
000382  f7fffffe          BL       ADC_Init
;;;294    
;;;295    		/*使能指定的ADC*/
;;;296    		ADC_Cmd(ADC3, ENABLE);
000386  2101              MOVS     r1,#1
000388  4811              LDR      r0,|L2.976|
00038a  f7fffffe          BL       ADC_Cmd
;;;297    		
;;;298    		/*使能复位校准 */
;;;299    		ADC_ResetCalibration(ADC3);
00038e  4810              LDR      r0,|L2.976|
000390  f7fffffe          BL       ADC_ResetCalibration
;;;300    		 
;;;301    		/*等待复位校准结束*/
;;;302    		while(ADC_GetResetCalibrationStatus(ADC3));
000394  bf00              NOP      
                  |L2.918|
000396  480e              LDR      r0,|L2.976|
000398  f7fffffe          BL       ADC_GetResetCalibrationStatus
00039c  2800              CMP      r0,#0
00039e  d1fa              BNE      |L2.918|
;;;303    		
;;;304    		/*开启AD校准*/
;;;305    		ADC_StartCalibration(ADC3);
0003a0  480b              LDR      r0,|L2.976|
0003a2  f7fffffe          BL       ADC_StartCalibration
;;;306    	 
;;;307    		/*等待校准结束*/
;;;308    		while(ADC_GetCalibrationStatus(ADC3));
0003a6  bf00              NOP      
                  |L2.936|
0003a8  4809              LDR      r0,|L2.976|
0003aa  f7fffffe          BL       ADC_GetCalibrationStatus
0003ae  2800              CMP      r0,#0
0003b0  d1fa              BNE      |L2.936|
;;;309    		
;;;310    		/*ADC,ADC通道,采样时间为239.5周期*/
;;;311    		ADC_RegularChannelConfig(ADC3, ADC_Channel_4, 1, ADC_SampleTime_239Cycles5 );
0003b2  2307              MOVS     r3,#7
0003b4  2201              MOVS     r2,#1
0003b6  2104              MOVS     r1,#4
0003b8  4805              LDR      r0,|L2.976|
0003ba  f7fffffe          BL       ADC_RegularChannelConfig
;;;312    	}
;;;313    	
;;;314    }
0003be  b007              ADD      sp,sp,#0x1c
0003c0  bd00              POP      {pc}
;;;315    
                          ENDP

0003c2  0000              DCW      0x0000
                  |L2.964|
                          DCD      0x40010c00
                  |L2.968|
                          DCD      0x40012800
                  |L2.972|
                          DCD      0x40011c00
                  |L2.976|
                          DCD      0x40013c00
                  |L2.980|
                          DCD      0x40011000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\src\\bsp_CurrentFeedback.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_bsp_CurrentFeedback_c_91b4e5ab____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___21_bsp_CurrentFeedback_c_91b4e5ab____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_bsp_CurrentFeedback_c_91b4e5ab____REVSH|
#line 128
|__asm___21_bsp_CurrentFeedback_c_91b4e5ab____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
