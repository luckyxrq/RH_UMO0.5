; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_motor.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_motor.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\app\inc -IF:\LuckyXRQ\CleanCar\Project\MDK-ARM(uV4)\RTE -ID:\soft\MDK5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\soft\MDK5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_motor.crf ..\..\User\app\src\bsp_motor.c]
                          THUMB

                          AREA ||i.bsp_InitMotor||, CODE, READONLY, ALIGN=1

                  bsp_InitMotor PROC
;;;32     */
;;;33     void bsp_InitMotor(void)
000000  b510              PUSH     {r4,lr}
;;;34     {
;;;35     	/*初始化PWM 20KHZ，用于驱动电机，10KHZ会有噪声*/
;;;36     	bsp_InitTimer1(3599,0); 
000002  2100              MOVS     r1,#0
000004  f640600f          MOV      r0,#0xe0f
000008  f7fffffe          BL       bsp_InitTimer1
;;;37     	bsp_InitTimer4(3599,0);
00000c  2100              MOVS     r1,#0
00000e  f640600f          MOV      r0,#0xe0f
000012  f7fffffe          BL       bsp_InitTimer4
;;;38     	bsp_InitVacuum();
000016  f7fffffe          BL       bsp_InitVacuum
;;;39     	
;;;40     }
00001a  bd10              POP      {r4,pc}
;;;41     
                          ENDP


                          AREA ||i.bsp_InitTimer1||, CODE, READONLY, ALIGN=2

                  bsp_InitTimer1 PROC
;;;219    */
;;;220    static void bsp_InitTimer1(uint16_t arr,uint16_t psc)
000000  b530              PUSH     {r4,r5,lr}
;;;221    {  
000002  b089              SUB      sp,sp,#0x24
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;222    	
;;;223    	GPIO_InitTypeDef   GPIO_InitStructure;
;;;224    	TIM_OCInitTypeDef  TIM_OCInitStructure;
;;;225    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;226    	
;;;227    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  02c8              LSLS     r0,r1,#11
00000c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;228     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE|RCC_APB2Periph_AFIO, ENABLE);
000010  2101              MOVS     r1,#1
000012  2041              MOVS     r0,#0x41
000014  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;229    	GPIO_PinRemapConfig(GPIO_FullRemap_TIM1, ENABLE); /*Timer1重映射*/     	
000018  2101              MOVS     r1,#1
00001a  4836              LDR      r0,|L2.244|
00001c  f7fffffe          BL       GPIO_PinRemapConfig
;;;230    
;;;231    	/*GPIO初始化*/
;;;232    	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_9|GPIO_Pin_11|GPIO_Pin_13|GPIO_Pin_14;
000020  f44f40d4          MOV      r0,#0x6a00
000024  f8ad0020          STRH     r0,[sp,#0x20]
;;;233    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;  //复用推挽输出
000028  2018              MOVS     r0,#0x18
00002a  f88d0023          STRB     r0,[sp,#0x23]
;;;234    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00002e  2003              MOVS     r0,#3
000030  f88d0022          STRB     r0,[sp,#0x22]
;;;235    	GPIO_Init(GPIOE, &GPIO_InitStructure);
000034  a908              ADD      r1,sp,#0x20
000036  4830              LDR      r0,|L2.248|
000038  f7fffffe          BL       GPIO_Init
;;;236    	
;;;237    	/*定时器初始化*/
;;;238    	TIM_TimeBaseStructure.TIM_Period 		= arr; 					
00003c  f8ad5008          STRH     r5,[sp,#8]
;;;239    	TIM_TimeBaseStructure.TIM_Prescaler     = psc; 					
000040  f8ad4004          STRH     r4,[sp,#4]
;;;240    	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; 		
000044  2000              MOVS     r0,#0
000046  f8ad000a          STRH     r0,[sp,#0xa]
;;;241    	TIM_TimeBaseStructure.TIM_CounterMode 	= TIM_CounterMode_Up;  	
00004a  f8ad0006          STRH     r0,[sp,#6]
;;;242    	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure); 
00004e  a901              ADD      r1,sp,#4
000050  482a              LDR      r0,|L2.252|
000052  f7fffffe          BL       TIM_TimeBaseInit
;;;243    	
;;;244    	/*
;;;245    	PWM一共有两种模式，PWM1模式：CNT<CRRx为有效电平（不包括等于）。CNT>=CRRx为无效电平。PWM2模式相反。
;;;246    	那么问题来了什么为有效电平？他又怎么确定？
;;;247    	它是由TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;输出极性来定的。
;;;248    	有效电平加输出极性就等于什么时候输出高电
;;;249    	*/ 
;;;250    	TIM_OCInitStructure.TIM_OCMode 		= TIM_OCMode_PWM1; 			
000056  2060              MOVS     r0,#0x60
000058  f8ad0010          STRH     r0,[sp,#0x10]
;;;251     	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; 	
00005c  2001              MOVS     r0,#1
00005e  f8ad0012          STRH     r0,[sp,#0x12]
;;;252    	TIM_OCInitStructure.TIM_OCPolarity  = TIM_OCPolarity_High;	
000062  2000              MOVS     r0,#0
000064  f8ad0018          STRH     r0,[sp,#0x18]
;;;253    
;;;254    	/*TIM1，TIM8必须使用，否则在RTOS中无法使用，暂时不了解原因*/
;;;255    	TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Disable;	/* only for TIM1 and TIM8. */	
000068  f8ad0014          STRH     r0,[sp,#0x14]
;;;256    	TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;			/* only for TIM1 and TIM8. */		
00006c  f8ad001a          STRH     r0,[sp,#0x1a]
;;;257    	TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Reset;		/* only for TIM1 and TIM8. */
000070  f8ad001c          STRH     r0,[sp,#0x1c]
;;;258    	TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCNIdleState_Reset;		/* only for TIM1 and TIM8. */
000074  f8ad001e          STRH     r0,[sp,#0x1e]
;;;259    	
;;;260    	/*CH1*/
;;;261    	TIM_OC1Init(TIM1, &TIM_OCInitStructure);	 
000078  a904              ADD      r1,sp,#0x10
00007a  4820              LDR      r0,|L2.252|
00007c  f7fffffe          BL       TIM_OC1Init
;;;262    	TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);
000080  2108              MOVS     r1,#8
000082  481e              LDR      r0,|L2.252|
000084  f7fffffe          BL       TIM_OC1PreloadConfig
;;;263    	
;;;264    	/*CH2*/
;;;265    	TIM_OC2Init(TIM1, &TIM_OCInitStructure); 
000088  a904              ADD      r1,sp,#0x10
00008a  481c              LDR      r0,|L2.252|
00008c  f7fffffe          BL       TIM_OC2Init
;;;266    	TIM_OC2PreloadConfig(TIM1, TIM_OCPreload_Enable);
000090  2108              MOVS     r1,#8
000092  481a              LDR      r0,|L2.252|
000094  f7fffffe          BL       TIM_OC2PreloadConfig
;;;267    	
;;;268    	/*CH3*/
;;;269    	TIM_OC3Init(TIM1, &TIM_OCInitStructure);	 
000098  a904              ADD      r1,sp,#0x10
00009a  4818              LDR      r0,|L2.252|
00009c  f7fffffe          BL       TIM_OC3Init
;;;270    	TIM_OC3PreloadConfig(TIM1, TIM_OCPreload_Enable);
0000a0  2108              MOVS     r1,#8
0000a2  4816              LDR      r0,|L2.252|
0000a4  f7fffffe          BL       TIM_OC3PreloadConfig
;;;271    	
;;;272    	/*CH4*/
;;;273    	TIM_OC4Init(TIM1, &TIM_OCInitStructure);	 
0000a8  a904              ADD      r1,sp,#0x10
0000aa  4814              LDR      r0,|L2.252|
0000ac  f7fffffe          BL       TIM_OC4Init
;;;274    	TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Enable);
0000b0  2108              MOVS     r1,#8
0000b2  4812              LDR      r0,|L2.252|
0000b4  f7fffffe          BL       TIM_OC4PreloadConfig
;;;275      
;;;276    	/*使能TIM1*/
;;;277    	TIM_Cmd(TIM1, ENABLE); 
0000b8  2101              MOVS     r1,#1
0000ba  4810              LDR      r0,|L2.252|
0000bc  f7fffffe          BL       TIM_Cmd
;;;278    	
;;;279    	/*TIM1，TIM8必须使用，其他定时器可使用或不使用*/
;;;280    	TIM_CtrlPWMOutputs(TIM1,ENABLE);
0000c0  2101              MOVS     r1,#1
0000c2  480e              LDR      r0,|L2.252|
0000c4  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;281    	
;;;282    	/*4个通道全部输出高电平*/
;;;283    	TIM_SetCompare1(TIM1,CONSTANT_HIGH_PWM);
0000c8  f44f6161          MOV      r1,#0xe10
0000cc  480b              LDR      r0,|L2.252|
0000ce  f7fffffe          BL       TIM_SetCompare1
;;;284    	TIM_SetCompare2(TIM1,CONSTANT_HIGH_PWM);
0000d2  f44f6161          MOV      r1,#0xe10
0000d6  4809              LDR      r0,|L2.252|
0000d8  f7fffffe          BL       TIM_SetCompare2
;;;285    	TIM_SetCompare3(TIM1,CONSTANT_HIGH_PWM);
0000dc  f44f6161          MOV      r1,#0xe10
0000e0  4806              LDR      r0,|L2.252|
0000e2  f7fffffe          BL       TIM_SetCompare3
;;;286    	TIM_SetCompare4(TIM1,CONSTANT_HIGH_PWM);
0000e6  f44f6161          MOV      r1,#0xe10
0000ea  4804              LDR      r0,|L2.252|
0000ec  f7fffffe          BL       TIM_SetCompare4
;;;287    	
;;;288    }
0000f0  b009              ADD      sp,sp,#0x24
0000f2  bd30              POP      {r4,r5,pc}
;;;289    
                          ENDP

                  |L2.244|
                          DCD      0x001600c0
                  |L2.248|
                          DCD      0x40011800
                  |L2.252|
                          DCD      0x40012c00

                          AREA ||i.bsp_InitTimer4||, CODE, READONLY, ALIGN=2

                  bsp_InitTimer4 PROC
;;;298    */
;;;299    static void bsp_InitTimer4(uint16_t arr,uint16_t psc)
000000  b530              PUSH     {r4,r5,lr}
;;;300    {  
000002  b089              SUB      sp,sp,#0x24
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;301    	
;;;302    	GPIO_InitTypeDef   GPIO_InitStructure;
;;;303    	TIM_OCInitTypeDef  TIM_OCInitStructure;
;;;304    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;305    	
;;;306    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
000008  2101              MOVS     r1,#1
00000a  2004              MOVS     r0,#4
00000c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;307     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD|RCC_APB2Periph_AFIO, ENABLE);
000010  2101              MOVS     r1,#1
000012  2021              MOVS     r0,#0x21
000014  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;308    	GPIO_PinRemapConfig(GPIO_Remap_TIM4, ENABLE); /*Timer1重映射*/     	
000018  2101              MOVS     r1,#1
00001a  0308              LSLS     r0,r1,#12
00001c  f7fffffe          BL       GPIO_PinRemapConfig
;;;309    
;;;310    	/*GPIO初始化*/
;;;311    	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_12 | GPIO_Pin_13 |GPIO_Pin_14 | GPIO_Pin_15;
000020  f44f4070          MOV      r0,#0xf000
000024  f8ad0020          STRH     r0,[sp,#0x20]
;;;312    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;  //复用推挽输出
000028  2018              MOVS     r0,#0x18
00002a  f88d0023          STRB     r0,[sp,#0x23]
;;;313    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00002e  2003              MOVS     r0,#3
000030  f88d0022          STRB     r0,[sp,#0x22]
;;;314    	GPIO_Init(GPIOD, &GPIO_InitStructure);
000034  a908              ADD      r1,sp,#0x20
000036  482b              LDR      r0,|L3.228|
000038  f7fffffe          BL       GPIO_Init
;;;315    	
;;;316    	/*定时器初始化*/
;;;317    	TIM_TimeBaseStructure.TIM_Period 		= arr; 					
00003c  f8ad5008          STRH     r5,[sp,#8]
;;;318    	TIM_TimeBaseStructure.TIM_Prescaler     = psc; 					
000040  f8ad4004          STRH     r4,[sp,#4]
;;;319    	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; 		
000044  2000              MOVS     r0,#0
000046  f8ad000a          STRH     r0,[sp,#0xa]
;;;320    	TIM_TimeBaseStructure.TIM_CounterMode 	= TIM_CounterMode_Up;  	
00004a  f8ad0006          STRH     r0,[sp,#6]
;;;321    	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure); 
00004e  a901              ADD      r1,sp,#4
000050  4825              LDR      r0,|L3.232|
000052  f7fffffe          BL       TIM_TimeBaseInit
;;;322    	
;;;323    	/*
;;;324    	PWM一共有两种模式，PWM1模式：CNT<CRRx为有效电平（不包括等于）。CNT>=CRRx为无效电平。PWM2模式相反。
;;;325    	那么问题来了什么为有效电平？他又怎么确定？
;;;326    	它是由TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;输出极性来定的。
;;;327    	有效电平加输出极性就等于什么时候输出高电
;;;328    	*/ 
;;;329    	TIM_OCInitStructure.TIM_OCMode 		= TIM_OCMode_PWM1; 			
000056  2060              MOVS     r0,#0x60
000058  f8ad0010          STRH     r0,[sp,#0x10]
;;;330     	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; 	
00005c  2001              MOVS     r0,#1
00005e  f8ad0012          STRH     r0,[sp,#0x12]
;;;331    	TIM_OCInitStructure.TIM_OCPolarity  = TIM_OCPolarity_High;	
000062  2000              MOVS     r0,#0
000064  f8ad0018          STRH     r0,[sp,#0x18]
;;;332    
;;;333    	/*TIM1，TIM8必须使用，否则在RTOS中无法使用，暂时不了解原因*/
;;;334    	#if 0
;;;335    	TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Disable;	/* only for TIM1 and TIM8. */	
;;;336    	TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;			/* only for TIM1 and TIM8. */		
;;;337    	TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Reset;		/* only for TIM1 and TIM8. */
;;;338    	TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCNIdleState_Reset;		/* only for TIM1 and TIM8. */
;;;339    	#endif
;;;340    	
;;;341    	/*CH1*/
;;;342    	TIM_OC1Init(TIM4, &TIM_OCInitStructure);	 
000068  a904              ADD      r1,sp,#0x10
00006a  481f              LDR      r0,|L3.232|
00006c  f7fffffe          BL       TIM_OC1Init
;;;343    	TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Enable);
000070  2108              MOVS     r1,#8
000072  481d              LDR      r0,|L3.232|
000074  f7fffffe          BL       TIM_OC1PreloadConfig
;;;344    	
;;;345    	/*CH2*/
;;;346    	TIM_OC2Init(TIM4, &TIM_OCInitStructure); 
000078  a904              ADD      r1,sp,#0x10
00007a  481b              LDR      r0,|L3.232|
00007c  f7fffffe          BL       TIM_OC2Init
;;;347    	TIM_OC2PreloadConfig(TIM4, TIM_OCPreload_Enable);
000080  2108              MOVS     r1,#8
000082  4819              LDR      r0,|L3.232|
000084  f7fffffe          BL       TIM_OC2PreloadConfig
;;;348    	
;;;349    	/*CH3*/
;;;350    	TIM_OC3Init(TIM4, &TIM_OCInitStructure);	 
000088  a904              ADD      r1,sp,#0x10
00008a  4817              LDR      r0,|L3.232|
00008c  f7fffffe          BL       TIM_OC3Init
;;;351    	TIM_OC3PreloadConfig(TIM4, TIM_OCPreload_Enable);
000090  2108              MOVS     r1,#8
000092  4815              LDR      r0,|L3.232|
000094  f7fffffe          BL       TIM_OC3PreloadConfig
;;;352    	
;;;353    	/*CH4*/
;;;354    	TIM_OC4Init(TIM4, &TIM_OCInitStructure);	 
000098  a904              ADD      r1,sp,#0x10
00009a  4813              LDR      r0,|L3.232|
00009c  f7fffffe          BL       TIM_OC4Init
;;;355    	TIM_OC4PreloadConfig(TIM4, TIM_OCPreload_Enable);
0000a0  2108              MOVS     r1,#8
0000a2  4811              LDR      r0,|L3.232|
0000a4  f7fffffe          BL       TIM_OC4PreloadConfig
;;;356      
;;;357    	/*使能TIM*/
;;;358    	TIM_Cmd(TIM4, ENABLE); 
0000a8  2101              MOVS     r1,#1
0000aa  480f              LDR      r0,|L3.232|
0000ac  f7fffffe          BL       TIM_Cmd
;;;359    	
;;;360    	/*TIM1，TIM8必须使用，其他定时器可使用或不使用*/
;;;361    	TIM_CtrlPWMOutputs(TIM4,ENABLE);
0000b0  2101              MOVS     r1,#1
0000b2  480d              LDR      r0,|L3.232|
0000b4  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;362    	
;;;363    	/*4个通道全部输出高电平*/
;;;364    	TIM_SetCompare1(TIM4,CONSTANT_HIGH_PWM);
0000b8  f44f6161          MOV      r1,#0xe10
0000bc  480a              LDR      r0,|L3.232|
0000be  f7fffffe          BL       TIM_SetCompare1
;;;365    	TIM_SetCompare2(TIM4,CONSTANT_HIGH_PWM);
0000c2  f44f6161          MOV      r1,#0xe10
0000c6  4808              LDR      r0,|L3.232|
0000c8  f7fffffe          BL       TIM_SetCompare2
;;;366    	TIM_SetCompare3(TIM4,CONSTANT_HIGH_PWM);
0000cc  f44f6161          MOV      r1,#0xe10
0000d0  4805              LDR      r0,|L3.232|
0000d2  f7fffffe          BL       TIM_SetCompare3
;;;367    	TIM_SetCompare4(TIM4,CONSTANT_HIGH_PWM);
0000d6  f44f6161          MOV      r1,#0xe10
0000da  4803              LDR      r0,|L3.232|
0000dc  f7fffffe          BL       TIM_SetCompare4
;;;368    	
;;;369    }
0000e0  b009              ADD      sp,sp,#0x24
0000e2  bd30              POP      {r4,r5,pc}
;;;370    
                          ENDP

                  |L3.228|
                          DCD      0x40011400
                  |L3.232|
                          DCD      0x40000800

                          AREA ||i.bsp_InitVacuum||, CODE, READONLY, ALIGN=2

                  bsp_InitVacuum PROC
;;;135    */
;;;136    static void bsp_InitVacuum(void)
000000  b508              PUSH     {r3,lr}
;;;137    {
;;;138    	GPIO_InitTypeDef GPIO_InitStructure;
;;;139    
;;;140    	/* 打开GPIO时钟 */
;;;141    	RCC_APB2PeriphClockCmd(RCC_ALL_VACUUM, ENABLE);
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;142    
;;;143    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;144    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;145    	
;;;146    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_VACUUM;
000016  2001              MOVS     r0,#1
000018  f8ad0000          STRH     r0,[sp,#0]
;;;147    	GPIO_Init(GPIO_PORT_VACUUM, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4804              LDR      r0,|L4.48|
000020  f7fffffe          BL       GPIO_Init
;;;148    	
;;;149    	GPIO_ResetBits(GPIO_PORT_VACUUM,GPIO_PIN_VACUUM);
000024  2101              MOVS     r1,#1
000026  4802              LDR      r0,|L4.48|
000028  f7fffffe          BL       GPIO_ResetBits
;;;150    }
00002c  bd08              POP      {r3,pc}
;;;151    
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      0x40010800

                          AREA ||i.bsp_MotorCleanSetPWM||, CODE, READONLY, ALIGN=2

                  bsp_MotorCleanSetPWM PROC
;;;91     */
;;;92     void bsp_MotorCleanSetPWM(MotorCleanSN sn, MotorCleanDir dir , uint16_t pwm)
000000  b570              PUSH     {r4-r6,lr}
;;;93     {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;94     	switch(sn)
000008  b116              CBZ      r6,|L5.16|
00000a  2e01              CMP      r6,#1
00000c  d126              BNE      |L5.92|
00000e  e012              B        |L5.54|
                  |L5.16|
;;;95     	{
;;;96     		case MotorRollingBrush:
;;;97     		{
;;;98     			if(dir == CW)
000010  b944              CBNZ     r4,|L5.36|
;;;99     			{
;;;100    				TIM_SetCompare1(TIM4,0);
000012  2100              MOVS     r1,#0
000014  4812              LDR      r0,|L5.96|
000016  f7fffffe          BL       TIM_SetCompare1
;;;101    				TIM_SetCompare2(TIM4,pwm);
00001a  4629              MOV      r1,r5
00001c  4810              LDR      r0,|L5.96|
00001e  f7fffffe          BL       TIM_SetCompare2
000022  e007              B        |L5.52|
                  |L5.36|
;;;102    			}
;;;103    			else
;;;104    			{
;;;105    				TIM_SetCompare1(TIM4,pwm);
000024  4629              MOV      r1,r5
000026  480e              LDR      r0,|L5.96|
000028  f7fffffe          BL       TIM_SetCompare1
;;;106    				TIM_SetCompare2(TIM4,0);
00002c  2100              MOVS     r1,#0
00002e  480c              LDR      r0,|L5.96|
000030  f7fffffe          BL       TIM_SetCompare2
                  |L5.52|
;;;107    			}
;;;108    		}break;
000034  e012              B        |L5.92|
                  |L5.54|
;;;109    		
;;;110    		case MotorSideBrush:
;;;111    		{
;;;112    			if(dir == CW)
000036  b944              CBNZ     r4,|L5.74|
;;;113    			{
;;;114    				TIM_SetCompare3(TIM4,0);
000038  2100              MOVS     r1,#0
00003a  4809              LDR      r0,|L5.96|
00003c  f7fffffe          BL       TIM_SetCompare3
;;;115    				TIM_SetCompare4(TIM4,pwm);
000040  4629              MOV      r1,r5
000042  4807              LDR      r0,|L5.96|
000044  f7fffffe          BL       TIM_SetCompare4
000048  e007              B        |L5.90|
                  |L5.74|
;;;116    			}
;;;117    			else
;;;118    			{
;;;119    				TIM_SetCompare3(TIM4,pwm);
00004a  4629              MOV      r1,r5
00004c  4804              LDR      r0,|L5.96|
00004e  f7fffffe          BL       TIM_SetCompare3
;;;120    				TIM_SetCompare4(TIM4,0);
000052  2100              MOVS     r1,#0
000054  4802              LDR      r0,|L5.96|
000056  f7fffffe          BL       TIM_SetCompare4
                  |L5.90|
;;;121    			}
;;;122    		}break;
00005a  bf00              NOP      
                  |L5.92|
00005c  bf00              NOP                            ;108
;;;123    
;;;124    	}
;;;125    }
00005e  bd70              POP      {r4-r6,pc}
;;;126    
                          ENDP

                  |L5.96|
                          DCD      0x40000800

                          AREA ||i.bsp_MotorSetPWM||, CODE, READONLY, ALIGN=2

                  bsp_MotorSetPWM PROC
;;;49     */
;;;50     void bsp_MotorSetPWM(MotorSN sn ,MotorDir dir,uint16_t pwm)
000000  b570              PUSH     {r4-r6,lr}
;;;51     {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;52     	switch(sn)
000008  b116              CBZ      r6,|L6.16|
00000a  2e01              CMP      r6,#1
00000c  d126              BNE      |L6.92|
00000e  e012              B        |L6.54|
                  |L6.16|
;;;53     	{
;;;54     		case MotorLeft:
;;;55     		{
;;;56     			if(dir == Forward)
000010  b944              CBNZ     r4,|L6.36|
;;;57     			{
;;;58     				TIM_SetCompare3(TIM1,0);
000012  2100              MOVS     r1,#0
000014  4812              LDR      r0,|L6.96|
000016  f7fffffe          BL       TIM_SetCompare3
;;;59     				TIM_SetCompare4(TIM1,pwm);
00001a  4629              MOV      r1,r5
00001c  4810              LDR      r0,|L6.96|
00001e  f7fffffe          BL       TIM_SetCompare4
000022  e007              B        |L6.52|
                  |L6.36|
;;;60     			}
;;;61     			else
;;;62     			{
;;;63     				TIM_SetCompare3(TIM1,pwm);
000024  4629              MOV      r1,r5
000026  480e              LDR      r0,|L6.96|
000028  f7fffffe          BL       TIM_SetCompare3
;;;64     				TIM_SetCompare4(TIM1,0);
00002c  2100              MOVS     r1,#0
00002e  480c              LDR      r0,|L6.96|
000030  f7fffffe          BL       TIM_SetCompare4
                  |L6.52|
;;;65     			}
;;;66     		}break;
000034  e012              B        |L6.92|
                  |L6.54|
;;;67     		
;;;68     		case MotorRight:
;;;69     		{
;;;70     			if(dir != Forward)
000036  b144              CBZ      r4,|L6.74|
;;;71     			{
;;;72     				TIM_SetCompare1(TIM1,0);
000038  2100              MOVS     r1,#0
00003a  4809              LDR      r0,|L6.96|
00003c  f7fffffe          BL       TIM_SetCompare1
;;;73     				TIM_SetCompare2(TIM1,pwm);
000040  4629              MOV      r1,r5
000042  4807              LDR      r0,|L6.96|
000044  f7fffffe          BL       TIM_SetCompare2
000048  e007              B        |L6.90|
                  |L6.74|
;;;74     			}
;;;75     			else
;;;76     			{
;;;77     				TIM_SetCompare1(TIM1,pwm);
00004a  4629              MOV      r1,r5
00004c  4804              LDR      r0,|L6.96|
00004e  f7fffffe          BL       TIM_SetCompare1
;;;78     				TIM_SetCompare2(TIM1,0);
000052  2100              MOVS     r1,#0
000054  4802              LDR      r0,|L6.96|
000056  f7fffffe          BL       TIM_SetCompare2
                  |L6.90|
;;;79     			}
;;;80     		}break;
00005a  bf00              NOP      
                  |L6.92|
00005c  bf00              NOP                            ;66
;;;81     	}
;;;82     }
00005e  bd70              POP      {r4-r6,pc}
;;;83     
                          ENDP

                  |L6.96|
                          DCD      0x40012c00

                          AREA ||i.bsp_StartVacuum||, CODE, READONLY, ALIGN=2

                  bsp_StartVacuum PROC
;;;188    */
;;;189    void bsp_StartVacuum(void)
000000  2000              MOVS     r0,#0
;;;190    {
;;;191    	vacuum.tick = 0 ;
000002  4902              LDR      r1,|L7.12|
000004  6048              STR      r0,[r1,#4]  ; vacuum
;;;192    	vacuum.isRunning = true;
000006  2001              MOVS     r0,#1
000008  7008              STRB     r0,[r1,#0]
;;;193    }
00000a  4770              BX       lr
;;;194    
                          ENDP

                  |L7.12|
                          DCD      vacuum

                          AREA ||i.bsp_StopVacuum||, CODE, READONLY, ALIGN=2

                  bsp_StopVacuum PROC
;;;202    */
;;;203    void bsp_StopVacuum(void)
000000  b510              PUSH     {r4,lr}
;;;204    {
;;;205    	vacuum.isRunning = false;
000002  2000              MOVS     r0,#0
000004  4903              LDR      r1,|L8.20|
000006  7008              STRB     r0,[r1,#0]
;;;206    	vacuum.tick = 0 ;
000008  6048              STR      r0,[r1,#4]  ; vacuum
;;;207    	
;;;208    	GPIO_ResetBits(GPIO_PORT_VACUUM,GPIO_PIN_VACUUM);
00000a  2101              MOVS     r1,#1
00000c  4802              LDR      r0,|L8.24|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;209    }
000012  bd10              POP      {r4,pc}
;;;210    
                          ENDP

                  |L8.20|
                          DCD      vacuum
                  |L8.24|
                          DCD      0x40010800

                          AREA ||i.bsp_VacuumClean||, CODE, READONLY, ALIGN=2

                  bsp_VacuumClean PROC
;;;159    */
;;;160    void bsp_VacuumClean(void)
000000  b510              PUSH     {r4,lr}
;;;161    {	
;;;162    	if(!vacuum.isRunning)
000002  4812              LDR      r0,|L9.76|
000004  7800              LDRB     r0,[r0,#0]  ; vacuum
000006  b900              CBNZ     r0,|L9.10|
                  |L9.8|
;;;163    		return ;
;;;164    	
;;;165    	++vacuum.tick;
;;;166    	
;;;167    	if(vacuum.tick <= 20)
;;;168    	{
;;;169    		GPIO_SetBits(GPIOA,GPIO_Pin_0);
;;;170    	}
;;;171    	else if(vacuum.tick > 20 && vacuum.tick <=40)
;;;172    	{
;;;173    		GPIO_ResetBits(GPIOA,GPIO_Pin_0);
;;;174    	}
;;;175    	else
;;;176    	{
;;;177    		vacuum.tick = 0 ;
;;;178    	}
;;;179    }
000008  bd10              POP      {r4,pc}
                  |L9.10|
00000a  4810              LDR      r0,|L9.76|
00000c  6840              LDR      r0,[r0,#4]            ;165  ; vacuum
00000e  1c40              ADDS     r0,r0,#1              ;165
000010  490e              LDR      r1,|L9.76|
000012  6048              STR      r0,[r1,#4]            ;165  ; vacuum
000014  4608              MOV      r0,r1                 ;167
000016  6840              LDR      r0,[r0,#4]            ;167  ; vacuum
000018  2814              CMP      r0,#0x14              ;167
00001a  d804              BHI      |L9.38|
00001c  2101              MOVS     r1,#1                 ;169
00001e  480c              LDR      r0,|L9.80|
000020  f7fffffe          BL       GPIO_SetBits
000024  e00f              B        |L9.70|
                  |L9.38|
000026  4809              LDR      r0,|L9.76|
000028  6840              LDR      r0,[r0,#4]            ;171  ; vacuum
00002a  2814              CMP      r0,#0x14              ;171
00002c  d908              BLS      |L9.64|
00002e  4807              LDR      r0,|L9.76|
000030  6840              LDR      r0,[r0,#4]            ;171  ; vacuum
000032  2828              CMP      r0,#0x28              ;171
000034  d804              BHI      |L9.64|
000036  2101              MOVS     r1,#1                 ;173
000038  4805              LDR      r0,|L9.80|
00003a  f7fffffe          BL       GPIO_ResetBits
00003e  e002              B        |L9.70|
                  |L9.64|
000040  2000              MOVS     r0,#0                 ;177
000042  4902              LDR      r1,|L9.76|
000044  6048              STR      r0,[r1,#4]            ;177  ; vacuum
                  |L9.70|
000046  bf00              NOP      
000048  e7de              B        |L9.8|
;;;180    
                          ENDP

00004a  0000              DCW      0x0000
                  |L9.76|
                          DCD      vacuum
                  |L9.80|
                          DCD      0x40010800

                          AREA ||.data||, DATA, ALIGN=2

                  vacuum
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\src\\bsp_motor.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_motor_c_714f68c8____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_bsp_motor_c_714f68c8____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_motor_c_714f68c8____REVSH|
#line 128
|__asm___11_bsp_motor_c_714f68c8____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
