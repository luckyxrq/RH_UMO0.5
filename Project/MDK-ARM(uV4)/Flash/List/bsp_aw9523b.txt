; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_aw9523b.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_aw9523b.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\app\inc -IF:\LuckyXRQ\BAK\CleanCar\Project\MDK-ARM(uV4)\RTE -ID:\soft\MDK5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\soft\MDK5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_aw9523b.crf ..\..\User\app\src\bsp_aw9523b.c]
                          THUMB

                          AREA ||i.aw_ReadBytes||, CODE, READONLY, ALIGN=1

                  aw_ReadBytes PROC
;;;205    */
;;;206    uint8_t aw_ReadBytes(uint8_t *_pReadBuf, uint16_t _usAddress, uint16_t _usSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;207    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;208    	uint16_t i;
;;;209    
;;;210    	/* 采用串行EEPROM随即读取指令序列，连续读取若干字节 */
;;;211    
;;;212    	/* 第1步：发起I2C总线启动信号 */
;;;213    	i2c_Start();
00000a  f7fffffe          BL       i2c_Start
;;;214    
;;;215    	/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;216    	i2c_SendByte(AW_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
00000e  20b6              MOVS     r0,#0xb6
000010  f7fffffe          BL       i2c_SendByte
;;;217    
;;;218    	/* 第3步：发送ACK */
;;;219    	if (i2c_WaitAck() != 0)
000014  f7fffffe          BL       i2c_WaitAck
000018  b100              CBZ      r0,|L1.28|
;;;220    	{
;;;221    		goto cmd_fail;	/* EEPROM器件无应答 */
00001a  e025              B        |L1.104|
                  |L1.28|
;;;222    	}
;;;223    
;;;224    	/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;225    	if (AW_ADDR_BYTES == 1)
;;;226    	{
;;;227    		i2c_SendByte((uint8_t)_usAddress);
00001c  b2f8              UXTB     r0,r7
00001e  f7fffffe          BL       i2c_SendByte
;;;228    		if (i2c_WaitAck() != 0)
000022  f7fffffe          BL       i2c_WaitAck
000026  b100              CBZ      r0,|L1.42|
;;;229    		{
;;;230    			goto cmd_fail;	/* EEPROM器件无应答 */
000028  e01e              B        |L1.104|
                  |L1.42|
;;;231    		}
;;;232    	}
;;;233    	else
;;;234    	{
;;;235    		i2c_SendByte(_usAddress >> 8);
;;;236    		if (i2c_WaitAck() != 0)
;;;237    		{
;;;238    			goto cmd_fail;	/* EEPROM器件无应答 */
;;;239    		}
;;;240    
;;;241    		i2c_SendByte(_usAddress);
;;;242    		if (i2c_WaitAck() != 0)
;;;243    		{
;;;244    			goto cmd_fail;	/* EEPROM器件无应答 */
;;;245    		}
;;;246    	}
;;;247    
;;;248    	/* 第6步：重新启动I2C总线。下面开始读取数据 */
;;;249    	i2c_Start();
00002a  f7fffffe          BL       i2c_Start
;;;250    
;;;251    	/* 第7步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;252    	i2c_SendByte(AW_DEV_ADDR | I2C_RD);	/* 此处是读指令 */
00002e  20b7              MOVS     r0,#0xb7
000030  f7fffffe          BL       i2c_SendByte
;;;253    
;;;254    	/* 第8步：发送ACK */
;;;255    	if (i2c_WaitAck() != 0)
000034  f7fffffe          BL       i2c_WaitAck
000038  b100              CBZ      r0,|L1.60|
;;;256    	{
;;;257    		goto cmd_fail;	/* EEPROM器件无应答 */
00003a  e015              B        |L1.104|
                  |L1.60|
;;;258    	}
;;;259    
;;;260    	/* 第9步：循环读取数据 */
;;;261    	for (i = 0; i < _usSize; i++)
00003c  2400              MOVS     r4,#0
00003e  e00c              B        |L1.90|
                  |L1.64|
;;;262    	{
;;;263    		_pReadBuf[i] = i2c_ReadByte();	/* 读1个字节 */
000040  f7fffffe          BL       i2c_ReadByte
000044  5530              STRB     r0,[r6,r4]
;;;264    
;;;265    		/* 每读完1个字节后，需要发送Ack， 最后一个字节不需要Ack，发Nack */
;;;266    		if (i != _usSize - 1)
000046  1e68              SUBS     r0,r5,#1
000048  42a0              CMP      r0,r4
00004a  d002              BEQ      |L1.82|
;;;267    		{
;;;268    			i2c_Ack();	/* 中间字节读完后，CPU产生ACK信号(驱动SDA = 0) */
00004c  f7fffffe          BL       i2c_Ack
000050  e001              B        |L1.86|
                  |L1.82|
;;;269    		}
;;;270    		else
;;;271    		{
;;;272    			i2c_NAck();	/* 最后1个字节读完后，CPU产生NACK信号(驱动SDA = 1) */
000052  f7fffffe          BL       i2c_NAck
                  |L1.86|
000056  1c60              ADDS     r0,r4,#1              ;261
000058  b284              UXTH     r4,r0                 ;261
                  |L1.90|
00005a  42ac              CMP      r4,r5                 ;261
00005c  dbf0              BLT      |L1.64|
;;;273    		}
;;;274    	}
;;;275    	/* 发送I2C总线停止信号 */
;;;276    	i2c_Stop();
00005e  f7fffffe          BL       i2c_Stop
;;;277    	return 1;	/* 执行成功 */
000062  2001              MOVS     r0,#1
                  |L1.100|
;;;278    
;;;279    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;280    	/* 发送I2C总线停止信号 */
;;;281    	i2c_Stop();
;;;282    	return 0;
;;;283    }
000064  e8bd81f0          POP      {r4-r8,pc}
                  |L1.104|
000068  f7fffffe          BL       i2c_Stop
00006c  2000              MOVS     r0,#0                 ;282
00006e  e7f9              B        |L1.100|
;;;284    
                          ENDP


                          AREA ||i.aw_WriteBytes||, CODE, READONLY, ALIGN=1

                  aw_WriteBytes PROC
;;;294    */
;;;295    uint8_t aw_WriteBytes(uint8_t *_pWriteBuf, uint16_t _usAddress, uint16_t _usSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;296    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;297    	uint16_t i = 0 ;
00000a  2400              MOVS     r4,#0
;;;298    	uint16_t usAddr = _usAddress;
00000c  46b0              MOV      r8,r6
;;;299    	
;;;300    	for(i=0;i<_usSize;i++)
00000e  bf00              NOP      
000010  e01f              B        |L2.82|
                  |L2.18|
;;;301    	{
;;;302    		/* 第1步：发起I2C总线启动信号 */
;;;303    		i2c_Start();
000012  f7fffffe          BL       i2c_Start
;;;304    
;;;305    		/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;306    		i2c_SendByte(AW_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
000016  20b6              MOVS     r0,#0xb6
000018  f7fffffe          BL       i2c_SendByte
;;;307    
;;;308    		/* 第3步：发送一个时钟，判断器件是否正确应答 */
;;;309    		if (i2c_WaitAck() != 0)
00001c  f7fffffe          BL       i2c_WaitAck
000020  b100              CBZ      r0,|L2.36|
;;;310    		{
;;;311    			goto cmd_fail;	/* EEPROM器件无应答 */
000022  e01b              B        |L2.92|
                  |L2.36|
;;;312    		}
;;;313    		/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;314    		if (AW_ADDR_BYTES == 1)
;;;315    		{
;;;316    			i2c_SendByte((uint8_t)usAddr);
000024  f00800ff          AND      r0,r8,#0xff
000028  f7fffffe          BL       i2c_SendByte
;;;317    			if (i2c_WaitAck() != 0)
00002c  f7fffffe          BL       i2c_WaitAck
000030  b100              CBZ      r0,|L2.52|
;;;318    			{
;;;319    				goto cmd_fail;	/* EEPROM器件无应答 */
000032  e013              B        |L2.92|
                  |L2.52|
;;;320    			}
;;;321    		}
;;;322    		else
;;;323    		{
;;;324    			i2c_SendByte(usAddr >> 8);
;;;325    			if (i2c_WaitAck() != 0)
;;;326    			{
;;;327    				goto cmd_fail;	/* EEPROM器件无应答 */
;;;328    			}
;;;329    
;;;330    			i2c_SendByte(usAddr);
;;;331    			if (i2c_WaitAck() != 0)
;;;332    			{
;;;333    				goto cmd_fail;	/* EEPROM器件无应答 */
;;;334    			}
;;;335    		}
;;;336    
;;;337    		/* 第6步：开始写入数据 */
;;;338    		i2c_SendByte(_pWriteBuf[i]);
000034  5d28              LDRB     r0,[r5,r4]
000036  f7fffffe          BL       i2c_SendByte
;;;339    
;;;340    		/* 第7步：发送ACK */
;;;341    		if (i2c_WaitAck() != 0)
00003a  f7fffffe          BL       i2c_WaitAck
00003e  b100              CBZ      r0,|L2.66|
;;;342    		{
;;;343    			goto cmd_fail;	/* EEPROM器件无应答 */
000040  e00c              B        |L2.92|
                  |L2.66|
;;;344    		}
;;;345    		
;;;346    		/* 命令执行成功，发送I2C总线停止信号 */
;;;347    		i2c_Stop();
000042  f7fffffe          BL       i2c_Stop
;;;348    		usAddr++;	/* 地址增1 */
000046  f1080001          ADD      r0,r8,#1
00004a  fa1ff880          UXTH     r8,r0
00004e  1c60              ADDS     r0,r4,#1              ;300
000050  b284              UXTH     r4,r0                 ;300
                  |L2.82|
000052  42bc              CMP      r4,r7                 ;300
000054  dbdd              BLT      |L2.18|
;;;349    		
;;;350    	}
;;;351    	
;;;352    	return 1;
000056  2001              MOVS     r0,#1
                  |L2.88|
;;;353    
;;;354    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;355    	/* 发送I2C总线停止信号 */
;;;356    	i2c_Stop();
;;;357    	return 0;
;;;358    }
000058  e8bd81f0          POP      {r4-r8,pc}
                  |L2.92|
00005c  f7fffffe          BL       i2c_Stop
000060  2000              MOVS     r0,#0                 ;357
000062  e7f9              B        |L2.88|
;;;359    
                          ENDP


                          AREA ||i.bsp_AWReadID||, CODE, READONLY, ALIGN=1

                  bsp_AWReadID PROC
;;;49     */
;;;50     uint8_t bsp_AWReadID(void)
000000  b508              PUSH     {r3,lr}
;;;51     {
;;;52     	uint8_t id = 0 ;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;53     	
;;;54     	aw_ReadBytes(&id, AW_ID , 1);
000006  2201              MOVS     r2,#1
000008  2110              MOVS     r1,#0x10
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       aw_ReadBytes
;;;55     	
;;;56     	return id;
000010  f89d0000          LDRB     r0,[sp,#0]
;;;57     }
000014  bd08              POP      {r3,pc}
;;;58     
                          ENDP


                          AREA ||i.bsp_AWReadReg||, CODE, READONLY, ALIGN=1

                  bsp_AWReadReg PROC
;;;67     */
;;;68     uint8_t bsp_AWReadReg(ADDR addr)
000000  b538              PUSH     {r3-r5,lr}
;;;69     {
000002  4604              MOV      r4,r0
;;;70     	uint8_t data = 0 ;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;71     	
;;;72     	aw_ReadBytes(&data, addr , 1);
000008  2201              MOVS     r2,#1
00000a  4621              MOV      r1,r4
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       aw_ReadBytes
;;;73     	
;;;74     	return data;
000012  f89d0000          LDRB     r0,[sp,#0]
;;;75     }
000016  bd38              POP      {r3-r5,pc}
;;;76     
                          ENDP


                          AREA ||i.bsp_AWSetPinVal||, CODE, READONLY, ALIGN=2

                  bsp_AWSetPinVal PROC
;;;77     
;;;78     void bsp_AWSetPinVal(AW_PIN pin,AW_VAL val)
000000  b570              PUSH     {r4-r6,lr}
;;;79     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;80     	
;;;81     	//读取当前输出状态寄存器
;;;82     	if(pin <= awP0_7)
000006  2c07              CMP      r4,#7
000008  dc24              BGT      |L5.84|
;;;83     	{
;;;84     		//计算寄存器值
;;;85     		if(val == AW_1)
00000a  2d01              CMP      r5,#1
00000c  d10e              BNE      |L5.44|
;;;86     		{
;;;87     			PO_Output |= 1<<(pin%8);
00000e  4620              MOV      r0,r4
000010  17e1              ASRS     r1,r4,#31
000012  eb047151          ADD      r1,r4,r1,LSR #29
000016  10c9              ASRS     r1,r1,#3
000018  eba402c1          SUB      r2,r4,r1,LSL #3
00001c  2101              MOVS     r1,#1
00001e  4091              LSLS     r1,r1,r2
000020  4a1f              LDR      r2,|L5.160|
000022  7812              LDRB     r2,[r2,#0]  ; PO_Output
000024  4311              ORRS     r1,r1,r2
000026  4a1e              LDR      r2,|L5.160|
000028  7011              STRB     r1,[r2,#0]
00002a  e00d              B        |L5.72|
                  |L5.44|
;;;88     		}
;;;89     		else
;;;90     		{
;;;91     			PO_Output &= ~(1<<(pin%8));
00002c  4620              MOV      r0,r4
00002e  17e1              ASRS     r1,r4,#31
000030  eb047151          ADD      r1,r4,r1,LSR #29
000034  10c9              ASRS     r1,r1,#3
000036  eba402c1          SUB      r2,r4,r1,LSL #3
00003a  2101              MOVS     r1,#1
00003c  4091              LSLS     r1,r1,r2
00003e  4a18              LDR      r2,|L5.160|
000040  7812              LDRB     r2,[r2,#0]  ; PO_Output
000042  438a              BICS     r2,r2,r1
000044  4916              LDR      r1,|L5.160|
000046  700a              STRB     r2,[r1,#0]
                  |L5.72|
;;;92     		}
;;;93     		//重新设置输出状态
;;;94     		aw_WriteBytes(&PO_Output , Output_Port0 , 1);
000048  2201              MOVS     r2,#1
00004a  2102              MOVS     r1,#2
00004c  4814              LDR      r0,|L5.160|
00004e  f7fffffe          BL       aw_WriteBytes
000052  e023              B        |L5.156|
                  |L5.84|
;;;95     	}
;;;96     	else
;;;97     	{
;;;98     		//计算寄存器值
;;;99     		if(val == AW_1)
000054  2d01              CMP      r5,#1
000056  d10e              BNE      |L5.118|
;;;100    		{
;;;101    			P1_Output |= 1<<(pin%8);
000058  4620              MOV      r0,r4
00005a  17e1              ASRS     r1,r4,#31
00005c  eb047151          ADD      r1,r4,r1,LSR #29
000060  10c9              ASRS     r1,r1,#3
000062  eba402c1          SUB      r2,r4,r1,LSL #3
000066  2101              MOVS     r1,#1
000068  4091              LSLS     r1,r1,r2
00006a  4a0e              LDR      r2,|L5.164|
00006c  7812              LDRB     r2,[r2,#0]  ; P1_Output
00006e  4311              ORRS     r1,r1,r2
000070  4a0c              LDR      r2,|L5.164|
000072  7011              STRB     r1,[r2,#0]
000074  e00d              B        |L5.146|
                  |L5.118|
;;;102    		}
;;;103    		else
;;;104    		{
;;;105    			P1_Output &= ~(1<<(pin%8));
000076  4620              MOV      r0,r4
000078  17e1              ASRS     r1,r4,#31
00007a  eb047151          ADD      r1,r4,r1,LSR #29
00007e  10c9              ASRS     r1,r1,#3
000080  eba402c1          SUB      r2,r4,r1,LSL #3
000084  2101              MOVS     r1,#1
000086  4091              LSLS     r1,r1,r2
000088  4a06              LDR      r2,|L5.164|
00008a  7812              LDRB     r2,[r2,#0]  ; P1_Output
00008c  438a              BICS     r2,r2,r1
00008e  4905              LDR      r1,|L5.164|
000090  700a              STRB     r2,[r1,#0]
                  |L5.146|
;;;106    		}
;;;107    		//重新设置输出状态
;;;108    		aw_WriteBytes(&P1_Output , Output_Port1 , 1);
000092  2201              MOVS     r2,#1
000094  2103              MOVS     r1,#3
000096  4803              LDR      r0,|L5.164|
000098  f7fffffe          BL       aw_WriteBytes
                  |L5.156|
;;;109    	}
;;;110    	
;;;111    }
00009c  bd70              POP      {r4-r6,pc}
;;;112    
                          ENDP

00009e  0000              DCW      0x0000
                  |L5.160|
                          DCD      PO_Output
                  |L5.164|
                          DCD      P1_Output

                          AREA ||i.bsp_CheckOk||, CODE, READONLY, ALIGN=1

                  bsp_CheckOk PROC
;;;150    */
;;;151    static uint8_t bsp_CheckOk(void)
000000  b510              PUSH     {r4,lr}
;;;152    {
;;;153    	if (i2c_CheckDevice(AW_DEV_ADDR) == 0)
000002  20b6              MOVS     r0,#0xb6
000004  f7fffffe          BL       i2c_CheckDevice
000008  b908              CBNZ     r0,|L6.14|
;;;154    	{
;;;155    		return 1;
00000a  2001              MOVS     r0,#1
                  |L6.12|
;;;156    	}
;;;157    	else
;;;158    	{
;;;159    		/* 失败后，切记发送I2C总线停止信号 */
;;;160    		i2c_Stop();
;;;161    		return 0;
;;;162    	}
;;;163    }
00000c  bd10              POP      {r4,pc}
                  |L6.14|
00000e  f7fffffe          BL       i2c_Stop
000012  2000              MOVS     r0,#0                 ;161
000014  e7fa              B        |L6.12|
;;;164    
                          ENDP


                          AREA ||i.bsp_InitAW9523B||, CODE, READONLY, ALIGN=1

                  bsp_InitAW9523B PROC
;;;26     */
;;;27     uint8_t bsp_InitAW9523B(void)
000000  b510              PUSH     {r4,lr}
;;;28     {
;;;29     	bsp_InitRST();
000002  f7fffffe          BL       bsp_InitRST
;;;30     	bsp_InitI2C();
000006  f7fffffe          BL       bsp_InitI2C
;;;31     	
;;;32     	/* 检测器件是否应答 */
;;;33     	if(!bsp_CheckOk())
00000a  f7fffffe          BL       bsp_CheckOk
00000e  b908              CBNZ     r0,|L7.20|
;;;34     		return 0;
000010  2000              MOVS     r0,#0
                  |L7.18|
;;;35     	
;;;36     	
;;;37     	bsp_InitRegister();
;;;38     	
;;;39     	return 1;
;;;40     }
000012  bd10              POP      {r4,pc}
                  |L7.20|
000014  f7fffffe          BL       bsp_InitRegister
000018  2001              MOVS     r0,#1                 ;39
00001a  e7fa              B        |L7.18|
;;;41     
                          ENDP


                          AREA ||i.bsp_InitRST||, CODE, READONLY, ALIGN=2

                  bsp_InitRST PROC
;;;121    */
;;;122    static void bsp_InitRST(void)
000000  b508              PUSH     {r3,lr}
;;;123    {
;;;124    	GPIO_InitTypeDef GPIO_InitStructure;
;;;125    
;;;126    	/* 打开GPIO时钟 */
;;;127    	RCC_APB2PeriphClockCmd(RCC_ALL_PIN, ENABLE);
000002  2101              MOVS     r1,#1
000004  2080              MOVS     r0,#0x80
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;128    
;;;129    
;;;130    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;131    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;132    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_RST;
000016  01c0              LSLS     r0,r0,#7
000018  f8ad0000          STRH     r0,[sp,#0]
;;;133    	GPIO_Init(GPIO_PORT_RST, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  480c              LDR      r0,|L8.80|
000020  f7fffffe          BL       GPIO_Init
;;;134    	
;;;135    	GPIO_SetBits(GPIO_PORT_RST,GPIO_PIN_RST);
000024  f44f6100          MOV      r1,#0x800
000028  4809              LDR      r0,|L8.80|
00002a  f7fffffe          BL       GPIO_SetBits
;;;136    	bsp_DelayMS(2);
00002e  2002              MOVS     r0,#2
000030  f7fffffe          BL       bsp_DelayMS
;;;137    	GPIO_ResetBits(GPIO_PORT_RST,GPIO_PIN_RST);
000034  f44f6100          MOV      r1,#0x800
000038  4805              LDR      r0,|L8.80|
00003a  f7fffffe          BL       GPIO_ResetBits
;;;138    	bsp_DelayUS(40);
00003e  2028              MOVS     r0,#0x28
000040  f7fffffe          BL       bsp_DelayUS
;;;139    	GPIO_SetBits(GPIO_PORT_RST,GPIO_PIN_RST);
000044  f44f6100          MOV      r1,#0x800
000048  4801              LDR      r0,|L8.80|
00004a  f7fffffe          BL       GPIO_SetBits
;;;140    }
00004e  bd08              POP      {r3,pc}
;;;141    
                          ENDP

                  |L8.80|
                          DCD      0x40011c00

                          AREA ||i.bsp_InitRegister||, CODE, READONLY, ALIGN=1

                  bsp_InitRegister PROC
;;;172    */
;;;173    static void bsp_InitRegister(void)
000000  b508              PUSH     {r3,lr}
;;;174    {
;;;175    	uint8_t data = 0 ;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;176    	
;;;177    	data = 0x00 ;//P0全部为输出模式
000006  9000              STR      r0,[sp,#0]
;;;178    	aw_WriteBytes(&data , Config_Port0 , 1);
000008  2201              MOVS     r2,#1
00000a  2104              MOVS     r1,#4
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       aw_WriteBytes
;;;179    	
;;;180    	data = 0x00 ;//P1全部为输出模式
000012  2000              MOVS     r0,#0
000014  9000              STR      r0,[sp,#0]
;;;181    	aw_WriteBytes(&data , Config_Port1 , 1);
000016  2201              MOVS     r2,#1
000018  2105              MOVS     r1,#5
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       aw_WriteBytes
;;;182    	
;;;183    	//P1只能为推挽模式，P0可以推挽或开漏
;;;184    	//0x00:P0全部开漏，0x10:P0全部推挽
;;;185    	data = 0x10 ;
000020  2010              MOVS     r0,#0x10
000022  9000              STR      r0,[sp,#0]
;;;186    	aw_WriteBytes(&data , GCR , 1);
000024  2201              MOVS     r2,#1
000026  2111              MOVS     r1,#0x11
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       aw_WriteBytes
;;;187    	
;;;188    	//全部初始电平为高
;;;189    	data = 0xFF ;
00002e  20ff              MOVS     r0,#0xff
000030  9000              STR      r0,[sp,#0]
;;;190    	aw_WriteBytes(&data , Output_Port0 , 1);
000032  2201              MOVS     r2,#1
000034  2102              MOVS     r1,#2
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       aw_WriteBytes
;;;191    	aw_WriteBytes(&data , Output_Port1 , 1);
00003c  2201              MOVS     r2,#1
00003e  2103              MOVS     r1,#3
000040  4668              MOV      r0,sp
000042  f7fffffe          BL       aw_WriteBytes
;;;192    	
;;;193    }
000046  bd08              POP      {r3,pc}
;;;194    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  PO_Output
000000  ff                DCB      0xff
                  P1_Output
000001  ff                DCB      0xff

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\src\\bsp_aw9523b.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_aw9523b_c_36ea835a____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_aw9523b_c_36ea835a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_aw9523b_c_36ea835a____REVSH|
#line 128
|__asm___13_bsp_aw9523b_c_36ea835a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
