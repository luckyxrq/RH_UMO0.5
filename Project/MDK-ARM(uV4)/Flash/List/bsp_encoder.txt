; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_encoder.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_encoder.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\app\inc -IF:\LuckyXRQ\CleanCar\Project\MDK-ARM(uV4)\RTE -ID:\soft\MDK5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\soft\MDK5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_encoder.crf ..\..\User\app\src\bsp_Encoder.c]
                          THUMB

                          AREA ||i.TIM7_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM7_IRQHandler PROC
;;;112    */
;;;113    void TIM7_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;114    {
;;;115    	if(RESET != TIM_GetITStatus(TIM7, TIM_IT_Update)) 
000002  2101              MOVS     r1,#1
000004  4821              LDR      r0,|L1.140|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  2800              CMP      r0,#0
00000c  d03c              BEQ      |L1.136|
;;;116    	{
;;;117    		TIM_ClearITPendingBit(TIM7, TIM_IT_Update); 
00000e  2101              MOVS     r1,#1
000010  481e              LDR      r0,|L1.140|
000012  f7fffffe          BL       TIM_ClearITPendingBit
;;;118    		++interruptCount;
000016  481e              LDR      r0,|L1.144|
000018  6800              LDR      r0,[r0,#0]  ; interruptCount
00001a  1c40              ADDS     r0,r0,#1
00001c  491c              LDR      r1,|L1.144|
00001e  6008              STR      r0,[r1,#0]  ; interruptCount
;;;119    		
;;;120    		
;;;121    		/*左脉冲计数*/
;;;122    		if(GPIO_ReadInputDataBit(GPIO_PORT_LEFT,  GPIO_PIN_LEFT) == 0)
000020  f44f4100          MOV      r1,#0x8000
000024  481b              LDR      r0,|L1.148|
000026  f7fffffe          BL       GPIO_ReadInputDataBit
00002a  b918              CBNZ     r0,|L1.52|
;;;123    		{
;;;124    			encoder.isReadyRising[EncoderLeft] = true;
00002c  2001              MOVS     r0,#1
00002e  491a              LDR      r1,|L1.152|
000030  7008              STRB     r0,[r1,#0]
000032  e009              B        |L1.72|
                  |L1.52|
;;;125    		}
;;;126    		else
;;;127    		{
;;;128    			if(encoder.isReadyRising[EncoderLeft])
000034  4818              LDR      r0,|L1.152|
000036  7800              LDRB     r0,[r0,#0]  ; encoder
000038  b130              CBZ      r0,|L1.72|
;;;129    			{
;;;130    				encoder.isReadyRising[EncoderLeft] = false;
00003a  2000              MOVS     r0,#0
00003c  4916              LDR      r1,|L1.152|
00003e  7008              STRB     r0,[r1,#0]
;;;131    				++encoder.risingCount[EncoderLeft];
000040  4608              MOV      r0,r1
000042  6840              LDR      r0,[r0,#4]  ; encoder
000044  1c40              ADDS     r0,r0,#1
000046  6048              STR      r0,[r1,#4]  ; encoder
                  |L1.72|
;;;132    			}
;;;133    		}
;;;134    		
;;;135    		/*右脉冲计数*/
;;;136    		if(GPIO_ReadInputDataBit(GPIO_PORT_RIGHT,  GPIO_PIN_RIGHT) == 0)
000048  2108              MOVS     r1,#8
00004a  4814              LDR      r0,|L1.156|
00004c  f7fffffe          BL       GPIO_ReadInputDataBit
000050  b918              CBNZ     r0,|L1.90|
;;;137    		{
;;;138    			encoder.isReadyRising[EncoderRight] = true;
000052  2001              MOVS     r0,#1
000054  4910              LDR      r1,|L1.152|
000056  7048              STRB     r0,[r1,#1]
000058  e009              B        |L1.110|
                  |L1.90|
;;;139    		}
;;;140    		else
;;;141    		{
;;;142    			if(encoder.isReadyRising[EncoderRight])
00005a  480f              LDR      r0,|L1.152|
00005c  7840              LDRB     r0,[r0,#1]  ; encoder
00005e  b130              CBZ      r0,|L1.110|
;;;143    			{
;;;144    				encoder.isReadyRising[EncoderRight] = false;
000060  2000              MOVS     r0,#0
000062  490d              LDR      r1,|L1.152|
000064  7048              STRB     r0,[r1,#1]
;;;145    				++encoder.risingCount[EncoderRight];
000066  4608              MOV      r0,r1
000068  6880              LDR      r0,[r0,#8]
00006a  1c40              ADDS     r0,r0,#1
00006c  6088              STR      r0,[r1,#8]
                  |L1.110|
;;;146    			}
;;;147    		}
;;;148    
;;;149    		/*计算速度*/
;;;150    		if(interruptCount >= CALC_T)
00006e  4808              LDR      r0,|L1.144|
000070  6800              LDR      r0,[r0,#0]  ; interruptCount
000072  f5b07f7a          CMP      r0,#0x3e8
000076  d307              BCC      |L1.136|
;;;151    		{
;;;152    			interruptCount = 0 ;
000078  2000              MOVS     r0,#0
00007a  4905              LDR      r1,|L1.144|
00007c  6008              STR      r0,[r1,#0]  ; interruptCount
;;;153    			
;;;154    			bsp_EncoderCalcSpeed(EncoderLeft);
00007e  f7fffffe          BL       bsp_EncoderCalcSpeed
;;;155    			bsp_EncoderCalcSpeed(EncoderRight);
000082  2001              MOVS     r0,#1
000084  f7fffffe          BL       bsp_EncoderCalcSpeed
                  |L1.136|
;;;156    		}
;;;157    
;;;158    	}
;;;159    }
000088  bd10              POP      {r4,pc}
;;;160    
                          ENDP

00008a  0000              DCW      0x0000
                  |L1.140|
                          DCD      0x40001400
                  |L1.144|
                          DCD      interruptCount
                  |L1.148|
                          DCD      0x40010800
                  |L1.152|
                          DCD      encoder
                  |L1.156|
                          DCD      0x40011800

                          AREA ||i.bsp_EncoderCalcSpeed||, CODE, READONLY, ALIGN=2

                  bsp_EncoderCalcSpeed PROC
;;;82     */
;;;83     static void bsp_EncoderCalcSpeed(EncoderSN sn)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;84     {
000004  4604              MOV      r4,r0
;;;85     	encoder.speed[sn] = (float)encoder.risingCount[sn] / (float)Ratio *  (float)PERIMETER / 0.1F;
000006  490e              LDR      r1,|L2.64|
000008  f8510024          LDR      r0,[r1,r4,LSL #2]
00000c  f7fffffe          BL       __aeabi_ui2f
000010  4607              MOV      r7,r0
000012  f04f4188          MOV      r1,#0x44000000
000016  f7fffffe          BL       __aeabi_fdiv
00001a  4606              MOV      r6,r0
00001c  4909              LDR      r1,|L2.68|
00001e  f7fffffe          BL       __aeabi_fmul
000022  4605              MOV      r5,r0
000024  4908              LDR      r1,|L2.72|
000026  f7fffffe          BL       __aeabi_fdiv
00002a  4905              LDR      r1,|L2.64|
00002c  3108              ADDS     r1,r1,#8
00002e  f8410024          STR      r0,[r1,r4,LSL #2]
;;;86     	encoder.risingCount[sn] = 0 ;
000032  2100              MOVS     r1,#0
000034  4802              LDR      r0,|L2.64|
000036  f8401024          STR      r1,[r0,r4,LSL #2]
;;;87     	
;;;88     }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;89     
                          ENDP

00003e  0000              DCW      0x0000
                  |L2.64|
                          DCD      encoder+0x4
                  |L2.68|
                          DCD      0x435be94c
                  |L2.72|
                          DCD      0x3dcccccd

                          AREA ||i.bsp_EncoderGetSpeed||, CODE, READONLY, ALIGN=2

                  bsp_EncoderGetSpeed PROC
;;;98     */
;;;99     float bsp_EncoderGetSpeed(EncoderSN sn)
000000  4601              MOV      r1,r0
;;;100    {
;;;101    	return encoder.speed[sn];
000002  4802              LDR      r0,|L3.12|
000004  f8500021          LDR      r0,[r0,r1,LSL #2]
;;;102    }
000008  4770              BX       lr
;;;103    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      encoder+0xc

                          AREA ||i.bsp_InitEncoder||, CODE, READONLY, ALIGN=1

                  bsp_InitEncoder PROC
;;;28     */
;;;29     void bsp_InitEncoder(void)
000000  b510              PUSH     {r4,lr}
;;;30     {
;;;31     	bsp_InitEncoderIO();
000002  f7fffffe          BL       bsp_InitEncoderIO
;;;32     	bsp_InitEncoderTick();
000006  f7fffffe          BL       bsp_InitEncoderTick
;;;33     	
;;;34     }
00000a  bd10              POP      {r4,pc}
;;;35     
                          ENDP


                          AREA ||i.bsp_InitEncoderIO||, CODE, READONLY, ALIGN=2

                  bsp_InitEncoderIO PROC
;;;43     */
;;;44     static void bsp_InitEncoderIO(void)
000000  b508              PUSH     {r3,lr}
;;;45     {
;;;46     	GPIO_InitTypeDef  GPIO_InitStructure;
;;;47     	
;;;48     	RCC_APB2PeriphClockCmd(RCC_ALL_ENCODER, ENABLE);
000002  2101              MOVS     r1,#1
000004  2044              MOVS     r0,#0x44
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;49     				  
;;;50     	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;			
00000a  2048              MOVS     r0,#0x48
00000c  f88d0003          STRB     r0,[sp,#3]
;;;51     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000010  2003              MOVS     r0,#3
000012  f88d0002          STRB     r0,[sp,#2]
;;;52     	
;;;53     	GPIO_InitStructure.GPIO_Pin   = GPIO_PIN_LEFT;
000016  f44f4000          MOV      r0,#0x8000
00001a  f8ad0000          STRH     r0,[sp,#0]
;;;54     	GPIO_Init(GPIO_PORT_LEFT, &GPIO_InitStructure); 
00001e  4669              MOV      r1,sp
000020  4805              LDR      r0,|L5.56|
000022  f7fffffe          BL       GPIO_Init
;;;55     	
;;;56     	GPIO_InitStructure.GPIO_Pin   = GPIO_PIN_RIGHT;
000026  2008              MOVS     r0,#8
000028  f8ad0000          STRH     r0,[sp,#0]
;;;57     	GPIO_Init(GPIO_PORT_RIGHT, &GPIO_InitStructure); 
00002c  4669              MOV      r1,sp
00002e  4803              LDR      r0,|L5.60|
000030  f7fffffe          BL       GPIO_Init
;;;58     }
000034  bd08              POP      {r3,pc}
;;;59     
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      0x40010800
                  |L5.60|
                          DCD      0x40011800

                          AREA ||i.bsp_InitEncoderTick||, CODE, READONLY, ALIGN=2

                  bsp_InitEncoderTick PROC
;;;68     */
;;;69     static void bsp_InitEncoderTick(void)
000000  b510              PUSH     {r4,lr}
;;;70     {
;;;71     	bsp_SetTIMforInt(TIM7, ENCODER_INTERRUPT_FREQUENCY, 1, 0);
000002  2300              MOVS     r3,#0
000004  2201              MOVS     r2,#1
000006  f2427110          MOV      r1,#0x2710
00000a  4802              LDR      r0,|L6.20|
00000c  f7fffffe          BL       bsp_SetTIMforInt
;;;72     }
000010  bd10              POP      {r4,pc}
;;;73     
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40001400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  encoder
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  interruptCount
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\src\\bsp_Encoder.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_Encoder_c_95ca51fc____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_Encoder_c_95ca51fc____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_Encoder_c_95ca51fc____REVSH|
#line 128
|__asm___13_bsp_Encoder_c_95ca51fc____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
