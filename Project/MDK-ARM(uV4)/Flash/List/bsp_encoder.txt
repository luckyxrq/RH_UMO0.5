; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_encoder.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_encoder.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\app\inc -IF:\LuckyXRQ\CleanCar\Project\MDK-ARM(uV4)\RTE -ID:\soft\MDK5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\soft\MDK5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_encoder.crf ..\..\User\app\src\bsp_Encoder.c]
                          THUMB

                          AREA ||i.TIM7_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM7_IRQHandler PROC
;;;112    */
;;;113    void TIM7_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;114    {
;;;115    	if(RESET != TIM_GetITStatus(TIM7, TIM_IT_Update)) 
000002  2101              MOVS     r1,#1
000004  4825              LDR      r0,|L1.156|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  2800              CMP      r0,#0
00000c  d045              BEQ      |L1.154|
;;;116    	{
;;;117    		TIM_ClearITPendingBit(TIM7, TIM_IT_Update); 
00000e  2101              MOVS     r1,#1
000010  4822              LDR      r0,|L1.156|
000012  f7fffffe          BL       TIM_ClearITPendingBit
;;;118    		++interruptCount;
000016  4822              LDR      r0,|L1.160|
000018  6800              LDR      r0,[r0,#0]  ; interruptCount
00001a  1c40              ADDS     r0,r0,#1
00001c  4920              LDR      r1,|L1.160|
00001e  6008              STR      r0,[r1,#0]  ; interruptCount
;;;119    		
;;;120    		
;;;121    		/*左脉冲计数*/
;;;122    		if(GPIO_ReadInputDataBit(GPIO_PORT_LEFT,  GPIO_PIN_LEFT) == 0)
000020  f44f4100          MOV      r1,#0x8000
000024  481f              LDR      r0,|L1.164|
000026  f7fffffe          BL       GPIO_ReadInputDataBit
00002a  b918              CBNZ     r0,|L1.52|
;;;123    		{
;;;124    			encoder.isReadyRising[EncoderLeft] = true;
00002c  2001              MOVS     r0,#1
00002e  491e              LDR      r1,|L1.168|
000030  7008              STRB     r0,[r1,#0]
000032  e00d              B        |L1.80|
                  |L1.52|
;;;125    		}
;;;126    		else
;;;127    		{
;;;128    			if(encoder.isReadyRising[EncoderLeft])
000034  481c              LDR      r0,|L1.168|
000036  7800              LDRB     r0,[r0,#0]  ; encoder
000038  b150              CBZ      r0,|L1.80|
;;;129    			{
;;;130    				encoder.isReadyRising[EncoderLeft] = false;
00003a  2000              MOVS     r0,#0
00003c  491a              LDR      r1,|L1.168|
00003e  7008              STRB     r0,[r1,#0]
;;;131    				++encoder.risingCount[EncoderLeft];
000040  4608              MOV      r0,r1
000042  6840              LDR      r0,[r0,#4]  ; encoder
000044  1c40              ADDS     r0,r0,#1
000046  6048              STR      r0,[r1,#4]  ; encoder
;;;132    				++encoder.cnt[0];
000048  4608              MOV      r0,r1
00004a  6940              LDR      r0,[r0,#0x14]  ; encoder
00004c  1c40              ADDS     r0,r0,#1
00004e  6148              STR      r0,[r1,#0x14]  ; encoder
                  |L1.80|
;;;133    			}
;;;134    		}
;;;135    		
;;;136    		/*右脉冲计数*/
;;;137    		if(GPIO_ReadInputDataBit(GPIO_PORT_RIGHT,  GPIO_PIN_RIGHT) == 0)
000050  2108              MOVS     r1,#8
000052  4816              LDR      r0,|L1.172|
000054  f7fffffe          BL       GPIO_ReadInputDataBit
000058  b918              CBNZ     r0,|L1.98|
;;;138    		{
;;;139    			encoder.isReadyRising[EncoderRight] = true;
00005a  2001              MOVS     r0,#1
00005c  4912              LDR      r1,|L1.168|
00005e  7048              STRB     r0,[r1,#1]
000060  e00d              B        |L1.126|
                  |L1.98|
;;;140    		}
;;;141    		else
;;;142    		{
;;;143    			if(encoder.isReadyRising[EncoderRight])
000062  4811              LDR      r0,|L1.168|
000064  7840              LDRB     r0,[r0,#1]  ; encoder
000066  b150              CBZ      r0,|L1.126|
;;;144    			{
;;;145    				encoder.isReadyRising[EncoderRight] = false;
000068  2000              MOVS     r0,#0
00006a  490f              LDR      r1,|L1.168|
00006c  7048              STRB     r0,[r1,#1]
;;;146    				++encoder.risingCount[EncoderRight];
00006e  4608              MOV      r0,r1
000070  6880              LDR      r0,[r0,#8]
000072  1c40              ADDS     r0,r0,#1
000074  6088              STR      r0,[r1,#8]
;;;147    				++encoder.cnt[1];
000076  4608              MOV      r0,r1
000078  6980              LDR      r0,[r0,#0x18]
00007a  1c40              ADDS     r0,r0,#1
00007c  6188              STR      r0,[r1,#0x18]
                  |L1.126|
;;;148    			}
;;;149    		}
;;;150    
;;;151    		/*计算速度*/
;;;152    		if(interruptCount >= CALC_T)
00007e  4808              LDR      r0,|L1.160|
000080  6800              LDR      r0,[r0,#0]  ; interruptCount
000082  f2475130          MOV      r1,#0x7530
000086  4288              CMP      r0,r1
000088  d307              BCC      |L1.154|
;;;153    		{
;;;154    			interruptCount = 0 ;
00008a  2000              MOVS     r0,#0
00008c  4904              LDR      r1,|L1.160|
00008e  6008              STR      r0,[r1,#0]  ; interruptCount
;;;155    			
;;;156    			bsp_EncoderCalcSpeed(EncoderLeft);
000090  f7fffffe          BL       bsp_EncoderCalcSpeed
;;;157    			bsp_EncoderCalcSpeed(EncoderRight);
000094  2001              MOVS     r0,#1
000096  f7fffffe          BL       bsp_EncoderCalcSpeed
                  |L1.154|
;;;158    		}
;;;159    
;;;160    	}
;;;161    }
00009a  bd10              POP      {r4,pc}
;;;162    
                          ENDP

                  |L1.156|
                          DCD      0x40001400
                  |L1.160|
                          DCD      interruptCount
                  |L1.164|
                          DCD      0x40010800
                  |L1.168|
                          DCD      encoder
                  |L1.172|
                          DCD      0x40011800

                          AREA ||i.bsp_EncoderCalcSpeed||, CODE, READONLY, ALIGN=2

                  bsp_EncoderCalcSpeed PROC
;;;82     */
;;;83     static void bsp_EncoderCalcSpeed(EncoderSN sn)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;84     {
000004  4604              MOV      r4,r0
;;;85     	encoder.speed[sn] = (float)encoder.risingCount[sn] / (float)Ratio *  (float)PERIMETER / 0.3F;
000006  490e              LDR      r1,|L2.64|
000008  f8510024          LDR      r0,[r1,r4,LSL #2]
00000c  f7fffffe          BL       __aeabi_ui2f
000010  4607              MOV      r7,r0
000012  f04f4188          MOV      r1,#0x44000000
000016  f7fffffe          BL       __aeabi_fdiv
00001a  4606              MOV      r6,r0
00001c  4909              LDR      r1,|L2.68|
00001e  f7fffffe          BL       __aeabi_fmul
000022  4605              MOV      r5,r0
000024  4908              LDR      r1,|L2.72|
000026  f7fffffe          BL       __aeabi_fdiv
00002a  4905              LDR      r1,|L2.64|
00002c  3108              ADDS     r1,r1,#8
00002e  f8410024          STR      r0,[r1,r4,LSL #2]
;;;86     	encoder.risingCount[sn] = 0 ;
000032  2100              MOVS     r1,#0
000034  4802              LDR      r0,|L2.64|
000036  f8401024          STR      r1,[r0,r4,LSL #2]
;;;87     	
;;;88     }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;89     
                          ENDP

00003e  0000              DCW      0x0000
                  |L2.64|
                          DCD      encoder+0x4
                  |L2.68|
                          DCD      0x435be94c
                  |L2.72|
                          DCD      0x3e99999a

                          AREA ||i.bsp_EncoderGetSpeed||, CODE, READONLY, ALIGN=2

                  bsp_EncoderGetSpeed PROC
;;;98     */
;;;99     float bsp_EncoderGetSpeed(EncoderSN sn)
000000  4601              MOV      r1,r0
;;;100    {
;;;101    	return encoder.speed[sn];
000002  4802              LDR      r0,|L3.12|
000004  f8500021          LDR      r0,[r0,r1,LSL #2]
;;;102    }
000008  4770              BX       lr
;;;103    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      encoder+0xc

                          AREA ||i.bsp_InitEncoder||, CODE, READONLY, ALIGN=1

                  bsp_InitEncoder PROC
;;;28     */
;;;29     void bsp_InitEncoder(void)
000000  b510              PUSH     {r4,lr}
;;;30     {
;;;31     	bsp_InitEncoderIO();
000002  f7fffffe          BL       bsp_InitEncoderIO
;;;32     	bsp_InitEncoderTick();
000006  f7fffffe          BL       bsp_InitEncoderTick
;;;33     	
;;;34     }
00000a  bd10              POP      {r4,pc}
;;;35     
                          ENDP


                          AREA ||i.bsp_InitEncoderIO||, CODE, READONLY, ALIGN=2

                  bsp_InitEncoderIO PROC
;;;43     */
;;;44     static void bsp_InitEncoderIO(void)
000000  b508              PUSH     {r3,lr}
;;;45     {
;;;46     	GPIO_InitTypeDef  GPIO_InitStructure;
;;;47     	
;;;48     	RCC_APB2PeriphClockCmd(RCC_ALL_ENCODER, ENABLE);
000002  2101              MOVS     r1,#1
000004  2044              MOVS     r0,#0x44
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;49     				  
;;;50     	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;			
00000a  2048              MOVS     r0,#0x48
00000c  f88d0003          STRB     r0,[sp,#3]
;;;51     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000010  2003              MOVS     r0,#3
000012  f88d0002          STRB     r0,[sp,#2]
;;;52     	
;;;53     	GPIO_InitStructure.GPIO_Pin   = GPIO_PIN_LEFT;
000016  f44f4000          MOV      r0,#0x8000
00001a  f8ad0000          STRH     r0,[sp,#0]
;;;54     	GPIO_Init(GPIO_PORT_LEFT, &GPIO_InitStructure); 
00001e  4669              MOV      r1,sp
000020  4805              LDR      r0,|L5.56|
000022  f7fffffe          BL       GPIO_Init
;;;55     	
;;;56     	GPIO_InitStructure.GPIO_Pin   = GPIO_PIN_RIGHT;
000026  2008              MOVS     r0,#8
000028  f8ad0000          STRH     r0,[sp,#0]
;;;57     	GPIO_Init(GPIO_PORT_RIGHT, &GPIO_InitStructure); 
00002c  4669              MOV      r1,sp
00002e  4803              LDR      r0,|L5.60|
000030  f7fffffe          BL       GPIO_Init
;;;58     }
000034  bd08              POP      {r3,pc}
;;;59     
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      0x40010800
                  |L5.60|
                          DCD      0x40011800

                          AREA ||i.bsp_InitEncoderTick||, CODE, READONLY, ALIGN=2

                  bsp_InitEncoderTick PROC
;;;68     */
;;;69     static void bsp_InitEncoderTick(void)
000000  b510              PUSH     {r4,lr}
;;;70     {
;;;71     	bsp_SetTIMforInt(TIM7, ENCODER_INTERRUPT_FREQUENCY, 1, 0);
000002  2300              MOVS     r3,#0
000004  2201              MOVS     r2,#1
000006  4902              LDR      r1,|L6.16|
000008  4802              LDR      r0,|L6.20|
00000a  f7fffffe          BL       bsp_SetTIMforInt
;;;72     }
00000e  bd10              POP      {r4,pc}
;;;73     
                          ENDP

                  |L6.16|
                          DCD      0x000186a0
                  |L6.20|
                          DCD      0x40001400

                          AREA ||i.bsp_PrintEncoder||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  bsp_PrintEncoder PROC
;;;163    
;;;164    void bsp_PrintEncoder(void)
000000  b510              PUSH     {r4,lr}
;;;165    {
;;;166    	DEBUG("L:%d  R:%d\r\n",encoder.cnt[0],encoder.cnt[1]);
000002  4803              LDR      r0,|L7.16|
000004  6982              LDR      r2,[r0,#0x18]
000006  6941              LDR      r1,[r0,#0x14]  ; encoder
000008  a002              ADR      r0,|L7.20|
00000a  f7fffffe          BL       __2printf
;;;167    }
00000e  bd10              POP      {r4,pc}
;;;168    
                          ENDP

                  |L7.16|
                          DCD      encoder
                  |L7.20|
000014  4c3a2564          DCB      "L:%d  R:%d\r\n",0
000018  2020523a
00001c  25640d0a
000020  00      
000021  00                DCB      0
000022  00                DCB      0
000023  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  encoder
                          %        28

                          AREA ||.data||, DATA, ALIGN=2

                  interruptCount
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\src\\bsp_Encoder.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_Encoder_c_95ca51fc____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_Encoder_c_95ca51fc____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_Encoder_c_95ca51fc____REVSH|
#line 128
|__asm___13_bsp_Encoder_c_95ca51fc____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
