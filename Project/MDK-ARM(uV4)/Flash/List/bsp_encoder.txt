; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_encoder.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_encoder.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\app\inc -IF:\LuckyXRQ\CleanCar\Project\MDK-ARM(uV4)\RTE -ID:\soft\MDK5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\soft\MDK5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_encoder.crf ..\..\User\app\src\bsp_Encoder.c]
                          THUMB

                          AREA ||i.TIM7_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM7_IRQHandler PROC
;;;112    */
;;;113    void TIM7_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;114    {
;;;115    	if(RESET != TIM_GetITStatus(TIM7, TIM_IT_Update)) 
000002  2101              MOVS     r1,#1
000004  482e              LDR      r0,|L1.192|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  2800              CMP      r0,#0
00000c  d057              BEQ      |L1.190|
;;;116    	{
;;;117    		TIM_ClearITPendingBit(TIM7, TIM_IT_Update); 
00000e  2101              MOVS     r1,#1
000010  482b              LDR      r0,|L1.192|
000012  f7fffffe          BL       TIM_ClearITPendingBit
;;;118    		++interruptCount;
000016  482b              LDR      r0,|L1.196|
000018  6800              LDR      r0,[r0,#0]  ; interruptCount
00001a  1c40              ADDS     r0,r0,#1
00001c  4929              LDR      r1,|L1.196|
00001e  6008              STR      r0,[r1,#0]  ; interruptCount
;;;119    		
;;;120    		
;;;121    		/*左脉冲计数*/
;;;122    		if(GPIO_ReadInputDataBit(GPIO_PORT_LEFT,  GPIO_PIN_LEFT) == 0)
000020  f44f4100          MOV      r1,#0x8000
000024  4828              LDR      r0,|L1.200|
000026  f7fffffe          BL       GPIO_ReadInputDataBit
00002a  b918              CBNZ     r0,|L1.52|
;;;123    		{
;;;124    			encoder.isReadyRising[EncoderLeft] = true;
00002c  2001              MOVS     r0,#1
00002e  4927              LDR      r1,|L1.204|
000030  7008              STRB     r0,[r1,#0]
000032  e016              B        |L1.98|
                  |L1.52|
;;;125    		}
;;;126    		else
;;;127    		{
;;;128    			if(encoder.isReadyRising[EncoderLeft])
000034  4825              LDR      r0,|L1.204|
000036  7800              LDRB     r0,[r0,#0]  ; encoder
000038  b198              CBZ      r0,|L1.98|
;;;129    			{
;;;130    				encoder.isReadyRising[EncoderLeft] = false;
00003a  2000              MOVS     r0,#0
00003c  4923              LDR      r1,|L1.204|
00003e  7008              STRB     r0,[r1,#0]
;;;131    				++encoder.risingCount[EncoderLeft];
000040  4608              MOV      r0,r1
000042  6840              LDR      r0,[r0,#4]  ; encoder
000044  1c40              ADDS     r0,r0,#1
000046  6048              STR      r0,[r1,#4]  ; encoder
;;;132    				encoder.odometer[0] += (bsp_MotorGetDir(MotorLeft)==Forward ? 1 : -1);/*里程计*/
000048  2000              MOVS     r0,#0
00004a  f7fffffe          BL       bsp_MotorGetDir
00004e  b908              CBNZ     r0,|L1.84|
000050  2001              MOVS     r0,#1
000052  e001              B        |L1.88|
                  |L1.84|
000054  f04f30ff          MOV      r0,#0xffffffff
                  |L1.88|
000058  491c              LDR      r1,|L1.204|
00005a  6949              LDR      r1,[r1,#0x14]  ; encoder
00005c  4408              ADD      r0,r0,r1
00005e  491b              LDR      r1,|L1.204|
000060  6148              STR      r0,[r1,#0x14]  ; encoder
                  |L1.98|
;;;133    			}
;;;134    		}
;;;135    		
;;;136    		/*右脉冲计数*/
;;;137    		if(GPIO_ReadInputDataBit(GPIO_PORT_RIGHT,  GPIO_PIN_RIGHT) == 0)
000062  2108              MOVS     r1,#8
000064  481a              LDR      r0,|L1.208|
000066  f7fffffe          BL       GPIO_ReadInputDataBit
00006a  b918              CBNZ     r0,|L1.116|
;;;138    		{
;;;139    			encoder.isReadyRising[EncoderRight] = true;
00006c  2001              MOVS     r0,#1
00006e  4917              LDR      r1,|L1.204|
000070  7048              STRB     r0,[r1,#1]
000072  e016              B        |L1.162|
                  |L1.116|
;;;140    		}
;;;141    		else
;;;142    		{
;;;143    			if(encoder.isReadyRising[EncoderRight])
000074  4815              LDR      r0,|L1.204|
000076  7840              LDRB     r0,[r0,#1]  ; encoder
000078  b198              CBZ      r0,|L1.162|
;;;144    			{
;;;145    				encoder.isReadyRising[EncoderRight] = false;
00007a  2000              MOVS     r0,#0
00007c  4913              LDR      r1,|L1.204|
00007e  7048              STRB     r0,[r1,#1]
;;;146    				++encoder.risingCount[EncoderRight];
000080  4608              MOV      r0,r1
000082  6880              LDR      r0,[r0,#8]
000084  1c40              ADDS     r0,r0,#1
000086  6088              STR      r0,[r1,#8]
;;;147    				encoder.odometer[1] += (bsp_MotorGetDir(MotorRight)==Forward ? 1 : -1);/*里程计*/
000088  2001              MOVS     r0,#1
00008a  f7fffffe          BL       bsp_MotorGetDir
00008e  b908              CBNZ     r0,|L1.148|
000090  2101              MOVS     r1,#1
000092  e001              B        |L1.152|
                  |L1.148|
000094  f04f31ff          MOV      r1,#0xffffffff
                  |L1.152|
000098  480c              LDR      r0,|L1.204|
00009a  6980              LDR      r0,[r0,#0x18]
00009c  4401              ADD      r1,r1,r0
00009e  480b              LDR      r0,|L1.204|
0000a0  6181              STR      r1,[r0,#0x18]
                  |L1.162|
;;;148    			}
;;;149    		}
;;;150    
;;;151    		/*计算速度*/
;;;152    		if(interruptCount >= CALC_T)
0000a2  4808              LDR      r0,|L1.196|
0000a4  6800              LDR      r0,[r0,#0]  ; interruptCount
0000a6  f2475130          MOV      r1,#0x7530
0000aa  4288              CMP      r0,r1
0000ac  d307              BCC      |L1.190|
;;;153    		{
;;;154    			interruptCount = 0 ;
0000ae  2000              MOVS     r0,#0
0000b0  4904              LDR      r1,|L1.196|
0000b2  6008              STR      r0,[r1,#0]  ; interruptCount
;;;155    			
;;;156    			bsp_EncoderCalcSpeed(EncoderLeft);
0000b4  f7fffffe          BL       bsp_EncoderCalcSpeed
;;;157    			bsp_EncoderCalcSpeed(EncoderRight);
0000b8  2001              MOVS     r0,#1
0000ba  f7fffffe          BL       bsp_EncoderCalcSpeed
                  |L1.190|
;;;158    		}
;;;159    
;;;160    	}
;;;161    }
0000be  bd10              POP      {r4,pc}
;;;162    
                          ENDP

                  |L1.192|
                          DCD      0x40001400
                  |L1.196|
                          DCD      interruptCount
                  |L1.200|
                          DCD      0x40010800
                  |L1.204|
                          DCD      encoder
                  |L1.208|
                          DCD      0x40011800

                          AREA ||i.bsp_EncoderCalcSpeed||, CODE, READONLY, ALIGN=2

                  bsp_EncoderCalcSpeed PROC
;;;82     */
;;;83     static void bsp_EncoderCalcSpeed(EncoderSN sn)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;84     {
000004  4604              MOV      r4,r0
;;;85     	encoder.speed[sn] = (float)encoder.risingCount[sn] / (float)Ratio *  (float)PERIMETER / 0.3F;
000006  490e              LDR      r1,|L2.64|
000008  f8510024          LDR      r0,[r1,r4,LSL #2]
00000c  f7fffffe          BL       __aeabi_ui2f
000010  4607              MOV      r7,r0
000012  f04f4188          MOV      r1,#0x44000000
000016  f7fffffe          BL       __aeabi_fdiv
00001a  4606              MOV      r6,r0
00001c  4909              LDR      r1,|L2.68|
00001e  f7fffffe          BL       __aeabi_fmul
000022  4605              MOV      r5,r0
000024  4908              LDR      r1,|L2.72|
000026  f7fffffe          BL       __aeabi_fdiv
00002a  4905              LDR      r1,|L2.64|
00002c  3108              ADDS     r1,r1,#8
00002e  f8410024          STR      r0,[r1,r4,LSL #2]
;;;86     	encoder.risingCount[sn] = 0 ;
000032  2100              MOVS     r1,#0
000034  4802              LDR      r0,|L2.64|
000036  f8401024          STR      r1,[r0,r4,LSL #2]
;;;87     	
;;;88     }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;89     
                          ENDP

00003e  0000              DCW      0x0000
                  |L2.64|
                          DCD      encoder+0x4
                  |L2.68|
                          DCD      0x435be94c
                  |L2.72|
                          DCD      0x3e99999a

                          AREA ||i.bsp_EncoderGetSpeed||, CODE, READONLY, ALIGN=2

                  bsp_EncoderGetSpeed PROC
;;;98     */
;;;99     float bsp_EncoderGetSpeed(EncoderSN sn)
000000  4601              MOV      r1,r0
;;;100    {
;;;101    	return encoder.speed[sn];
000002  4802              LDR      r0,|L3.12|
000004  f8500021          LDR      r0,[r0,r1,LSL #2]
;;;102    }
000008  4770              BX       lr
;;;103    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      encoder+0xc

                          AREA ||i.bsp_InitEncoder||, CODE, READONLY, ALIGN=1

                  bsp_InitEncoder PROC
;;;28     */
;;;29     void bsp_InitEncoder(void)
000000  b510              PUSH     {r4,lr}
;;;30     {
;;;31     	bsp_InitEncoderIO();
000002  f7fffffe          BL       bsp_InitEncoderIO
;;;32     	bsp_InitEncoderTick();
000006  f7fffffe          BL       bsp_InitEncoderTick
;;;33     	
;;;34     }
00000a  bd10              POP      {r4,pc}
;;;35     
                          ENDP


                          AREA ||i.bsp_InitEncoderIO||, CODE, READONLY, ALIGN=2

                  bsp_InitEncoderIO PROC
;;;43     */
;;;44     static void bsp_InitEncoderIO(void)
000000  b508              PUSH     {r3,lr}
;;;45     {
;;;46     	GPIO_InitTypeDef  GPIO_InitStructure;
;;;47     	
;;;48     	RCC_APB2PeriphClockCmd(RCC_ALL_ENCODER, ENABLE);
000002  2101              MOVS     r1,#1
000004  2044              MOVS     r0,#0x44
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;49     				  
;;;50     	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;			
00000a  2048              MOVS     r0,#0x48
00000c  f88d0003          STRB     r0,[sp,#3]
;;;51     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000010  2003              MOVS     r0,#3
000012  f88d0002          STRB     r0,[sp,#2]
;;;52     	
;;;53     	GPIO_InitStructure.GPIO_Pin   = GPIO_PIN_LEFT;
000016  f44f4000          MOV      r0,#0x8000
00001a  f8ad0000          STRH     r0,[sp,#0]
;;;54     	GPIO_Init(GPIO_PORT_LEFT, &GPIO_InitStructure); 
00001e  4669              MOV      r1,sp
000020  4805              LDR      r0,|L5.56|
000022  f7fffffe          BL       GPIO_Init
;;;55     	
;;;56     	GPIO_InitStructure.GPIO_Pin   = GPIO_PIN_RIGHT;
000026  2008              MOVS     r0,#8
000028  f8ad0000          STRH     r0,[sp,#0]
;;;57     	GPIO_Init(GPIO_PORT_RIGHT, &GPIO_InitStructure); 
00002c  4669              MOV      r1,sp
00002e  4803              LDR      r0,|L5.60|
000030  f7fffffe          BL       GPIO_Init
;;;58     }
000034  bd08              POP      {r3,pc}
;;;59     
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      0x40010800
                  |L5.60|
                          DCD      0x40011800

                          AREA ||i.bsp_InitEncoderTick||, CODE, READONLY, ALIGN=2

                  bsp_InitEncoderTick PROC
;;;68     */
;;;69     static void bsp_InitEncoderTick(void)
000000  b510              PUSH     {r4,lr}
;;;70     {
;;;71     	bsp_SetTIMforInt(TIM7, ENCODER_INTERRUPT_FREQUENCY, 1, 0);
000002  2300              MOVS     r3,#0
000004  2201              MOVS     r2,#1
000006  4902              LDR      r1,|L6.16|
000008  4802              LDR      r0,|L6.20|
00000a  f7fffffe          BL       bsp_SetTIMforInt
;;;72     }
00000e  bd10              POP      {r4,pc}
;;;73     
                          ENDP

                  |L6.16|
                          DCD      0x000186a0
                  |L6.20|
                          DCD      0x40001400

                          AREA ||i.bsp_encoderGetOdometer||, CODE, READONLY, ALIGN=2

                  bsp_encoderGetOdometer PROC
;;;164    
;;;165    int32_t bsp_encoderGetOdometer(MotorSN sn)
000000  4601              MOV      r1,r0
;;;166    {
;;;167    	int32_t odometer = 0 ;
000002  2000              MOVS     r0,#0
;;;168    	switch(sn)
000004  b111              CBZ      r1,|L7.12|
000006  2901              CMP      r1,#1
000008  d106              BNE      |L7.24|
00000a  e002              B        |L7.18|
                  |L7.12|
;;;169    	{
;;;170    		case MotorLeft:
;;;171    		{
;;;172    			odometer = encoder.odometer[0];
00000c  4a03              LDR      r2,|L7.28|
00000e  6950              LDR      r0,[r2,#0x14]  ; encoder
;;;173    		}break;
000010  e002              B        |L7.24|
                  |L7.18|
;;;174    		
;;;175    		case MotorRight:
;;;176    		{
;;;177    			odometer = encoder.odometer[1];
000012  4a02              LDR      r2,|L7.28|
000014  6990              LDR      r0,[r2,#0x18]
;;;178    		}break;
000016  bf00              NOP      
                  |L7.24|
000018  bf00              NOP                            ;173
;;;179    	}
;;;180    	
;;;181    	return  odometer;
;;;182    	
;;;183    }
00001a  4770              BX       lr
;;;184    
                          ENDP

                  |L7.28|
                          DCD      encoder

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  encoder
                          %        28

                          AREA ||.data||, DATA, ALIGN=2

                  interruptCount
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\src\\bsp_Encoder.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_Encoder_c_95ca51fc____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_Encoder_c_95ca51fc____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_Encoder_c_95ca51fc____REVSH|
#line 128
|__asm___13_bsp_Encoder_c_95ca51fc____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
