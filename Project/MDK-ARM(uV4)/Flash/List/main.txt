; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\main.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\app\inc -I.\RTE\_Flash -IE:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IE:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\main.crf ..\..\User\main.c]
                          THUMB

                          AREA ||i.AppObjCreate||, CODE, READONLY, ALIGN=2

                  AppObjCreate PROC
;;;407    */
;;;408    static void AppObjCreate (void)
000000  b510              PUSH     {r4,lr}
;;;409    {
;;;410    	/* 创建互斥信号量 */
;;;411        xMutex = xSemaphoreCreateMutex();
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       xQueueCreateMutex
000008  4901              LDR      r1,|L1.16|
00000a  6008              STR      r0,[r1,#0]  ; xMutex
;;;412    	
;;;413    	if(xMutex == NULL)
;;;414        {
;;;415            /* 没有创建成功，用户可以在这里加入创建失败的处理机制 */
;;;416        }
;;;417    }
00000c  bd10              POP      {r4,pc}
;;;418    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      xMutex

                          AREA ||i.AppTaskCreate||, CODE, READONLY, ALIGN=2

                  AppTaskCreate PROC
;;;346    */
;;;347    static void AppTaskCreate (void)
000000  b51f              PUSH     {r0-r4,lr}
;;;348    {
;;;349    //    xTaskCreate( vTaskTaskUserIF,   	/* 任务函数  */
;;;350    //                 "vTaskUserIF",     	/* 任务名    */
;;;351    //                 1024,               	/* 任务栈大小，单位word，也就是4字节 */
;;;352    //                 NULL,              	/* 任务参数  */
;;;353    //                 1,                 	/* 任务优先级*/
;;;354    //                 &xHandleTaskUserIF );  /* 任务句柄  */
;;;355    //	
;;;356    //	
;;;357    //	xTaskCreate( vTaskLED,    		/* 任务函数  */
;;;358    //                 "vTaskLED",  		/* 任务名    */
;;;359    //                 1024,         		/* stack大小，单位word，也就是4字节 */
;;;360    //                 NULL,        		/* 任务参数  */
;;;361    //                 2,           		/* 任务优先级*/
;;;362    //                 &xHandleTaskLED ); /* 任务句柄  */
;;;363    //	
;;;364    //	xTaskCreate( vTaskMsgPro,     		/* 任务函数  */
;;;365    //                 "vTaskMsgPro",   		/* 任务名    */
;;;366    //                 1024,             		/* 任务栈大小，单位word，也就是4字节 */
;;;367    //                 NULL,           		/* 任务参数  */
;;;368    //                 3,               		/* 任务优先级*/
;;;369    //                 &xHandleTaskMsgPro );  /* 任务句柄  */
;;;370    //	
;;;371    //	
;;;372    //	xTaskCreate( vTaskStart,     		/* 任务函数  */
;;;373    //                 "vTaskStart",   		/* 任务名    */
;;;374    //                 1024,            		/* 任务栈大小，单位word，也就是4字节 */
;;;375    //                 NULL,           		/* 任务参数  */
;;;376    //                 4,              		/* 任务优先级*/
;;;377    //                 &xHandleTaskStart );   /* 任务句柄  */
;;;378    
;;;379    	xTaskCreate( vTaskPerception,     		    /* 任务函数  */
000002  2000              MOVS     r0,#0
000004  4a14              LDR      r2,|L2.88|
000006  2307              MOVS     r3,#7
000008  e9cd2001          STRD     r2,r0,[sp,#4]
00000c  9300              STR      r3,[sp,#0]
00000e  9003              STR      r0,[sp,#0xc]
000010  4603              MOV      r3,r0
000012  f44f6280          MOV      r2,#0x400
000016  a111              ADR      r1,|L2.92|
000018  4814              LDR      r0,|L2.108|
00001a  f7fffffe          BL       xTaskGenericCreate
;;;380                     "vTaskPerception",   		    /* 任务名    */
;;;381                     1024,            		        /* 任务栈大小，单位word，也就是4字节 */
;;;382                     NULL,           		        /* 任务参数  */
;;;383                     7,              		        /* 任务优先级*/
;;;384                     &xHandleTaskPerception );      /* 任务句柄  */	
;;;385    	xTaskCreate( vTaskControl,     		        /* 任务函数  */
00001e  2000              MOVS     r0,#0
000020  4a13              LDR      r2,|L2.112|
000022  2306              MOVS     r3,#6
000024  e9cd2001          STRD     r2,r0,[sp,#4]
000028  9300              STR      r3,[sp,#0]
00002a  9003              STR      r0,[sp,#0xc]
00002c  4603              MOV      r3,r0
00002e  f44f6280          MOV      r2,#0x400
000032  a110              ADR      r1,|L2.116|
000034  4813              LDR      r0,|L2.132|
000036  f7fffffe          BL       xTaskGenericCreate
;;;386                     "vTaskControl",   		        /* 任务名    */
;;;387                     1024,            		        /* 任务栈大小，单位word，也就是4字节 */
;;;388                     NULL,           		        /* 任务参数  */
;;;389                     6,              		        /* 任务优先级*/
;;;390                     &xHandleTaskControl );         /* 任务句柄  */				 
;;;391    	xTaskCreate( vTaskDecision,     		    /* 任务函数  */
00003a  2000              MOVS     r0,#0
00003c  4a12              LDR      r2,|L2.136|
00003e  2305              MOVS     r3,#5
000040  e9cd2001          STRD     r2,r0,[sp,#4]
000044  9300              STR      r3,[sp,#0]
000046  9003              STR      r0,[sp,#0xc]
000048  4603              MOV      r3,r0
00004a  f44f6280          MOV      r2,#0x400
00004e  a10f              ADR      r1,|L2.140|
000050  4812              LDR      r0,|L2.156|
000052  f7fffffe          BL       xTaskGenericCreate
;;;392                     "vTaskDecision",   		    /* 任务名    */
;;;393                     1024,            		        /* 任务栈大小，单位word，也就是4字节 */
;;;394                     NULL,           		        /* 任务参数  */
;;;395                     5,              		        /* 任务优先级*/
;;;396                     &xHandleTaskDecision );        /* 任务句柄  */
;;;397    				 
;;;398    }
000056  bd1f              POP      {r0-r4,pc}
;;;399    
                          ENDP

                  |L2.88|
                          DCD      xHandleTaskPerception
                  |L2.92|
00005c  76546173          DCB      "vTaskPerception",0
000060  6b506572
000064  63657074
000068  696f6e00
                  |L2.108|
                          DCD      vTaskPerception
                  |L2.112|
                          DCD      xHandleTaskControl
                  |L2.116|
000074  76546173          DCB      "vTaskControl",0
000078  6b436f6e
00007c  74726f6c
000080  00      
000081  00                DCB      0
000082  00                DCB      0
000083  00                DCB      0
                  |L2.132|
                          DCD      vTaskControl
                  |L2.136|
                          DCD      xHandleTaskDecision
                  |L2.140|
00008c  76546173          DCB      "vTaskDecision",0
000090  6b446563
000094  6973696f
000098  6e00    
00009a  00                DCB      0
00009b  00                DCB      0
                  |L2.156|
                          DCD      vTaskDecision

                          AREA ||i.App_Printf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  App_Printf PROC
;;;427    */
;;;428    void  App_Printf(char *format, ...)
000000  b40f              PUSH     {r0-r3}
;;;429    {
000002  b500              PUSH     {lr}
000004  b0b5              SUB      sp,sp,#0xd4
;;;430        char  buf_str[200 + 1];
;;;431        va_list   v_args;
;;;432    
;;;433    
;;;434        va_start(v_args, format);
000006  a837              ADD      r0,sp,#0xdc
000008  9001              STR      r0,[sp,#4]
;;;435       (void)vsnprintf((char       *)&buf_str[0],
00000a  21c9              MOVS     r1,#0xc9
00000c  a802              ADD      r0,sp,#8
00000e  9b01              LDR      r3,[sp,#4]
000010  9a36              LDR      r2,[sp,#0xd8]
000012  f7fffffe          BL       __c89vsnprintf
;;;436                       (size_t      ) sizeof(buf_str),
;;;437                       (char const *) format,
;;;438                                      v_args);
;;;439        va_end(v_args);
000016  2000              MOVS     r0,#0
000018  9001              STR      r0,[sp,#4]
;;;440    
;;;441    	/* 互斥信号量 */
;;;442    	xSemaphoreTake(xMutex, portMAX_DELAY);
00001a  2300              MOVS     r3,#0
00001c  1e42              SUBS     r2,r0,#1
00001e  4619              MOV      r1,r3
000020  4808              LDR      r0,|L3.68|
000022  6800              LDR      r0,[r0,#0]  ; xMutex
000024  f7fffffe          BL       xQueueGenericReceive
;;;443    
;;;444        printf("%s", buf_str);
000028  a902              ADD      r1,sp,#8
00002a  a007              ADR      r0,|L3.72|
00002c  f7fffffe          BL       __2printf
;;;445    
;;;446       	xSemaphoreGive(xMutex);
000030  2300              MOVS     r3,#0
000032  461a              MOV      r2,r3
000034  4619              MOV      r1,r3
000036  4803              LDR      r0,|L3.68|
000038  6800              LDR      r0,[r0,#0]  ; xMutex
00003a  f7fffffe          BL       xQueueGenericSend
;;;447    }
00003e  b035              ADD      sp,sp,#0xd4
000040  f85dfb14          LDR      pc,[sp],#0x14
;;;448    
                          ENDP

                  |L3.68|
                          DCD      xMutex
                  |L3.72|
000048  257300            DCB      "%s",0
00004b  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;51     */
;;;52     int main(void)
000000  2001              MOVS     r0,#1
000002  f3808810          MSR      PRIMASK,r0
000006  bf00              NOP      
;;;53     {
;;;54     	/* 
;;;55     	  在启动调度前，为了防止初始化STM32外设时有中断服务程序执行，这里禁止全局中断(除了NMI和HardFault)。
;;;56     	  这样做的好处是：
;;;57     	  1. 防止执行的中断服务程序中有FreeRTOS的API函数。
;;;58     	  2. 保证系统正常启动，不受别的中断影响。
;;;59     	  3. 关于是否关闭全局中断，大家根据自己的实际情况设置即可。
;;;60     	  在移植文件port.c中的函数prvStartFirstTask中会重新开启全局中断。通过指令cpsie i开启，__set_PRIMASK(1)
;;;61     	  和cpsie i是等效的。
;;;62          */
;;;63     	__set_PRIMASK(1);  
;;;64     	
;;;65     	/* 硬件初始化 */
;;;66     	bsp_Init(); 
000008  f7fffffe          BL       bsp_Init
;;;67     	
;;;68     	/* 1. 初始化一个定时器中断，精度高于滴答定时器中断，这样才可以获得准确的系统信息 仅供调试目的，实际项
;;;69     		  目中不要使用，因为这个功能比较影响系统实时性。
;;;70     	   2. 为了正确获取FreeRTOS的调试信息，可以考虑将上面的关闭中断指令__set_PRIMASK(1); 注释掉。 
;;;71     	*/
;;;72     	vSetupSysInfoTest();
00000c  f7fffffe          BL       vSetupSysInfoTest
;;;73     	
;;;74     	/* 创建任务 */
;;;75     	AppTaskCreate();
000010  f7fffffe          BL       AppTaskCreate
;;;76     
;;;77     	/* 创建任务通信机制 */
;;;78     	AppObjCreate();
000014  f7fffffe          BL       AppObjCreate
;;;79     	
;;;80         /* 启动调度，开始执行任务 */
;;;81         vTaskStartScheduler();
000018  f7fffffe          BL       vTaskStartScheduler
;;;82     
;;;83     	/* 
;;;84     	  如果系统正常启动是不会运行到这里的，运行到这里极有可能是用于定时器任务或者空闲任务的
;;;85     	  heap空间不足造成创建失败，此要加大FreeRTOSConfig.h文件中定义的heap大小：
;;;86     	  #define configTOTAL_HEAP_SIZE	      ( ( size_t ) ( 17 * 1024 ) )
;;;87     	*/
;;;88     	while(1);
00001c  bf00              NOP      
                  |L4.30|
00001e  e7fe              B        |L4.30|
;;;89     }
;;;90     
                          ENDP


                          AREA ||i.vTaskControl||, CODE, READONLY, ALIGN=1

                  vTaskControl PROC
;;;309    }
;;;310    static void vTaskControl(void *pvParameters)       //控制 根据决策控制电机
000000  e008              B        |L5.20|
                  |L5.2|
;;;311    {
;;;312    	while(1)
;;;313        {
;;;314    
;;;315    		bsp_IWDG_Feed(); /* 喂狗 */ //1S
000002  f7fffffe          BL       bsp_IWDG_Feed
;;;316    		bsp_PidSched(); /*10MS调用一次，这里面进行PWM计算，占空比设置，速度（脉冲为单位；MM为单位）计算*/
000006  f7fffffe          BL       bsp_PidSched
;;;317    	
;;;318    		bsp_ComAnalysis();
00000a  f7fffffe          BL       bsp_ComAnalysis
;;;319    		vTaskDelay(10);
00000e  200a              MOVS     r0,#0xa
000010  f7fffffe          BL       vTaskDelay
                  |L5.20|
000014  e7f5              B        |L5.2|
;;;320        }
;;;321    	
;;;322    }
;;;323    static void vTaskDecision(void *pvParameters)      //决策 整机软件控制流程
                          ENDP


                          AREA ||i.vTaskDecision||, CODE, READONLY, ALIGN=1

                  vTaskDecision PROC
;;;322    }
;;;323    static void vTaskDecision(void *pvParameters)      //决策 整机软件控制流程
000000  e006              B        |L6.16|
                  |L6.2|
;;;324    {
;;;325    	while(1)
;;;326    	{
;;;327    		Collision collision = bsp_CollisionScan();
000002  f7fffffe          BL       bsp_CollisionScan
000006  4604              MOV      r4,r0
;;;328    		
;;;329    		
;;;330    		
;;;331    		
;;;332    		vTaskDelay(50);	
000008  2032              MOVS     r0,#0x32
00000a  f7fffffe          BL       vTaskDelay
;;;333    	}
00000e  bf00              NOP      
                  |L6.16|
000010  e7f7              B        |L6.2|
;;;334    	
;;;335    	
;;;336    }
;;;337    
                          ENDP


                          AREA ||i.vTaskLED||, CODE, READONLY, ALIGN=1

                  vTaskLED PROC
;;;168    */
;;;169    static void vTaskLED(void *pvParameters)
000000  e00a              B        |L7.24|
                  |L7.2|
;;;170    {
;;;171    	//static uint32_t index = 0 ;
;;;172        while(1)
;;;173        {
;;;174    		
;;;175    #if 1
;;;176    		Collision collision = bsp_CollisionScan();
000002  f7fffffe          BL       bsp_CollisionScan
000006  4604              MOV      r4,r0
;;;177    		
;;;178    		if(collision == CollisionLeft)
000008  b114              CBZ      r4,|L7.16|
;;;179    		{
;;;180    			//DEBUG("%06dLeft\r\n",index++);
;;;181    			
;;;182    //			bsp_SetMotorSpeed(MotorLeft,-5);
;;;183    //			bsp_SetMotorSpeed(MotorRight,-12);
;;;184    //			vTaskDelay(500);
;;;185    //			bsp_SetMotorSpeed(MotorLeft,5);
;;;186    //			bsp_SetMotorSpeed(MotorRight,5);
;;;187    		}
;;;188    		else if(collision == CollisionRight)
00000a  2c01              CMP      r4,#1
00000c  d000              BEQ      |L7.16|
;;;189    		{
;;;190    			//DEBUG("%06dRight\r\n",index++);
;;;191    			
;;;192    //			bsp_SetMotorSpeed(MotorLeft,-12);
;;;193    //			bsp_SetMotorSpeed(MotorRight,-5);
;;;194    //			vTaskDelay(500);
;;;195    //			bsp_SetMotorSpeed(MotorLeft,5);
;;;196    //			bsp_SetMotorSpeed(MotorRight,5);
;;;197    		}
;;;198    		else if(collision == CollisionAll)
00000e  bf00              NOP      
                  |L7.16|
;;;199    		{
;;;200    			//DEBUG("%06dBoth\r\n",index++);
;;;201    			
;;;202    //			bsp_SetMotorSpeed(MotorLeft,-12);
;;;203    //			bsp_SetMotorSpeed(MotorRight,-12);
;;;204    //			vTaskDelay(500);
;;;205    //			bsp_SetMotorSpeed(MotorLeft,5);
;;;206    //			bsp_SetMotorSpeed(MotorRight,5);
;;;207    		}
;;;208    #endif
;;;209    		
;;;210    		//bsp_ScopeSend();
;;;211    		
;;;212    		vTaskDelay(50);
000010  2032              MOVS     r0,#0x32
000012  f7fffffe          BL       vTaskDelay
;;;213        }
000016  bf00              NOP      
                  |L7.24|
000018  e7f3              B        |L7.2|
;;;214    }
;;;215    
                          ENDP


                          AREA ||i.vTaskMsgPro||, CODE, READONLY, ALIGN=1

                  vTaskMsgPro PROC
;;;224    */
;;;225    static void vTaskMsgPro(void *pvParameters)
000000  e008              B        |L8.20|
                  |L8.2|
;;;226    {
;;;227        while(1)
;;;228        {
;;;229    		//bsp_SendReportFrame();
;;;230    		//bsp_PrintRemoteState();
;;;231    		
;;;232    		bsp_IWDG_Feed(); /* 喂狗 */
000002  f7fffffe          BL       bsp_IWDG_Feed
;;;233    		
;;;234    		bsp_PidSched(); /*10MS调用一次，这里面进行PWM计算，占空比设置，速度（脉冲为单位；MM为单位）计算*/
000006  f7fffffe          BL       bsp_PidSched
;;;235    		
;;;236    //		DEBUG("L %d MM/S\r\n",bsp_MotorGetSpeed(MotorLeft));
;;;237    //		DEBUG("R %d MM/S\r\n",bsp_MotorGetSpeed(MotorRight));
;;;238    		
;;;239    		bsp_ComAnalysis();
00000a  f7fffffe          BL       bsp_ComAnalysis
;;;240    		vTaskDelay(10);
00000e  200a              MOVS     r0,#0xa
000010  f7fffffe          BL       vTaskDelay
                  |L8.20|
000014  e7f5              B        |L8.2|
;;;241        }
;;;242    }
;;;243    
                          ENDP


                          AREA ||i.vTaskPerception||, CODE, READONLY, ALIGN=1

                  vTaskPerception PROC
;;;291    
;;;292    static void vTaskPerception(void *pvParameters)   //感知 获取传感器数据 红外对管、跳崖、碰撞、离地、电机电流、尘盒霍尔、编码器、航向角
000000  f7fffffe          BL       bsp_AngleRst
;;;293    {
;;;294    	bsp_AngleRst();
;;;295    	
;;;296    	bsp_DetectStart();  /*开启红外对管轮询扫描*/
000004  f7fffffe          BL       bsp_DetectStart
;;;297    	bsp_StartUpdatePos();
000008  f7fffffe          BL       bsp_StartUpdatePos
;;;298    	
;;;299    	 while(1)
00000c  e00a              B        |L9.36|
                  |L9.14|
;;;300        {
;;;301    		bsp_DetectAct();  /*红外对管轮询扫描*/
00000e  f7fffffe          BL       bsp_DetectAct
;;;302    		bsp_DetectDeal(); /*红外对管扫描结果处理*/
000012  f7fffffe          BL       bsp_DetectDeal
;;;303    		bsp_PositionUpdate(); /*更新坐标*/
000016  f7fffffe          BL       bsp_PositionUpdate
;;;304    		bsp_KeyScan();	
00001a  f7fffffe          BL       bsp_KeyScan
;;;305    		
;;;306            vTaskDelay(1);	
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       vTaskDelay
                  |L9.36|
000024  e7f3              B        |L9.14|
;;;307    	}
;;;308    	
;;;309    }
;;;310    static void vTaskControl(void *pvParameters)       //控制 根据决策控制电机
                          ENDP


                          AREA ||i.vTaskStart||, CODE, READONLY, ALIGN=1

                  vTaskStart PROC
;;;252    */
;;;253    static void vTaskStart(void *pvParameters)
000000  f7fffffe          BL       bsp_DetectStart
;;;254    {
;;;255    	/*开启红外对管轮询扫描*/
;;;256    	bsp_DetectStart(); 
;;;257    //	/*开启寻找充电桩*/
;;;258    //	bsp_StartSearchChargingPile();
;;;259    	bsp_StartUpdatePos();
000004  f7fffffe          BL       bsp_StartUpdatePos
;;;260    	
;;;261        while(1)
000008  e008              B        |L10.28|
                  |L10.10|
;;;262        {
;;;263    		bsp_DetectAct();  /*红外对管轮询扫描*/
00000a  f7fffffe          BL       bsp_DetectAct
;;;264    		bsp_DetectDeal(); /*红外对管扫描结果处理*/
00000e  f7fffffe          BL       bsp_DetectDeal
;;;265    //		bsp_EdgewiseAct();/*沿边*/
;;;266    //		
;;;267    //		/*四个红外接收管*/
;;;268    //		bsp_GetCapCnt(CapCH1);
;;;269    //		bsp_GetCapCnt(CapCH2);
;;;270    //		bsp_GetCapCnt(CapCH3);
;;;271    //		bsp_GetCapCnt(CapCH4);
;;;272    //		
;;;273    //		/*寻找充电桩*/
;;;274    //		bsp_SearchChargingPileAct();
;;;275    		/*更新坐标*/
;;;276    		bsp_PositionUpdate();
000012  f7fffffe          BL       bsp_PositionUpdate
;;;277    		
;;;278            vTaskDelay(1);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       vTaskDelay
                  |L10.28|
00001c  e7f5              B        |L10.10|
;;;279    		
;;;280    //		bsp_KeyScan();
;;;281    			
;;;282        }
;;;283    }
;;;284    
                          ENDP


                          AREA ||i.vTaskTaskUserIF||, CODE, READONLY, ALIGN=1

                  vTaskTaskUserIF PROC
;;;99     */
;;;100    static void vTaskTaskUserIF(void *pvParameters)
000000  f7fffffe          BL       bsp_AngleRst
;;;101    {
;;;102    	uint8_t ucKeyCode;	
;;;103    	bsp_AngleRst();
;;;104    
;;;105    #if 0
;;;106    		bsp_SetMotorSpeed(MotorLeft,5);
;;;107    		bsp_SetMotorSpeed(MotorRight,5);
;;;108    #endif	
;;;109    	
;;;110    #if 0	
;;;111    	bsp_SetMotorSpeed(MotorLeft,bsp_MotorSpeedMM2Pulse(-104));
;;;112    	bsp_SetMotorSpeed(MotorRight,bsp_MotorSpeedMM2Pulse(-104));
;;;113    #endif
;;;114    	
;;;115        while(1)
000004  e002              B        |L11.12|
                  |L11.6|
;;;116        {
;;;117    //		/* 处理按键事件 */
;;;118    //		ucKeyCode = bsp_GetKey();
;;;119    //		if (ucKeyCode > 0)
;;;120    //		{
;;;121    //			/* 有键按下 */
;;;122    //			switch (ucKeyCode)
;;;123    //			{
;;;124    //				case KEY_1_DOWN:/*按键1按下*/
;;;125    //				{
;;;126    //					
;;;127    //				}break;
;;;128    //				
;;;129    //				case KEY_2_DOWN:/*按键2按下*/
;;;130    //				{
;;;131    //					
;;;132    //				}break;
;;;133    //				
;;;134    //				case KEY_3_DOWN:/*按键3按下*/	
;;;135    //				{
;;;136    //					
;;;137    //				}break;
;;;138    
;;;139    //				case KEY_1_LONG:/*按键1长按*/	
;;;140    //				{
;;;141    //					
;;;142    //				}break;
;;;143    //				
;;;144    //				case KEY_2_LONG:/*按键2长按*/	
;;;145    //				{
;;;146    //					
;;;147    //				}break;
;;;148    //				
;;;149    //				case KEY_3_LONG:/*按键3长按*/	
;;;150    //				{
;;;151    //					
;;;152    //				}break;
;;;153    //			}
;;;154    //		}
;;;155    		vTaskDelay(20);
000006  2014              MOVS     r0,#0x14
000008  f7fffffe          BL       vTaskDelay
                  |L11.12|
00000c  e7fb              B        |L11.6|
;;;156    		
;;;157    	}
;;;158    }
;;;159    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  xHandleTaskUserIF
                          DCD      0x00000000
                  xHandleTaskLED
                          DCD      0x00000000
                  xHandleTaskMsgPro
                          DCD      0x00000000
                  xHandleTaskStart
                          DCD      0x00000000
                  xHandleTaskPerception
                          DCD      0x00000000
                  xHandleTaskDecision
                          DCD      0x00000000
                  xHandleTaskControl
                          DCD      0x00000000
                  xMutex
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_main____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_main_c_main____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_main____REVSH|
#line 128
|__asm___6_main_c_main____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
