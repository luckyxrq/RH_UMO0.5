; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_communication.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_communication.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\app\inc -IF:\LuckyXRQ\CleanCar\Project\MDK-ARM(uV4)\RTE -ID:\soft\MDK5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\soft\MDK5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_communication.crf ..\..\User\app\src\bsp_communication.c]
                          THUMB

                          AREA ||i.bsp_CalcChk||, CODE, READONLY, ALIGN=1

                  bsp_CalcChk PROC
;;;109    */
;;;110    static uint16_t bsp_CalcChk(uint8_t *buf, uint8_t len)
000000  b530              PUSH     {r4,r5,lr}
;;;111    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;112    	uint8_t  i;
;;;113    	uint16_t rx_sum1=0x00FFu;
000006  21ff              MOVS     r1,#0xff
;;;114    	uint16_t rx_sum2=0x00FFu;
000008  22ff              MOVS     r2,#0xff
;;;115    	
;;;116    	for(i=0; i<len; i++)
00000a  2300              MOVS     r3,#0
00000c  e007              B        |L1.30|
                  |L1.14|
;;;117    	{
;;;118    		rx_sum2 += rx_sum1 += buf[i];
00000e  5ce0              LDRB     r0,[r4,r3]
000010  4408              ADD      r0,r0,r1
000012  b280              UXTH     r0,r0
000014  4601              MOV      r1,r0
000016  4410              ADD      r0,r0,r2
000018  b282              UXTH     r2,r0
00001a  1c58              ADDS     r0,r3,#1              ;116
00001c  b2c3              UXTB     r3,r0                 ;116
                  |L1.30|
00001e  42ab              CMP      r3,r5                 ;116
000020  dbf5              BLT      |L1.14|
;;;119    	}
;;;120    	
;;;121    	rx_sum1 = (rx_sum1&0x00FFu) + (rx_sum1>>8);
000022  b2c8              UXTB     r0,r1
000024  eb002121          ADD      r1,r0,r1,ASR #8
;;;122    	rx_sum2 = (rx_sum2&0x00FFu) + (rx_sum2>>8);
000028  b2d0              UXTB     r0,r2
00002a  eb002222          ADD      r2,r0,r2,ASR #8
;;;123    	
;;;124    	return rx_sum2<<8|rx_sum1;
00002e  ea412002          ORR      r0,r1,r2,LSL #8
000032  b280              UXTH     r0,r0
;;;125    }
000034  bd30              POP      {r4,r5,pc}
;;;126    
                          ENDP


                          AREA ||i.bsp_FillReportFrame||, CODE, READONLY, ALIGN=2

                  bsp_FillReportFrame PROC
;;;55     */
;;;56     void bsp_FillReportFrame(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;57     {
;;;58     	uint16_t chk = 0 ;
000002  2400              MOVS     r4,#0
;;;59     	uint32_t len = sizeof(reportFrame);/*帧大小*/
000004  252b              MOVS     r5,#0x2b
;;;60     	uint8_t* src = (uint8_t*)&reportFrame;
000006  4e24              LDR      r6,|L2.152|
;;;61     	int16_t angle = bsp_AngleReadRaw();                     /*角度*/
000008  f7fffffe          BL       bsp_AngleReadRaw
00000c  9002              STR      r0,[sp,#8]
;;;62     	int32_t odometerL = 0;//bsp_encoderGetOdometer(MotorLeft);  /*里程计 左*/
00000e  2000              MOVS     r0,#0
000010  9001              STR      r0,[sp,#4]
;;;63     	int32_t odometerR = 0;//bsp_encoderGetOdometer(MotorRight); /*里程计 右*/
000012  9000              STR      r0,[sp,#0]
;;;64     	
;;;65     	/*消除编译器警告*/
;;;66     	UNUSED(reportFrame);
;;;67     	
;;;68     	/*大小端转换*/
;;;69     	reportFrame.sof1 = 0xAA;                     //恒定为0xAA
000014  20aa              MOVS     r0,#0xaa
000016  4631              MOV      r1,r6
000018  7008              STRB     r0,[r1,#0]
;;;70     	reportFrame.sof2 = 0xAA;                     //恒定为0xAA
00001a  7048              STRB     r0,[r1,#1]
;;;71     	reportFrame.sof3 = 0xAA;                     //恒定为0xAA
00001c  7088              STRB     r0,[r1,#2]
;;;72     	reportFrame.identifier = MIN_ID_ENVIRONMENT; //恒定为0x25
00001e  2030              MOVS     r0,#0x30
000020  70c8              STRB     r0,[r1,#3]
;;;73     	reportFrame.size_of_payload_field = 0x1B+8; 
000022  2023              MOVS     r0,#0x23
000024  7108              STRB     r0,[r1,#4]
;;;74     	reportFrame.left_wheel_pulse_count =  BEBufToUint32((uint8_t*)&odometerL);
000026  a801              ADD      r0,sp,#4
000028  f7fffffe          BL       BEBufToUint32
00002c  4631              MOV      r1,r6
00002e  f8c10005          STR      r0,[r1,#5]  ; reportFrame
;;;75     	reportFrame.right_wheel_pulse_count = BEBufToUint32((uint8_t*)&odometerR);
000032  4668              MOV      r0,sp
000034  f7fffffe          BL       BEBufToUint32
000038  4631              MOV      r1,r6
00003a  f8c10009          STR      r0,[r1,#9]  ; reportFrame
;;;76     	reportFrame.button_control_cmd = 0 ;
00003e  2000              MOVS     r0,#0
000040  7348              STRB     r0,[r1,#0xd]
;;;77     	reportFrame.distance_of_left_infrared = 0 ;
000042  81c8              STRH     r0,[r1,#0xe]
;;;78     	reportFrame.distance_of_right_infrared = 0 ;
000044  8208              STRH     r0,[r1,#0x10]
;;;79     	reportFrame.distance_of_front_infrared = 0 ;
000046  8248              STRH     r0,[r1,#0x12]
;;;80     	reportFrame.angle_deg = BEBufToUint16((uint8_t*)&angle);
000048  a802              ADD      r0,sp,#8
00004a  f7fffffe          BL       BEBufToUint16
00004e  b200              SXTH     r0,r0
000050  4631              MOV      r1,r6
000052  8288              STRH     r0,[r1,#0x14]
;;;81     	reportFrame.adc_1 = 0 ;
000054  2000              MOVS     r0,#0
000056  82c8              STRH     r0,[r1,#0x16]
;;;82     	reportFrame.adc_2 = 0 ;
000058  8308              STRH     r0,[r1,#0x18]
;;;83     	reportFrame.adc_3 = 0 ;
00005a  8348              STRH     r0,[r1,#0x1a]
;;;84     	reportFrame.adc_4 = 0 ;
00005c  8388              STRH     r0,[r1,#0x1c]
;;;85     	reportFrame.acc_x = 0 ;
00005e  83c8              STRH     r0,[r1,#0x1e]
;;;86     	reportFrame.acc_y = 0 ;
000060  8408              STRH     r0,[r1,#0x20]
;;;87     	reportFrame.acc_z = 0 ;
000062  8448              STRH     r0,[r1,#0x22]
;;;88     	reportFrame.obstacle_signal = 0 ;
000064  8488              STRH     r0,[r1,#0x24]
;;;89     	reportFrame.battery_level_soc = 0 ;
000066  f8810026          STRB     r0,[r1,#0x26]
;;;90     	reportFrame.charge_status = 0 ;
00006a  f8810027          STRB     r0,[r1,#0x27]
;;;91     	reportFrame.checksum_msb = 0 ;
00006e  f8810028          STRB     r0,[r1,#0x28]
;;;92     	reportFrame.checksum_lsb = 0 ;
000072  f8810029          STRB     r0,[r1,#0x29]
;;;93     	reportFrame.end_of_falg = 0x55 ;                  /*恒定0x55*/
000076  2055              MOVS     r0,#0x55
000078  f881002a          STRB     r0,[r1,#0x2a]
;;;94     	
;;;95     	/*计算校验*/
;;;96     	chk = bsp_CalcChk(src+3,len-6);
00007c  1fa8              SUBS     r0,r5,#6
00007e  b2c1              UXTB     r1,r0
000080  1cf0              ADDS     r0,r6,#3
000082  f7fffffe          BL       bsp_CalcChk
000086  4604              MOV      r4,r0
;;;97     	reportFrame.checksum_msb = chk >> 8;
000088  1220              ASRS     r0,r4,#8
00008a  4631              MOV      r1,r6
00008c  f8810028          STRB     r0,[r1,#0x28]
;;;98     	reportFrame.checksum_lsb = chk & 0x00FF;
000090  f8814029          STRB     r4,[r1,#0x29]
;;;99     }
000094  bdfe              POP      {r1-r7,pc}
;;;100    
                          ENDP

000096  0000              DCW      0x0000
                  |L2.152|
                          DCD      reportFrame

                          AREA ||i.bsp_SendReportFrame||, CODE, READONLY, ALIGN=2

                  bsp_SendReportFrame PROC
;;;26     */
;;;27     void bsp_SendReportFrame(void)
000000  b570              PUSH     {r4-r6,lr}
;;;28     {
;;;29     	
;;;30     	uint32_t len = sizeof(reportFrame);/*帧大小*/
000002  252b              MOVS     r5,#0x2b
;;;31     	uint8_t* src = (uint8_t*)&reportFrame;
000004  4e08              LDR      r6,|L3.40|
;;;32     	uint32_t i = 0 ;
000006  2400              MOVS     r4,#0
;;;33     	
;;;34     	/*填充数据*/
;;;35     	bsp_FillReportFrame();
000008  f7fffffe          BL       bsp_FillReportFrame
;;;36     	
;;;37     	/*填充帧*/
;;;38     	for(i=0;i<len;i++)
00000c  bf00              NOP      
00000e  e003              B        |L3.24|
                  |L3.16|
;;;39     	{
;;;40     		buf[i] = src[i];
000010  5d30              LDRB     r0,[r6,r4]
000012  4906              LDR      r1,|L3.44|
000014  5508              STRB     r0,[r1,r4]
000016  1c64              ADDS     r4,r4,#1              ;38
                  |L3.24|
000018  42ac              CMP      r4,r5                 ;38
00001a  d3f9              BCC      |L3.16|
;;;41     	}
;;;42     	
;;;43     	comSendBuf(COM4,buf,len);
00001c  b2aa              UXTH     r2,r5
00001e  4903              LDR      r1,|L3.44|
000020  2003              MOVS     r0,#3
000022  f7fffffe          BL       comSendBuf
;;;44     	
;;;45     }
000026  bd70              POP      {r4-r6,pc}
;;;46     
                          ENDP

                  |L3.40|
                          DCD      reportFrame
                  |L3.44|
                          DCD      buf

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  buf
                          %        256
                  reportFrame
                          %        43

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\src\\bsp_communication.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_bsp_communication_c_buf____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___19_bsp_communication_c_buf____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_bsp_communication_c_buf____REVSH|
#line 128
|__asm___19_bsp_communication_c_buf____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
