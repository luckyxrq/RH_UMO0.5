; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_control.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_control.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\app\inc -IF:\LuckyXRQ\CleanCar\Project\MDK-ARM(uV4)\RTE -ID:\soft\MDK5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\soft\MDK5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_control.crf ..\..\User\app\src\bsp_Control.c]
                          THUMB

                          AREA ||i.bsp_InitPid||, CODE, READONLY, ALIGN=2

                  bsp_InitPid PROC
;;;23     
;;;24     void bsp_InitPid(MotorSN sn)
000000  b948              CBNZ     r0,|L1.22|
;;;25     {
;;;26     	if(sn == MotorLeft)
;;;27     	{
;;;28     		/*给定KP KI参数*/
;;;29     		pid[0].kp = 20;
000002  490b              LDR      r1,|L1.48|
000004  4a0b              LDR      r2,|L1.52|
000006  6011              STR      r1,[r2,#0]  ; pid
;;;30     		pid[0].ki = 30;
000008  490b              LDR      r1,|L1.56|
00000a  6051              STR      r1,[r2,#4]  ; pid
;;;31     		/*清除之前的误差*/
;;;32     		pid[0].bias = 0 ;
00000c  2100              MOVS     r1,#0
00000e  6091              STR      r1,[r2,#8]  ; pid
;;;33     		pid[0].lastBias = 0 ;
000010  60d1              STR      r1,[r2,#0xc]  ; pid
;;;34     		pid[0].pwm = 0 ;
000012  6111              STR      r1,[r2,#0x10]  ; pid
000014  e00b              B        |L1.46|
                  |L1.22|
;;;35     	}
;;;36     	else if(sn == MotorRight)
000016  2801              CMP      r0,#1
000018  d109              BNE      |L1.46|
;;;37     	{
;;;38     		/*给定KP KI参数*/
;;;39     		pid[1].kp = 20;
00001a  4905              LDR      r1,|L1.48|
00001c  4a05              LDR      r2,|L1.52|
00001e  6151              STR      r1,[r2,#0x14]  ; pid
;;;40     		pid[1].ki = 30;
000020  4a05              LDR      r2,|L1.56|
000022  4904              LDR      r1,|L1.52|
000024  618a              STR      r2,[r1,#0x18]
;;;41     		/*清除之前的误差*/
;;;42     		pid[1].bias = 0 ;
000026  2200              MOVS     r2,#0
000028  61ca              STR      r2,[r1,#0x1c]
;;;43     		pid[1].lastBias = 0 ;
00002a  620a              STR      r2,[r1,#0x20]
;;;44     		pid[1].pwm = 0 ;
00002c  624a              STR      r2,[r1,#0x24]
                  |L1.46|
;;;45     	}
;;;46     }
00002e  4770              BX       lr
;;;47     
                          ENDP

                  |L1.48|
                          DCD      0x41a00000
                  |L1.52|
                          DCD      pid
                  |L1.56|
                          DCD      0x41f00000

                          AREA ||i.bsp_PidClear||, CODE, READONLY, ALIGN=2

                  bsp_PidClear PROC
;;;48     
;;;49     void bsp_PidClear(MotorSN sn)
000000  b928              CBNZ     r0,|L2.14|
;;;50     {
;;;51     	if(sn == MotorLeft)
;;;52     	{
;;;53     		/*清除之前的误差*/
;;;54     		pid[0].bias = 0 ;
000002  2100              MOVS     r1,#0
000004  4a06              LDR      r2,|L2.32|
000006  6091              STR      r1,[r2,#8]  ; pid
;;;55     		pid[0].lastBias = 0 ;
000008  60d1              STR      r1,[r2,#0xc]  ; pid
;;;56     		pid[0].pwm = 0 ;
00000a  6111              STR      r1,[r2,#0x10]  ; pid
00000c  e006              B        |L2.28|
                  |L2.14|
;;;57     	}
;;;58     	else if(sn == MotorRight)
00000e  2801              CMP      r0,#1
000010  d104              BNE      |L2.28|
;;;59     	{
;;;60     		/*清除之前的误差*/
;;;61     		pid[1].bias = 0 ;
000012  2200              MOVS     r2,#0
000014  4902              LDR      r1,|L2.32|
000016  61ca              STR      r2,[r1,#0x1c]
;;;62     		pid[1].lastBias = 0 ;
000018  620a              STR      r2,[r1,#0x20]
;;;63     		pid[1].pwm = 0 ;
00001a  624a              STR      r2,[r1,#0x24]
                  |L2.28|
;;;64     	}
;;;65     }
00001c  4770              BX       lr
;;;66     
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      pid

                          AREA ||i.bsp_PidExec||, CODE, READONLY, ALIGN=2

                  bsp_PidExec PROC
;;;67     
;;;68     void bsp_PidExec(MotorSN sn , int32_t Encoder, int32_t Target)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;69     {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;70     
;;;71     	/*如果目标速度小于0，那么编码器的反馈速度也应该为负，单个霍尔只能计数，没有正负*/
;;;72     	if(Target < 0 ) 
00000a  2d00              CMP      r5,#0
00000c  da00              BGE      |L3.16|
;;;73     	{
;;;74     		Encoder = -Encoder;
00000e  4264              RSBS     r4,r4,#0
                  |L3.16|
;;;75     	}
;;;76     		
;;;77     	/*计算PWM值，增量式PID*/
;;;78     	if(sn == MotorLeft)
000010  2e00              CMP      r6,#0
000012  d146              BNE      |L3.162|
;;;79     	{
;;;80     		pid[0].bias = Encoder-Target;                                  
000014  1b60              SUBS     r0,r4,r5
000016  f7fffffe          BL       __aeabi_i2f
00001a  4947              LDR      r1,|L3.312|
00001c  6088              STR      r0,[r1,#8]  ; pid
;;;81     		pid[0].pwm += pid[0].kp*(pid[0].bias-pid[0].lastBias)+pid[0].ki*pid[0].bias;
00001e  460a              MOV      r2,r1
000020  6891              LDR      r1,[r2,#8]  ; pid
000022  6850              LDR      r0,[r2,#4]  ; pid
000024  f7fffffe          BL       __aeabi_fmul
000028  4681              MOV      r9,r0
00002a  4a43              LDR      r2,|L3.312|
00002c  68d1              LDR      r1,[r2,#0xc]  ; pid
00002e  6890              LDR      r0,[r2,#8]  ; pid
000030  f7fffffe          BL       __aeabi_fsub
000034  4682              MOV      r10,r0
000036  4840              LDR      r0,|L3.312|
000038  6801              LDR      r1,[r0,#0]  ; pid
00003a  4650              MOV      r0,r10
00003c  f7fffffe          BL       __aeabi_fmul
000040  4680              MOV      r8,r0
000042  4649              MOV      r1,r9
000044  f7fffffe          BL       __aeabi_fadd
000048  4607              MOV      r7,r0
00004a  483b              LDR      r0,|L3.312|
00004c  6901              LDR      r1,[r0,#0x10]  ; pid
00004e  4638              MOV      r0,r7
000050  f7fffffe          BL       __aeabi_fadd
000054  4938              LDR      r1,|L3.312|
000056  6108              STR      r0,[r1,#0x10]  ; pid
;;;82     		pid[0].lastBias=pid[0].bias;
000058  4608              MOV      r0,r1
00005a  6880              LDR      r0,[r0,#8]  ; pid
00005c  60c8              STR      r0,[r1,#0xc]  ; pid
;;;83     		/*限幅*/
;;;84     		pid[0].pwm = bsp_PwmLimit(pid[0].pwm);	
00005e  6908              LDR      r0,[r1,#0x10]  ; pid
000060  f7fffffe          BL       __aeabi_f2iz
000064  4680              MOV      r8,r0
000066  f7fffffe          BL       bsp_PwmLimit
00006a  4607              MOV      r7,r0
00006c  f7fffffe          BL       __aeabi_i2f
000070  4931              LDR      r1,|L3.312|
000072  6108              STR      r0,[r1,#0x10]  ; pid
;;;85     		/*设置PWM*/
;;;86     		bsp_MotorSetPWM(MotorLeft,pid[0].pwm >0 ? Backward : Forward ,myabs(pid[0].pwm));
000074  6908              LDR      r0,[r1,#0x10]  ; pid
000076  f7fffffe          BL       __aeabi_f2iz
00007a  4681              MOV      r9,r0
00007c  f7fffffe          BL       myabs
000080  b287              UXTH     r7,r0
000082  492d              LDR      r1,|L3.312|
000084  6908              LDR      r0,[r1,#0x10]  ; pid
000086  2100              MOVS     r1,#0
000088  f7fffffe          BL       __aeabi_cfrcmple
00008c  d201              BCS      |L3.146|
00008e  2001              MOVS     r0,#1
000090  e000              B        |L3.148|
                  |L3.146|
000092  2000              MOVS     r0,#0
                  |L3.148|
000094  4680              MOV      r8,r0
000096  463a              MOV      r2,r7
000098  4641              MOV      r1,r8
00009a  2000              MOVS     r0,#0
00009c  f7fffffe          BL       bsp_MotorSetPWM
0000a0  e048              B        |L3.308|
                  |L3.162|
;;;87     	}
;;;88     	else if(sn == MotorRight)
0000a2  2e01              CMP      r6,#1
0000a4  d146              BNE      |L3.308|
;;;89     	{
;;;90     		pid[1].bias = Encoder-Target;                                
0000a6  1b60              SUBS     r0,r4,r5
0000a8  f7fffffe          BL       __aeabi_i2f
0000ac  4922              LDR      r1,|L3.312|
0000ae  61c8              STR      r0,[r1,#0x1c]
;;;91     		pid[1].pwm += pid[1].kp*(pid[1].bias-pid[1].lastBias)+pid[1].ki*pid[1].bias;
0000b0  460a              MOV      r2,r1
0000b2  69d1              LDR      r1,[r2,#0x1c]
0000b4  6990              LDR      r0,[r2,#0x18]
0000b6  f7fffffe          BL       __aeabi_fmul
0000ba  4681              MOV      r9,r0
0000bc  4a1e              LDR      r2,|L3.312|
0000be  6a11              LDR      r1,[r2,#0x20]
0000c0  69d0              LDR      r0,[r2,#0x1c]
0000c2  f7fffffe          BL       __aeabi_fsub
0000c6  4682              MOV      r10,r0
0000c8  481b              LDR      r0,|L3.312|
0000ca  6941              LDR      r1,[r0,#0x14]  ; pid
0000cc  4650              MOV      r0,r10
0000ce  f7fffffe          BL       __aeabi_fmul
0000d2  4680              MOV      r8,r0
0000d4  4649              MOV      r1,r9
0000d6  f7fffffe          BL       __aeabi_fadd
0000da  4607              MOV      r7,r0
0000dc  4816              LDR      r0,|L3.312|
0000de  6a41              LDR      r1,[r0,#0x24]
0000e0  4638              MOV      r0,r7
0000e2  f7fffffe          BL       __aeabi_fadd
0000e6  4914              LDR      r1,|L3.312|
0000e8  6248              STR      r0,[r1,#0x24]
;;;92     		pid[1].lastBias=pid[1].bias;
0000ea  4608              MOV      r0,r1
0000ec  69c1              LDR      r1,[r0,#0x1c]
0000ee  6201              STR      r1,[r0,#0x20]
;;;93     		/*限幅*/
;;;94     		pid[1].pwm = bsp_PwmLimit(pid[1].pwm);
0000f0  4601              MOV      r1,r0
0000f2  6a48              LDR      r0,[r1,#0x24]
0000f4  f7fffffe          BL       __aeabi_f2iz
0000f8  4680              MOV      r8,r0
0000fa  f7fffffe          BL       bsp_PwmLimit
0000fe  4607              MOV      r7,r0
000100  f7fffffe          BL       __aeabi_i2f
000104  490c              LDR      r1,|L3.312|
000106  6248              STR      r0,[r1,#0x24]
;;;95     		/*设置PWM*/
;;;96     		bsp_MotorSetPWM(MotorRight,pid[1].pwm >0 ? Backward : Forward ,myabs(pid[1].pwm));
000108  6a48              LDR      r0,[r1,#0x24]
00010a  f7fffffe          BL       __aeabi_f2iz
00010e  4681              MOV      r9,r0
000110  f7fffffe          BL       myabs
000114  b287              UXTH     r7,r0
000116  4908              LDR      r1,|L3.312|
000118  6a48              LDR      r0,[r1,#0x24]
00011a  2100              MOVS     r1,#0
00011c  f7fffffe          BL       __aeabi_cfrcmple
000120  d201              BCS      |L3.294|
000122  2001              MOVS     r0,#1
000124  e000              B        |L3.296|
                  |L3.294|
000126  2000              MOVS     r0,#0
                  |L3.296|
000128  4680              MOV      r8,r0
00012a  463a              MOV      r2,r7
00012c  4641              MOV      r1,r8
00012e  2001              MOVS     r0,#1
000130  f7fffffe          BL       bsp_MotorSetPWM
                  |L3.308|
;;;97     	}
;;;98     	
;;;99     }
000134  e8bd87f0          POP      {r4-r10,pc}
;;;100    
                          ENDP

                  |L3.312|
                          DCD      pid

                          AREA ||i.bsp_PwmLimit||, CODE, READONLY, ALIGN=2

                  bsp_PwmLimit PROC
;;;102    
;;;103    static int32_t bsp_PwmLimit(int32_t pwm)
000000  4601              MOV      r1,r0
;;;104    {
;;;105    	int32_t ret = 0 ;
000002  2000              MOVS     r0,#0
;;;106    	
;;;107    	if(pwm >= MAX_PWM)
000004  f5b16f61          CMP      r1,#0xe10
000008  db02              BLT      |L4.16|
;;;108    	{
;;;109    		ret = MAX_PWM;
00000a  f44f6061          MOV      r0,#0xe10
00000e  e005              B        |L4.28|
                  |L4.16|
;;;110    	}
;;;111    	else if(pwm <= -MAX_PWM)
000010  f5116f61          CMN      r1,#0xe10
000014  dc01              BGT      |L4.26|
;;;112    	{
;;;113    		ret = -MAX_PWM;
000016  4802              LDR      r0,|L4.32|
000018  e000              B        |L4.28|
                  |L4.26|
;;;114    	}
;;;115    	else
;;;116    	{
;;;117    		ret = pwm;
00001a  4608              MOV      r0,r1
                  |L4.28|
;;;118    	}
;;;119    	
;;;120    	return ret;
;;;121    }	
00001c  4770              BX       lr
;;;122    
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0xfffff1f0

                          AREA ||i.myabs||, CODE, READONLY, ALIGN=1

                  myabs PROC
;;;131    */
;;;132    int32_t myabs(int32_t val)
000000  4601              MOV      r1,r0
;;;133    { 		   
;;;134        int32_t temp;
;;;135    	
;;;136        if(val < 0)  
000002  2900              CMP      r1,#0
000004  da01              BGE      |L5.10|
;;;137    		temp = -val;  
000006  4248              RSBS     r0,r1,#0
000008  e000              B        |L5.12|
                  |L5.10|
;;;138        else 
;;;139    		temp = val;
00000a  4608              MOV      r0,r1
                  |L5.12|
;;;140    	
;;;141        return temp;
;;;142    }
00000c  4770              BX       lr
;;;143    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pid
                          %        40

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\src\\bsp_Control.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_Control_c_03aaa559____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_Control_c_03aaa559____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_Control_c_03aaa559____REVSH|
#line 128
|__asm___13_bsp_Control_c_03aaa559____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
