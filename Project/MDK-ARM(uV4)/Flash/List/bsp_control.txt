; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_control.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_control.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\app\inc -IF:\LuckyXRQ\CleanCar\Project\MDK-ARM(uV4)\RTE -ID:\soft\MDK5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\soft\MDK5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_control.crf ..\..\User\app\src\bsp_Control.c]
                          THUMB

                          AREA ||i.bsp_InitPid||, CODE, READONLY, ALIGN=2

                  bsp_InitPid PROC
;;;42     */
;;;43     void bsp_InitPid(MotorSN sn)
000000  b958              CBNZ     r0,|L1.26|
;;;44     {
;;;45     	if(sn == MotorLeft)
;;;46     	{
;;;47     		/*给定KP KI参数*/
;;;48     		pid[0].kp = 5;
000002  490d              LDR      r1,|L1.56|
000004  4a0d              LDR      r2,|L1.60|
000006  6011              STR      r1,[r2,#0]  ; pid
;;;49     		pid[0].ki = 10;
000008  490d              LDR      r1,|L1.64|
00000a  6051              STR      r1,[r2,#4]  ; pid
;;;50     		/*清除之前的误差*/
;;;51     		pid[0].bias = 0 ;
00000c  2100              MOVS     r1,#0
00000e  6091              STR      r1,[r2,#8]  ; pid
;;;52     		pid[0].lastBias = 0 ;
000010  60d1              STR      r1,[r2,#0xc]  ; pid
;;;53     		pid[0].pwm = 0 ;
000012  6111              STR      r1,[r2,#0x10]  ; pid
;;;54     		/*目的速度*/
;;;55     		pid[0].target = 0 ;
000014  6151              STR      r1,[r2,#0x14]  ; pid
;;;56     		/*上一次目的速度*/
;;;57     		pid[0].lastTarget = 0 ;
000016  6191              STR      r1,[r2,#0x18]  ; pid
000018  e00d              B        |L1.54|
                  |L1.26|
;;;58     	}
;;;59     	else if(sn == MotorRight)
00001a  2801              CMP      r0,#1
00001c  d10b              BNE      |L1.54|
;;;60     	{
;;;61     		/*给定KP KI参数*/
;;;62     		pid[1].kp = 5;
00001e  4906              LDR      r1,|L1.56|
000020  4a06              LDR      r2,|L1.60|
000022  61d1              STR      r1,[r2,#0x1c]  ; pid
;;;63     		pid[1].ki = 10;
000024  4a06              LDR      r2,|L1.64|
000026  4905              LDR      r1,|L1.60|
000028  620a              STR      r2,[r1,#0x20]
;;;64     		/*清除之前的误差*/
;;;65     		pid[1].bias = 0 ;
00002a  2200              MOVS     r2,#0
00002c  624a              STR      r2,[r1,#0x24]
;;;66     		pid[1].lastBias = 0 ;
00002e  628a              STR      r2,[r1,#0x28]
;;;67     		pid[1].pwm = 0 ;
000030  62ca              STR      r2,[r1,#0x2c]
;;;68     		/*目的速度*/
;;;69     		pid[1].target = 0 ;
000032  630a              STR      r2,[r1,#0x30]
;;;70     		/*上一次速度*/
;;;71     		pid[1].lastTarget = 0 ;
000034  634a              STR      r2,[r1,#0x34]
                  |L1.54|
;;;72     	}
;;;73     }
000036  4770              BX       lr
;;;74     
                          ENDP

                  |L1.56|
                          DCD      0x40a00000
                  |L1.60|
                          DCD      pid
                  |L1.64|
                          DCD      0x41200000

                          AREA ||i.bsp_MotorBrake||, CODE, READONLY, ALIGN=2

                  bsp_MotorBrake PROC
;;;237    */
;;;238    static void bsp_MotorBrake(MotorSN sn)
000000  b510              PUSH     {r4,lr}
;;;239    {
000002  4604              MOV      r4,r0
;;;240    	if(sn == MotorLeft)
000004  b954              CBNZ     r4,|L2.28|
;;;241    	{
;;;242    		TIM_SetCompare3(TIM1,CONSTANT_HIGH_PWM);
000006  f44f6161          MOV      r1,#0xe10
00000a  480b              LDR      r0,|L2.56|
00000c  f7fffffe          BL       TIM_SetCompare3
;;;243    		TIM_SetCompare4(TIM1,CONSTANT_HIGH_PWM);
000010  f44f6161          MOV      r1,#0xe10
000014  4808              LDR      r0,|L2.56|
000016  f7fffffe          BL       TIM_SetCompare4
00001a  e00b              B        |L2.52|
                  |L2.28|
;;;244    	}
;;;245    	else if(sn == MotorRight)
00001c  2c01              CMP      r4,#1
00001e  d109              BNE      |L2.52|
;;;246    	{
;;;247    		TIM_SetCompare1(TIM1,CONSTANT_HIGH_PWM);
000020  f44f6161          MOV      r1,#0xe10
000024  4804              LDR      r0,|L2.56|
000026  f7fffffe          BL       TIM_SetCompare1
;;;248    		TIM_SetCompare2(TIM1,CONSTANT_HIGH_PWM);
00002a  f44f6161          MOV      r1,#0xe10
00002e  4802              LDR      r0,|L2.56|
000030  f7fffffe          BL       TIM_SetCompare2
                  |L2.52|
;;;249    	}
;;;250    
;;;251    }
000034  bd10              POP      {r4,pc}
;;;252    
                          ENDP

000036  0000              DCW      0x0000
                  |L2.56|
                          DCD      0x40012c00

                          AREA ||i.bsp_MotorGetPulseVector||, CODE, READONLY, ALIGN=2

                  bsp_MotorGetPulseVector PROC
;;;191    */
;;;192    int32_t bsp_MotorGetPulseVector(MotorSN sn)
000000  4601              MOV      r1,r0
;;;193    {
;;;194    	return encoderPulseVector[sn];
000002  4802              LDR      r0,|L3.12|
000004  f8500021          LDR      r0,[r0,r1,LSL #2]
;;;195    }
000008  4770              BX       lr
;;;196    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      encoderPulseVector

                          AREA ||i.bsp_MotorGetSpeed||, CODE, READONLY, ALIGN=2

                  bsp_MotorGetSpeed PROC
;;;130    */
;;;131    int32_t bsp_MotorGetSpeed(MotorSN sn)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;132    {
000004  4605              MOV      r5,r0
;;;133    	uint8_t i = 0 ;
000006  2400              MOVS     r4,#0
;;;134    	int32_t sum = 0 ;
000008  2600              MOVS     r6,#0
;;;135    	int32_t ret = 0 ;
00000a  2700              MOVS     r7,#0
;;;136    	
;;;137    	for(i=0; i< SPEED_SAMP_COUNT ; i++)
00000c  bf00              NOP      
00000e  e009              B        |L4.36|
                  |L4.16|
;;;138    	{
;;;139    		sum += speed[sn][i];
000010  eb050085          ADD      r0,r5,r5,LSL #2
000014  490b              LDR      r1,|L4.68|
000016  eb0100c0          ADD      r0,r1,r0,LSL #3
00001a  f8500024          LDR      r0,[r0,r4,LSL #2]
00001e  4406              ADD      r6,r6,r0
000020  1c60              ADDS     r0,r4,#1              ;137
000022  b2c4              UXTB     r4,r0                 ;137
                  |L4.36|
000024  2c0a              CMP      r4,#0xa               ;137
000026  dbf3              BLT      |L4.16|
;;;140    	}
;;;141    	
;;;142    	ret = (float)sum / (float)SPEED_SAMP_COUNT;
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       __aeabi_i2f
00002e  4681              MOV      r9,r0
000030  4905              LDR      r1,|L4.72|
000032  f7fffffe          BL       __aeabi_fdiv
000036  4680              MOV      r8,r0
000038  f7fffffe          BL       __aeabi_f2iz
00003c  4607              MOV      r7,r0
;;;143    	
;;;144    	return ret;
00003e  4638              MOV      r0,r7
;;;145    }
000040  e8bd87f0          POP      {r4-r10,pc}
;;;146    
                          ENDP

                  |L4.68|
                          DCD      speed
                  |L4.72|
                          DCD      0x41200000

                          AREA ||i.bsp_MotorGetTargetSpeed||, CODE, READONLY, ALIGN=2

                  bsp_MotorGetTargetSpeed PROC
;;;102    */
;;;103    int32_t bsp_MotorGetTargetSpeed(MotorSN sn)
000000  4601              MOV      r1,r0
;;;104    {
;;;105    	return pid[sn].target;
000002  ebc100c1          RSB      r0,r1,r1,LSL #3
000006  4a02              LDR      r2,|L5.16|
000008  eb020080          ADD      r0,r2,r0,LSL #2
00000c  6940              LDR      r0,[r0,#0x14]
;;;106    }
00000e  4770              BX       lr
;;;107    
                          ENDP

                  |L5.16|
                          DCD      pid

                          AREA ||i.bsp_MotorSpeedMM2Pulse||, CODE, READONLY, ALIGN=2

                  bsp_MotorSpeedMM2Pulse PROC
;;;155    */
;;;156    int32_t bsp_MotorSpeedMM2Pulse(int16_t mm)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;157    {
000004  4604              MOV      r4,r0
;;;158    	int32_t ret = 0 ;
000006  2500              MOVS     r5,#0
;;;159    	float pulse = 0 ;
000008  2600              MOVS     r6,#0
;;;160    
;;;161    	if(mm == 0)
00000a  b914              CBNZ     r4,|L6.18|
;;;162    	{
;;;163    		return 0;
00000c  2000              MOVS     r0,#0
                  |L6.14|
;;;164    	}
;;;165    
;;;166    	pulse = mm * 12.0F / 250.0F ;
;;;167    	
;;;168    	if(pulse >0 && pulse <= 1.0F)
;;;169    	{
;;;170    		ret = 1 ;
;;;171    	}
;;;172    	else if(pulse >= -1.0F && pulse < 0)
;;;173    	{
;;;174    		ret = -1 ;
;;;175    	}
;;;176    	else
;;;177    	{
;;;178    		ret = pulse;
;;;179    	}
;;;180    	
;;;181    	return ret;
;;;182    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L6.18|
000012  4620              MOV      r0,r4                 ;166
000014  f7fffffe          BL       __aeabi_i2f
000018  4680              MOV      r8,r0                 ;166
00001a  4914              LDR      r1,|L6.108|
00001c  f7fffffe          BL       __aeabi_fmul
000020  4607              MOV      r7,r0                 ;166
000022  4913              LDR      r1,|L6.112|
000024  f7fffffe          BL       __aeabi_fdiv
000028  4606              MOV      r6,r0                 ;166
00002a  2100              MOVS     r1,#0                 ;168
00002c  4630              MOV      r0,r6                 ;168
00002e  f7fffffe          BL       __aeabi_cfrcmple
000032  d207              BCS      |L6.68|
000034  f04f517e          MOV      r1,#0x3f800000        ;168
000038  4630              MOV      r0,r6                 ;168
00003a  f7fffffe          BL       __aeabi_cfcmple
00003e  d801              BHI      |L6.68|
000040  2501              MOVS     r5,#1                 ;170
000042  e010              B        |L6.102|
                  |L6.68|
000044  490b              LDR      r1,|L6.116|
000046  4630              MOV      r0,r6                 ;172
000048  f7fffffe          BL       __aeabi_cfrcmple
00004c  d807              BHI      |L6.94|
00004e  2100              MOVS     r1,#0                 ;172
000050  4630              MOV      r0,r6                 ;172
000052  f7fffffe          BL       __aeabi_cfcmple
000056  d202              BCS      |L6.94|
000058  f04f35ff          MOV      r5,#0xffffffff        ;174
00005c  e003              B        |L6.102|
                  |L6.94|
00005e  4630              MOV      r0,r6                 ;178
000060  f7fffffe          BL       __aeabi_f2iz
000064  4605              MOV      r5,r0                 ;178
                  |L6.102|
000066  4628              MOV      r0,r5                 ;181
000068  e7d1              B        |L6.14|
;;;183    
                          ENDP

00006a  0000              DCW      0x0000
                  |L6.108|
                          DCD      0x41400000
                  |L6.112|
                          DCD      0x437a0000
                  |L6.116|
                          DCD      0xbf800000

                          AREA ||i.bsp_PidClear||, CODE, READONLY, ALIGN=2

                  bsp_PidClear PROC
;;;205    */
;;;206    static void bsp_PidClear(MotorSN sn)
000000  b930              CBNZ     r0,|L7.16|
;;;207    {
;;;208    	if(sn == MotorLeft)
;;;209    	{
;;;210    		/*清除之前的误差*/
;;;211    		pid[0].bias = 0 ;
000002  2100              MOVS     r1,#0
000004  4a07              LDR      r2,|L7.36|
000006  6091              STR      r1,[r2,#8]  ; pid
;;;212    		pid[0].lastBias = 0 ;
000008  60d1              STR      r1,[r2,#0xc]  ; pid
;;;213    		pid[0].pwm = 0 ;
00000a  6111              STR      r1,[r2,#0x10]  ; pid
;;;214    
;;;215    		/*上一次目的速度*/
;;;216    		pid[0].lastTarget = 0 ;
00000c  6191              STR      r1,[r2,#0x18]  ; pid
00000e  e007              B        |L7.32|
                  |L7.16|
;;;217    	}
;;;218    	else if(sn == MotorRight)
000010  2801              CMP      r0,#1
000012  d105              BNE      |L7.32|
;;;219    	{
;;;220    		/*清除之前的误差*/
;;;221    		pid[1].bias = 0 ;
000014  2200              MOVS     r2,#0
000016  4903              LDR      r1,|L7.36|
000018  624a              STR      r2,[r1,#0x24]
;;;222    		pid[1].lastBias = 0 ;
00001a  628a              STR      r2,[r1,#0x28]
;;;223    		pid[1].pwm = 0 ;
00001c  62ca              STR      r2,[r1,#0x2c]
;;;224    
;;;225    		/*上一次目的速度*/
;;;226    		pid[1].lastTarget = 0 ;
00001e  634a              STR      r2,[r1,#0x34]
                  |L7.32|
;;;227    	}
;;;228    }
000020  4770              BX       lr
;;;229    
                          ENDP

000022  0000              DCW      0x0000
                  |L7.36|
                          DCD      pid

                          AREA ||i.bsp_PidExec||, CODE, READONLY, ALIGN=2

                  bsp_PidExec PROC
;;;260    */
;;;261    static void bsp_PidExec(MotorSN sn , int32_t Encoder, int32_t Target)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;262    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;263    	/*如果目标速度为0*/
;;;264    	if(Target == 0)
00000a  b92d              CBNZ     r5,|L8.24|
;;;265    	{
;;;266    		bsp_MotorBrake(sn);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       bsp_MotorBrake
;;;267    		bsp_PidClear(sn);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       bsp_PidClear
                  |L8.24|
;;;268    	}
;;;269    	
;;;270    	
;;;271    	/*如果目标速度小于0，那么编码器的反馈速度也应该为负，单个霍尔只能计数，没有正负*/
;;;272    	if(Target < 0 ) 
000018  2d00              CMP      r5,#0
00001a  da00              BGE      |L8.30|
;;;273    	{
;;;274    		Encoder = -Encoder;
00001c  4276              RSBS     r6,r6,#0
                  |L8.30|
;;;275    	}
;;;276    	
;;;277    	/*统计左右轮机转动的脉冲数，带方向的*/
;;;278    	encoderPulseVector[sn] += Encoder;
00001e  487f              LDR      r0,|L8.540|
000020  f8500024          LDR      r0,[r0,r4,LSL #2]
000024  4430              ADD      r0,r0,r6
000026  497d              LDR      r1,|L8.540|
000028  f8410024          STR      r0,[r1,r4,LSL #2]
;;;279    	
;;;280    	/*计算速度，250MM/S时，10MS有12个脉冲*/
;;;281    	speed[sn][sampleIndex[sn]++] = Encoder / 12.0F * 250;
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       __aeabi_i2f
000032  4681              MOV      r9,r0
000034  497a              LDR      r1,|L8.544|
000036  f7fffffe          BL       __aeabi_fdiv
00003a  4680              MOV      r8,r0
00003c  4979              LDR      r1,|L8.548|
00003e  f7fffffe          BL       __aeabi_fmul
000042  4607              MOV      r7,r0
000044  f7fffffe          BL       __aeabi_f2iz
000048  4977              LDR      r1,|L8.552|
00004a  5d0a              LDRB     r2,[r1,r4]
00004c  5d09              LDRB     r1,[r1,r4]
00004e  1c49              ADDS     r1,r1,#1
000050  4b75              LDR      r3,|L8.552|
000052  5519              STRB     r1,[r3,r4]
000054  eb040184          ADD      r1,r4,r4,LSL #2
000058  4b74              LDR      r3,|L8.556|
00005a  eb0301c1          ADD      r1,r3,r1,LSL #3
00005e  f8410022          STR      r0,[r1,r2,LSL #2]
;;;282    	if(sampleIndex[sn] >= SPEED_SAMP_COUNT)
000062  4871              LDR      r0,|L8.552|
000064  5d00              LDRB     r0,[r0,r4]
000066  280a              CMP      r0,#0xa
000068  db02              BLT      |L8.112|
;;;283    	{
;;;284    		sampleIndex[sn] = 0 ;
00006a  2000              MOVS     r0,#0
00006c  496e              LDR      r1,|L8.552|
00006e  5508              STRB     r0,[r1,r4]
                  |L8.112|
;;;285    	}
;;;286    		
;;;287    	/*计算PWM值，增量式PID*/
;;;288    	if(sn == MotorLeft && !Target)
000070  2c00              CMP      r4,#0
000072  d167              BNE      |L8.324|
000074  2d00              CMP      r5,#0
000076  d165              BNE      |L8.324|
;;;289    	{
;;;290    		if(pid[0].lastTarget == 0) /*从0速启动*/
000078  486d              LDR      r0,|L8.560|
00007a  6980              LDR      r0,[r0,#0x18]  ; pid
00007c  b910              CBNZ     r0,|L8.132|
;;;291    		{
;;;292    			pid[0].lastTarget = Target;
00007e  486c              LDR      r0,|L8.560|
000080  6185              STR      r5,[r0,#0x18]  ; pid
000082  e018              B        |L8.182|
                  |L8.132|
;;;293    		}
;;;294    		else if(pid[0].lastTarget / (float)Target < 0) /*2次目标速度方向相反*/
000084  4628              MOV      r0,r5
000086  f7fffffe          BL       __aeabi_i2f
00008a  4680              MOV      r8,r0
00008c  4968              LDR      r1,|L8.560|
00008e  6988              LDR      r0,[r1,#0x18]  ; pid
000090  f7fffffe          BL       __aeabi_i2f
000094  4681              MOV      r9,r0
000096  4641              MOV      r1,r8
000098  f7fffffe          BL       __aeabi_fdiv
00009c  4607              MOV      r7,r0
00009e  2100              MOVS     r1,#0
0000a0  f7fffffe          BL       __aeabi_cfcmple
0000a4  d207              BCS      |L8.182|
;;;295    		{
;;;296    			bsp_MotorBrake(sn);
0000a6  4620              MOV      r0,r4
0000a8  f7fffffe          BL       bsp_MotorBrake
;;;297    			bsp_PidClear(sn);
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       bsp_PidClear
                  |L8.178|
;;;298    			return ;
;;;299    		}
;;;300    		
;;;301    		pid[0].bias = Encoder-Target;                                  
;;;302    		pid[0].pwm += pid[0].kp*(pid[0].bias-pid[0].lastBias)+pid[0].ki*pid[0].bias;
;;;303    		pid[0].lastBias=pid[0].bias;
;;;304    		/*限幅*/
;;;305    		pid[0].pwm = bsp_PwmLimit(pid[0].pwm);	
;;;306    		/*设置PWM*/
;;;307    		bsp_MotorSetPWM(MotorLeft,pid[0].pwm >0 ? Backward : Forward ,myabs(pid[0].pwm));
;;;308    	}
;;;309    	else if(sn == MotorRight && !Target)
;;;310    	{
;;;311    		if(pid[1].lastTarget == 0) /*从0速启动*/
;;;312    		{
;;;313    			pid[1].lastTarget = Target;
;;;314    		}
;;;315    		else if(pid[1].lastTarget / (float)Target < 0) /*2次目标速度方向相反*/
;;;316    		{
;;;317    			bsp_MotorBrake(sn);
;;;318    			bsp_PidClear(sn);
;;;319    			return ;
;;;320    		}
;;;321    		
;;;322    		pid[1].bias = Encoder-Target;                                
;;;323    		pid[1].pwm += pid[1].kp*(pid[1].bias-pid[1].lastBias)+pid[1].ki*pid[1].bias;
;;;324    		pid[1].lastBias=pid[1].bias;
;;;325    		/*限幅*/
;;;326    		pid[1].pwm = bsp_PwmLimit(pid[1].pwm);
;;;327    		/*设置PWM*/
;;;328    		bsp_MotorSetPWM(MotorRight,pid[1].pwm >0 ? Backward : Forward ,myabs(pid[1].pwm));
;;;329    	}
;;;330    	
;;;331    }
0000b2  e8bd87f0          POP      {r4-r10,pc}
                  |L8.182|
0000b6  1b70              SUBS     r0,r6,r5              ;301
0000b8  f7fffffe          BL       __aeabi_i2f
0000bc  495c              LDR      r1,|L8.560|
0000be  6088              STR      r0,[r1,#8]            ;301  ; pid
0000c0  460a              MOV      r2,r1                 ;302
0000c2  6891              LDR      r1,[r2,#8]            ;302  ; pid
0000c4  6850              LDR      r0,[r2,#4]            ;302  ; pid
0000c6  f7fffffe          BL       __aeabi_fmul
0000ca  4681              MOV      r9,r0                 ;302
0000cc  4a58              LDR      r2,|L8.560|
0000ce  68d1              LDR      r1,[r2,#0xc]          ;302  ; pid
0000d0  6890              LDR      r0,[r2,#8]            ;302  ; pid
0000d2  f7fffffe          BL       __aeabi_fsub
0000d6  4682              MOV      r10,r0                ;302
0000d8  4855              LDR      r0,|L8.560|
0000da  6801              LDR      r1,[r0,#0]            ;302  ; pid
0000dc  4650              MOV      r0,r10                ;302
0000de  f7fffffe          BL       __aeabi_fmul
0000e2  4680              MOV      r8,r0                 ;302
0000e4  4649              MOV      r1,r9                 ;302
0000e6  f7fffffe          BL       __aeabi_fadd
0000ea  4607              MOV      r7,r0                 ;302
0000ec  4850              LDR      r0,|L8.560|
0000ee  6901              LDR      r1,[r0,#0x10]         ;302  ; pid
0000f0  4638              MOV      r0,r7                 ;302
0000f2  f7fffffe          BL       __aeabi_fadd
0000f6  494e              LDR      r1,|L8.560|
0000f8  6108              STR      r0,[r1,#0x10]         ;302  ; pid
0000fa  4608              MOV      r0,r1                 ;303
0000fc  6880              LDR      r0,[r0,#8]            ;303  ; pid
0000fe  60c8              STR      r0,[r1,#0xc]          ;303  ; pid
000100  6908              LDR      r0,[r1,#0x10]         ;305  ; pid
000102  f7fffffe          BL       __aeabi_f2iz
000106  4680              MOV      r8,r0                 ;305
000108  f7fffffe          BL       bsp_PwmLimit
00010c  4607              MOV      r7,r0                 ;305
00010e  f7fffffe          BL       __aeabi_i2f
000112  4947              LDR      r1,|L8.560|
000114  6108              STR      r0,[r1,#0x10]         ;305  ; pid
000116  6908              LDR      r0,[r1,#0x10]         ;307  ; pid
000118  f7fffffe          BL       __aeabi_f2iz
00011c  4681              MOV      r9,r0                 ;307
00011e  f7fffffe          BL       myabs
000122  b287              UXTH     r7,r0                 ;307
000124  4942              LDR      r1,|L8.560|
000126  6908              LDR      r0,[r1,#0x10]         ;307  ; pid
000128  2100              MOVS     r1,#0                 ;307
00012a  f7fffffe          BL       __aeabi_cfrcmple
00012e  d201              BCS      |L8.308|
000130  2001              MOVS     r0,#1                 ;307
000132  e000              B        |L8.310|
                  |L8.308|
000134  2000              MOVS     r0,#0                 ;307
                  |L8.310|
000136  4680              MOV      r8,r0                 ;307
000138  463a              MOV      r2,r7                 ;307
00013a  4641              MOV      r1,r8                 ;307
00013c  2000              MOVS     r0,#0                 ;307
00013e  f7fffffe          BL       bsp_MotorSetPWM
000142  e068              B        |L8.534|
                  |L8.324|
000144  2c01              CMP      r4,#1                 ;309
000146  d166              BNE      |L8.534|
000148  2d00              CMP      r5,#0                 ;309
00014a  d164              BNE      |L8.534|
00014c  4838              LDR      r0,|L8.560|
00014e  6b40              LDR      r0,[r0,#0x34]         ;311
000150  b910              CBNZ     r0,|L8.344|
000152  4837              LDR      r0,|L8.560|
000154  6345              STR      r5,[r0,#0x34]         ;313
000156  e017              B        |L8.392|
                  |L8.344|
000158  4628              MOV      r0,r5                 ;315
00015a  f7fffffe          BL       __aeabi_i2f
00015e  4680              MOV      r8,r0                 ;315
000160  4933              LDR      r1,|L8.560|
000162  6b48              LDR      r0,[r1,#0x34]         ;315
000164  f7fffffe          BL       __aeabi_i2f
000168  4681              MOV      r9,r0                 ;315
00016a  4641              MOV      r1,r8                 ;315
00016c  f7fffffe          BL       __aeabi_fdiv
000170  4607              MOV      r7,r0                 ;315
000172  2100              MOVS     r1,#0                 ;315
000174  f7fffffe          BL       __aeabi_cfcmple
000178  d206              BCS      |L8.392|
00017a  4620              MOV      r0,r4                 ;317
00017c  f7fffffe          BL       bsp_MotorBrake
000180  4620              MOV      r0,r4                 ;318
000182  f7fffffe          BL       bsp_PidClear
000186  e794              B        |L8.178|
                  |L8.392|
000188  1b70              SUBS     r0,r6,r5              ;322
00018a  f7fffffe          BL       __aeabi_i2f
00018e  4928              LDR      r1,|L8.560|
000190  6248              STR      r0,[r1,#0x24]         ;322
000192  460a              MOV      r2,r1                 ;323
000194  6a51              LDR      r1,[r2,#0x24]         ;323
000196  6a10              LDR      r0,[r2,#0x20]         ;323
000198  f7fffffe          BL       __aeabi_fmul
00019c  4681              MOV      r9,r0                 ;323
00019e  4a24              LDR      r2,|L8.560|
0001a0  6a91              LDR      r1,[r2,#0x28]         ;323
0001a2  6a50              LDR      r0,[r2,#0x24]         ;323
0001a4  f7fffffe          BL       __aeabi_fsub
0001a8  4682              MOV      r10,r0                ;323
0001aa  4821              LDR      r0,|L8.560|
0001ac  69c1              LDR      r1,[r0,#0x1c]         ;323  ; pid
0001ae  4650              MOV      r0,r10                ;323
0001b0  f7fffffe          BL       __aeabi_fmul
0001b4  4680              MOV      r8,r0                 ;323
0001b6  4649              MOV      r1,r9                 ;323
0001b8  f7fffffe          BL       __aeabi_fadd
0001bc  4607              MOV      r7,r0                 ;323
0001be  481c              LDR      r0,|L8.560|
0001c0  6ac1              LDR      r1,[r0,#0x2c]         ;323
0001c2  4638              MOV      r0,r7                 ;323
0001c4  f7fffffe          BL       __aeabi_fadd
0001c8  4919              LDR      r1,|L8.560|
0001ca  62c8              STR      r0,[r1,#0x2c]         ;323
0001cc  4608              MOV      r0,r1                 ;324
0001ce  6a41              LDR      r1,[r0,#0x24]         ;324
0001d0  6281              STR      r1,[r0,#0x28]         ;324
0001d2  4601              MOV      r1,r0                 ;326
0001d4  6ac8              LDR      r0,[r1,#0x2c]         ;326
0001d6  f7fffffe          BL       __aeabi_f2iz
0001da  4680              MOV      r8,r0                 ;326
0001dc  f7fffffe          BL       bsp_PwmLimit
0001e0  4607              MOV      r7,r0                 ;326
0001e2  f7fffffe          BL       __aeabi_i2f
0001e6  4912              LDR      r1,|L8.560|
0001e8  62c8              STR      r0,[r1,#0x2c]         ;326
0001ea  6ac8              LDR      r0,[r1,#0x2c]         ;328
0001ec  f7fffffe          BL       __aeabi_f2iz
0001f0  4681              MOV      r9,r0                 ;328
0001f2  f7fffffe          BL       myabs
0001f6  b287              UXTH     r7,r0                 ;328
0001f8  490d              LDR      r1,|L8.560|
0001fa  6ac8              LDR      r0,[r1,#0x2c]         ;328
0001fc  2100              MOVS     r1,#0                 ;328
0001fe  f7fffffe          BL       __aeabi_cfrcmple
000202  d201              BCS      |L8.520|
000204  2001              MOVS     r0,#1                 ;328
000206  e000              B        |L8.522|
                  |L8.520|
000208  2000              MOVS     r0,#0                 ;328
                  |L8.522|
00020a  4680              MOV      r8,r0                 ;328
00020c  463a              MOV      r2,r7                 ;328
00020e  4641              MOV      r1,r8                 ;328
000210  2001              MOVS     r0,#1                 ;328
000212  f7fffffe          BL       bsp_MotorSetPWM
                  |L8.534|
000216  bf00              NOP      
000218  e74b              B        |L8.178|
;;;332    
                          ENDP

00021a  0000              DCW      0x0000
                  |L8.540|
                          DCD      encoderPulseVector
                  |L8.544|
                          DCD      0x41400000
                  |L8.548|
                          DCD      0x437a0000
                  |L8.552|
                          DCD      sampleIndex
                  |L8.556|
                          DCD      speed
                  |L8.560|
                          DCD      pid

                          AREA ||i.bsp_PidSched||, CODE, READONLY, ALIGN=2

                  bsp_PidSched PROC
;;;115    */
;;;116    void bsp_PidSched(void)
000000  b510              PUSH     {r4,lr}
;;;117    {
;;;118    	bsp_PidExec(MotorLeft, bsp_EncoderGetPulseT(EncoderLeft), pid[0].target);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       bsp_EncoderGetPulseT
000008  4604              MOV      r4,r0
00000a  4808              LDR      r0,|L9.44|
00000c  6942              LDR      r2,[r0,#0x14]  ; pid
00000e  4621              MOV      r1,r4
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       bsp_PidExec
;;;119    	bsp_PidExec(MotorRight,bsp_EncoderGetPulseT(EncoderRight),pid[1].target);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       bsp_EncoderGetPulseT
00001c  4604              MOV      r4,r0
00001e  4803              LDR      r0,|L9.44|
000020  6b02              LDR      r2,[r0,#0x30]
000022  4621              MOV      r1,r4
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       bsp_PidExec
;;;120    }
00002a  bd10              POP      {r4,pc}
;;;121    
                          ENDP

                  |L9.44|
                          DCD      pid

                          AREA ||i.bsp_PwmLimit||, CODE, READONLY, ALIGN=2

                  bsp_PwmLimit PROC
;;;341    */
;;;342    static int32_t bsp_PwmLimit(int32_t pwm)
000000  4601              MOV      r1,r0
;;;343    {
;;;344    	int32_t ret = 0 ;
000002  2000              MOVS     r0,#0
;;;345    	
;;;346    	if(pwm >= MAX_PWM)
000004  f5b16f61          CMP      r1,#0xe10
000008  db02              BLT      |L10.16|
;;;347    	{
;;;348    		ret = MAX_PWM;
00000a  f44f6061          MOV      r0,#0xe10
00000e  e005              B        |L10.28|
                  |L10.16|
;;;349    	}
;;;350    	else if(pwm <= -MAX_PWM)
000010  f5116f61          CMN      r1,#0xe10
000014  dc01              BGT      |L10.26|
;;;351    	{
;;;352    		ret = -MAX_PWM;
000016  4802              LDR      r0,|L10.32|
000018  e000              B        |L10.28|
                  |L10.26|
;;;353    	}
;;;354    	else
;;;355    	{
;;;356    		ret = pwm;
00001a  4608              MOV      r0,r1
                  |L10.28|
;;;357    	}
;;;358    	
;;;359    	return ret;
;;;360    }	
00001c  4770              BX       lr
;;;361    
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      0xfffff1f0

                          AREA ||i.bsp_SetMotorSpeed||, CODE, READONLY, ALIGN=2

                  bsp_SetMotorSpeed PROC
;;;82     */
;;;83     void bsp_SetMotorSpeed(MotorSN sn , int32_t speed)
000000  b910              CBNZ     r0,|L11.8|
;;;84     {
;;;85     	if(sn == MotorLeft)
;;;86     	{
;;;87     		pid[0].target = speed;
000002  4a04              LDR      r2,|L11.20|
000004  6151              STR      r1,[r2,#0x14]  ; pid
000006  e003              B        |L11.16|
                  |L11.8|
;;;88     	}
;;;89     	else if(sn == MotorRight)
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L11.16|
;;;90     	{
;;;91     		pid[1].target = speed;
00000c  4a01              LDR      r2,|L11.20|
00000e  6311              STR      r1,[r2,#0x30]
                  |L11.16|
;;;92     	}
;;;93     }
000010  4770              BX       lr
;;;94     
                          ENDP

000012  0000              DCW      0x0000
                  |L11.20|
                          DCD      pid

                          AREA ||i.myabs||, CODE, READONLY, ALIGN=1

                  myabs PROC
;;;370    */
;;;371    static int32_t myabs(int32_t val)
000000  4601              MOV      r1,r0
;;;372    { 		   
;;;373        int32_t temp;
;;;374    	
;;;375        if(val < 0)  
000002  2900              CMP      r1,#0
000004  da01              BGE      |L12.10|
;;;376    		temp = -val;  
000006  4248              RSBS     r0,r1,#0
000008  e000              B        |L12.12|
                  |L12.10|
;;;377        else 
;;;378    		temp = val;
00000a  4608              MOV      r0,r1
                  |L12.12|
;;;379    	
;;;380        return temp;
;;;381    }
00000c  4770              BX       lr
;;;382    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pid
                          %        56
                  speed
                          %        80

                          AREA ||.data||, DATA, ALIGN=2

                  encoderPulseVector
                          %        8
                  sampleIndex
000008  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\src\\bsp_Control.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_Control_c_03aaa559____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_Control_c_03aaa559____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_Control_c_03aaa559____REVSH|
#line 128
|__asm___13_bsp_Control_c_03aaa559____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
