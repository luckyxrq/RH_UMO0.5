; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_cliffsw.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_cliffsw.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\app\inc -IF:\LuckyXRQ\CleanCar\Project\MDK-ARM(uV4)\RTE -ID:\soft\MDK5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\soft\MDK5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_cliffsw.crf ..\..\User\app\src\bsp_CliffSW.c]
                          THUMB

                          AREA ||i.bsp_GetCliffVoltage||, CODE, READONLY, ALIGN=2

                  bsp_GetCliffVoltage PROC
;;;157    */
;;;158    float bsp_GetCliffVoltage(CliffSWSN sn)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;159    {
000004  4604              MOV      r4,r0
;;;160    	float ret = 0 ;
000006  2500              MOVS     r5,#0
;;;161    	
;;;162    	switch(sn)
000008  b124              CBZ      r4,|L1.20|
00000a  2c01              CMP      r4,#1
00000c  d024              BEQ      |L1.88|
00000e  2c02              CMP      r4,#2
000010  d166              BNE      |L1.224|
000012  e043              B        |L1.156|
                  |L1.20|
;;;163    	{
;;;164    		case Cliff1:
;;;165    		{
;;;166    			ADC_RegularChannelConfig(ADC2, ADC_Channel_7, 1, ADC_SampleTime_239Cycles5 );
000014  2307              MOVS     r3,#7
000016  2201              MOVS     r2,#1
000018  4619              MOV      r1,r3
00001a  4833              LDR      r0,|L1.232|
00001c  f7fffffe          BL       ADC_RegularChannelConfig
;;;167    			ADC_SoftwareStartConvCmd(ADC2, ENABLE);	
000020  2101              MOVS     r1,#1
000022  4831              LDR      r0,|L1.232|
000024  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;168    			while(!ADC_GetFlagStatus(ADC2, ADC_FLAG_EOC ));
000028  bf00              NOP      
                  |L1.42|
00002a  2102              MOVS     r1,#2
00002c  482e              LDR      r0,|L1.232|
00002e  f7fffffe          BL       ADC_GetFlagStatus
000032  2800              CMP      r0,#0
000034  d0f9              BEQ      |L1.42|
;;;169    			ret = ADC_GetConversionValue(ADC2) * 3.3F / 4096;
000036  482c              LDR      r0,|L1.232|
000038  f7fffffe          BL       ADC_GetConversionValue
00003c  4680              MOV      r8,r0
00003e  f7fffffe          BL       __aeabi_ui2f
000042  4607              MOV      r7,r0
000044  4929              LDR      r1,|L1.236|
000046  f7fffffe          BL       __aeabi_fmul
00004a  4606              MOV      r6,r0
00004c  f04f418b          MOV      r1,#0x45800000
000050  f7fffffe          BL       __aeabi_fdiv
000054  4605              MOV      r5,r0
;;;170    		}break;
000056  e043              B        |L1.224|
                  |L1.88|
;;;171    		
;;;172    		case Cliff2:
;;;173    		{
;;;174    			ADC_RegularChannelConfig(ADC2, ADC_Channel_6, 1, ADC_SampleTime_239Cycles5 );
000058  2307              MOVS     r3,#7
00005a  2201              MOVS     r2,#1
00005c  2106              MOVS     r1,#6
00005e  4822              LDR      r0,|L1.232|
000060  f7fffffe          BL       ADC_RegularChannelConfig
;;;175    			ADC_SoftwareStartConvCmd(ADC2, ENABLE);	
000064  2101              MOVS     r1,#1
000066  4820              LDR      r0,|L1.232|
000068  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;176    			while(!ADC_GetFlagStatus(ADC2, ADC_FLAG_EOC ));
00006c  bf00              NOP      
                  |L1.110|
00006e  2102              MOVS     r1,#2
000070  481d              LDR      r0,|L1.232|
000072  f7fffffe          BL       ADC_GetFlagStatus
000076  2800              CMP      r0,#0
000078  d0f9              BEQ      |L1.110|
;;;177    			ret = ADC_GetConversionValue(ADC2) * 3.3F / 4096;
00007a  481b              LDR      r0,|L1.232|
00007c  f7fffffe          BL       ADC_GetConversionValue
000080  4680              MOV      r8,r0
000082  f7fffffe          BL       __aeabi_ui2f
000086  4607              MOV      r7,r0
000088  4918              LDR      r1,|L1.236|
00008a  f7fffffe          BL       __aeabi_fmul
00008e  4606              MOV      r6,r0
000090  f04f418b          MOV      r1,#0x45800000
000094  f7fffffe          BL       __aeabi_fdiv
000098  4605              MOV      r5,r0
;;;178    		}break;
00009a  e021              B        |L1.224|
                  |L1.156|
;;;179    		
;;;180    		case Cliff3:
;;;181    		{
;;;182    			ADC_RegularChannelConfig(ADC3, ADC_Channel_7, 1, ADC_SampleTime_239Cycles5 );
00009c  2307              MOVS     r3,#7
00009e  2201              MOVS     r2,#1
0000a0  4619              MOV      r1,r3
0000a2  4813              LDR      r0,|L1.240|
0000a4  f7fffffe          BL       ADC_RegularChannelConfig
;;;183    			ADC_SoftwareStartConvCmd(ADC3, ENABLE);	
0000a8  2101              MOVS     r1,#1
0000aa  4811              LDR      r0,|L1.240|
0000ac  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;184    			while(!ADC_GetFlagStatus(ADC3, ADC_FLAG_EOC ));
0000b0  bf00              NOP      
                  |L1.178|
0000b2  2102              MOVS     r1,#2
0000b4  480e              LDR      r0,|L1.240|
0000b6  f7fffffe          BL       ADC_GetFlagStatus
0000ba  2800              CMP      r0,#0
0000bc  d0f9              BEQ      |L1.178|
;;;185    			ret = ADC_GetConversionValue(ADC3) * 3.3F / 4096;
0000be  480c              LDR      r0,|L1.240|
0000c0  f7fffffe          BL       ADC_GetConversionValue
0000c4  4680              MOV      r8,r0
0000c6  f7fffffe          BL       __aeabi_ui2f
0000ca  4607              MOV      r7,r0
0000cc  4907              LDR      r1,|L1.236|
0000ce  f7fffffe          BL       __aeabi_fmul
0000d2  4606              MOV      r6,r0
0000d4  f04f418b          MOV      r1,#0x45800000
0000d8  f7fffffe          BL       __aeabi_fdiv
0000dc  4605              MOV      r5,r0
;;;186    		}break;
0000de  bf00              NOP      
                  |L1.224|
0000e0  bf00              NOP                            ;170
;;;187    	}
;;;188    	
;;;189    	return ret;
0000e2  4628              MOV      r0,r5
;;;190    }
0000e4  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

                  |L1.232|
                          DCD      0x40012800
                  |L1.236|
                          DCD      0x40533333
                  |L1.240|
                          DCD      0x40013c00

                          AREA ||i.bsp_InitCliffSW||, CODE, READONLY, ALIGN=2

                  bsp_InitCliffSW PROC
;;;13     */
;;;14     void bsp_InitCliffSW(void)
000000  b500              PUSH     {lr}
;;;15     {
000002  b087              SUB      sp,sp,#0x1c
;;;16     	ADC_InitTypeDef ADC_InitStructure; 
;;;17     	GPIO_InitTypeDef GPIO_InitStructure;
;;;18     	
;;;19     	/*跳崖1*/
;;;20     	{
;;;21     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA |RCC_APB2Periph_ADC2, ENABLE );
000004  2101              MOVS     r1,#1
000006  f2404004          MOV      r0,#0x404
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;22      
;;;23     		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;24     		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
00000e  f44f4000          MOV      r0,#0x8000
000012  f7fffffe          BL       RCC_ADCCLKConfig
;;;25                       
;;;26     		/*配置引脚为模拟输入模式*/
;;;27     		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
000016  2080              MOVS     r0,#0x80
000018  f8ad0004          STRH     r0,[sp,#4]
;;;28     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00001c  2000              MOVS     r0,#0
00001e  f88d0007          STRB     r0,[sp,#7]
;;;29     		GPIO_Init(GPIOA, &GPIO_InitStructure);	
000022  a901              ADD      r1,sp,#4
000024  485f              LDR      r0,|L2.420|
000026  f7fffffe          BL       GPIO_Init
;;;30     
;;;31     		/*复位ADC*/
;;;32     		ADC_DeInit(ADC2);
00002a  485f              LDR      r0,|L2.424|
00002c  f7fffffe          BL       ADC_DeInit
;;;33     
;;;34     		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000030  2000              MOVS     r0,#0
000032  9002              STR      r0,[sp,#8]
;;;35     		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
000034  f88d000c          STRB     r0,[sp,#0xc]
;;;36     		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
000038  f88d000d          STRB     r0,[sp,#0xd]
;;;37     		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
00003c  f44f2060          MOV      r0,#0xe0000
000040  9004              STR      r0,[sp,#0x10]
;;;38     		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000042  2000              MOVS     r0,#0
000044  9005              STR      r0,[sp,#0x14]
;;;39     		ADC_InitStructure.ADC_NbrOfChannel = 1;
000046  2001              MOVS     r0,#1
000048  f88d0018          STRB     r0,[sp,#0x18]
;;;40     		ADC_Init(ADC2, &ADC_InitStructure);  
00004c  a902              ADD      r1,sp,#8
00004e  4856              LDR      r0,|L2.424|
000050  f7fffffe          BL       ADC_Init
;;;41     
;;;42     		/*使能指定的ADC*/
;;;43     		ADC_Cmd(ADC2, ENABLE);
000054  2101              MOVS     r1,#1
000056  4854              LDR      r0,|L2.424|
000058  f7fffffe          BL       ADC_Cmd
;;;44     		
;;;45     		/*使能复位校准 */
;;;46     		ADC_ResetCalibration(ADC2);
00005c  4852              LDR      r0,|L2.424|
00005e  f7fffffe          BL       ADC_ResetCalibration
;;;47     		 
;;;48     		/*等待复位校准结束*/
;;;49     		while(ADC_GetResetCalibrationStatus(ADC2));
000062  bf00              NOP      
                  |L2.100|
000064  4850              LDR      r0,|L2.424|
000066  f7fffffe          BL       ADC_GetResetCalibrationStatus
00006a  2800              CMP      r0,#0
00006c  d1fa              BNE      |L2.100|
;;;50     		
;;;51     		/*开启AD校准*/
;;;52     		ADC_StartCalibration(ADC2);
00006e  484e              LDR      r0,|L2.424|
000070  f7fffffe          BL       ADC_StartCalibration
;;;53     	 
;;;54     		/*等待校准结束*/
;;;55     		while(ADC_GetCalibrationStatus(ADC2));
000074  bf00              NOP      
                  |L2.118|
000076  484c              LDR      r0,|L2.424|
000078  f7fffffe          BL       ADC_GetCalibrationStatus
00007c  2800              CMP      r0,#0
00007e  d1fa              BNE      |L2.118|
;;;56     		
;;;57     		/*ADC,ADC通道,采样时间为239.5周期*/
;;;58     		ADC_RegularChannelConfig(ADC2, ADC_Channel_7, 1, ADC_SampleTime_239Cycles5 );
000080  2307              MOVS     r3,#7
000082  2201              MOVS     r2,#1
000084  4619              MOV      r1,r3
000086  4848              LDR      r0,|L2.424|
000088  f7fffffe          BL       ADC_RegularChannelConfig
;;;59     	}
;;;60     	
;;;61     	
;;;62     	/*跳崖2*/
;;;63     	{
;;;64     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA |RCC_APB2Periph_ADC2, ENABLE );
00008c  2101              MOVS     r1,#1
00008e  f2404004          MOV      r0,#0x404
000092  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;65      
;;;66     		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;67     		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
000096  f44f4000          MOV      r0,#0x8000
00009a  f7fffffe          BL       RCC_ADCCLKConfig
;;;68                       
;;;69     		/*配置引脚为模拟输入模式*/
;;;70     		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
00009e  2040              MOVS     r0,#0x40
0000a0  f8ad0004          STRH     r0,[sp,#4]
;;;71     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
0000a4  2000              MOVS     r0,#0
0000a6  f88d0007          STRB     r0,[sp,#7]
;;;72     		GPIO_Init(GPIOA, &GPIO_InitStructure);	
0000aa  a901              ADD      r1,sp,#4
0000ac  483d              LDR      r0,|L2.420|
0000ae  f7fffffe          BL       GPIO_Init
;;;73     
;;;74     		/*复位ADC*/
;;;75     		ADC_DeInit(ADC2);
0000b2  483d              LDR      r0,|L2.424|
0000b4  f7fffffe          BL       ADC_DeInit
;;;76     
;;;77     		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
0000b8  2000              MOVS     r0,#0
0000ba  9002              STR      r0,[sp,#8]
;;;78     		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
0000bc  f88d000c          STRB     r0,[sp,#0xc]
;;;79     		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
0000c0  f88d000d          STRB     r0,[sp,#0xd]
;;;80     		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
0000c4  f44f2060          MOV      r0,#0xe0000
0000c8  9004              STR      r0,[sp,#0x10]
;;;81     		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
0000ca  2000              MOVS     r0,#0
0000cc  9005              STR      r0,[sp,#0x14]
;;;82     		ADC_InitStructure.ADC_NbrOfChannel = 1;
0000ce  2001              MOVS     r0,#1
0000d0  f88d0018          STRB     r0,[sp,#0x18]
;;;83     		ADC_Init(ADC2, &ADC_InitStructure);  
0000d4  a902              ADD      r1,sp,#8
0000d6  4834              LDR      r0,|L2.424|
0000d8  f7fffffe          BL       ADC_Init
;;;84     
;;;85     		/*使能指定的ADC*/
;;;86     		ADC_Cmd(ADC2, ENABLE);
0000dc  2101              MOVS     r1,#1
0000de  4832              LDR      r0,|L2.424|
0000e0  f7fffffe          BL       ADC_Cmd
;;;87     		
;;;88     		/*使能复位校准 */
;;;89     		ADC_ResetCalibration(ADC2);
0000e4  4830              LDR      r0,|L2.424|
0000e6  f7fffffe          BL       ADC_ResetCalibration
;;;90     		 
;;;91     		/*等待复位校准结束*/
;;;92     		while(ADC_GetResetCalibrationStatus(ADC2));
0000ea  bf00              NOP      
                  |L2.236|
0000ec  482e              LDR      r0,|L2.424|
0000ee  f7fffffe          BL       ADC_GetResetCalibrationStatus
0000f2  2800              CMP      r0,#0
0000f4  d1fa              BNE      |L2.236|
;;;93     		
;;;94     		/*开启AD校准*/
;;;95     		ADC_StartCalibration(ADC2);
0000f6  482c              LDR      r0,|L2.424|
0000f8  f7fffffe          BL       ADC_StartCalibration
;;;96     	 
;;;97     		/*等待校准结束*/
;;;98     		while(ADC_GetCalibrationStatus(ADC2));
0000fc  bf00              NOP      
                  |L2.254|
0000fe  482a              LDR      r0,|L2.424|
000100  f7fffffe          BL       ADC_GetCalibrationStatus
000104  2800              CMP      r0,#0
000106  d1fa              BNE      |L2.254|
;;;99     		
;;;100    		/*ADC,ADC通道,采样时间为239.5周期*/
;;;101    		ADC_RegularChannelConfig(ADC2, ADC_Channel_6, 1, ADC_SampleTime_239Cycles5 );
000108  2307              MOVS     r3,#7
00010a  2201              MOVS     r2,#1
00010c  2106              MOVS     r1,#6
00010e  4826              LDR      r0,|L2.424|
000110  f7fffffe          BL       ADC_RegularChannelConfig
;;;102    	}
;;;103    	
;;;104    	/*跳崖3*/
;;;105    	{
;;;106    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF |RCC_APB2Periph_ADC3, ENABLE );
000114  2101              MOVS     r1,#1
000116  f2480080          MOV      r0,#0x8080
00011a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;107     
;;;108    		/*设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M*/
;;;109    		RCC_ADCCLKConfig(RCC_PCLK2_Div6);
00011e  f44f4000          MOV      r0,#0x8000
000122  f7fffffe          BL       RCC_ADCCLKConfig
;;;110                      
;;;111    		/*配置引脚为模拟输入模式*/
;;;112    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000126  f44f7000          MOV      r0,#0x200
00012a  f8ad0004          STRH     r0,[sp,#4]
;;;113    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00012e  2000              MOVS     r0,#0
000130  f88d0007          STRB     r0,[sp,#7]
;;;114    		GPIO_Init(GPIOF, &GPIO_InitStructure);	
000134  a901              ADD      r1,sp,#4
000136  481d              LDR      r0,|L2.428|
000138  f7fffffe          BL       GPIO_Init
;;;115    
;;;116    		/*复位ADC*/
;;;117    		ADC_DeInit(ADC3);
00013c  481c              LDR      r0,|L2.432|
00013e  f7fffffe          BL       ADC_DeInit
;;;118    
;;;119    		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000142  2000              MOVS     r0,#0
000144  9002              STR      r0,[sp,#8]
;;;120    		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
000146  f88d000c          STRB     r0,[sp,#0xc]
;;;121    		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
00014a  f88d000d          STRB     r0,[sp,#0xd]
;;;122    		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
00014e  f44f2060          MOV      r0,#0xe0000
000152  9004              STR      r0,[sp,#0x10]
;;;123    		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000154  2000              MOVS     r0,#0
000156  9005              STR      r0,[sp,#0x14]
;;;124    		ADC_InitStructure.ADC_NbrOfChannel = 1;
000158  2001              MOVS     r0,#1
00015a  f88d0018          STRB     r0,[sp,#0x18]
;;;125    		ADC_Init(ADC3, &ADC_InitStructure);  
00015e  a902              ADD      r1,sp,#8
000160  4813              LDR      r0,|L2.432|
000162  f7fffffe          BL       ADC_Init
;;;126    
;;;127    		/*使能指定的ADC*/
;;;128    		ADC_Cmd(ADC3, ENABLE);
000166  2101              MOVS     r1,#1
000168  4811              LDR      r0,|L2.432|
00016a  f7fffffe          BL       ADC_Cmd
;;;129    		
;;;130    		/*使能复位校准 */
;;;131    		ADC_ResetCalibration(ADC3);
00016e  4810              LDR      r0,|L2.432|
000170  f7fffffe          BL       ADC_ResetCalibration
;;;132    		 
;;;133    		/*等待复位校准结束*/
;;;134    		while(ADC_GetResetCalibrationStatus(ADC3));
000174  bf00              NOP      
                  |L2.374|
000176  480e              LDR      r0,|L2.432|
000178  f7fffffe          BL       ADC_GetResetCalibrationStatus
00017c  2800              CMP      r0,#0
00017e  d1fa              BNE      |L2.374|
;;;135    		
;;;136    		/*开启AD校准*/
;;;137    		ADC_StartCalibration(ADC3);
000180  480b              LDR      r0,|L2.432|
000182  f7fffffe          BL       ADC_StartCalibration
;;;138    	 
;;;139    		/*等待校准结束*/
;;;140    		while(ADC_GetCalibrationStatus(ADC3));
000186  bf00              NOP      
                  |L2.392|
000188  4809              LDR      r0,|L2.432|
00018a  f7fffffe          BL       ADC_GetCalibrationStatus
00018e  2800              CMP      r0,#0
000190  d1fa              BNE      |L2.392|
;;;141    		
;;;142    		/*ADC,ADC通道,采样时间为239.5周期*/
;;;143    		ADC_RegularChannelConfig(ADC3, ADC_Channel_7, 1, ADC_SampleTime_239Cycles5 );
000192  2307              MOVS     r3,#7
000194  2201              MOVS     r2,#1
000196  4619              MOV      r1,r3
000198  4805              LDR      r0,|L2.432|
00019a  f7fffffe          BL       ADC_RegularChannelConfig
;;;144    	}	
;;;145    
;;;146    }
00019e  b007              ADD      sp,sp,#0x1c
0001a0  bd00              POP      {pc}
;;;147    
                          ENDP

0001a2  0000              DCW      0x0000
                  |L2.420|
                          DCD      0x40010800
                  |L2.424|
                          DCD      0x40012800
                  |L2.428|
                          DCD      0x40011c00
                  |L2.432|
                          DCD      0x40013c00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\src\\bsp_CliffSW.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_CliffSW_c_4df603ba____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_CliffSW_c_4df603ba____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_CliffSW_c_4df603ba____REVSH|
#line 128
|__asm___13_bsp_CliffSW_c_4df603ba____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
